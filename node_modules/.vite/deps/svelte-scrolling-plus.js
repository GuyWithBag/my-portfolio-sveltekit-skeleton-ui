import {
  writable
} from "./chunk-E6ZP6LG5.js";
import {
  cubicInOut
} from "./chunk-M6MB33T7.js";
import {
  get_store_value,
  noop,
  now
} from "./chunk-RVLVW3YK.js";

// node_modules/svelte-scrolling-plus/dist/store/index.js
var elements = writable([]);
var actors = writable([]);
var globalOptions = writable({
  offset: 0,
  duration: 500,
  easing: cubicInOut,
  onStart: noop,
  onDone: noop
});

// node_modules/svelte-scrolling-plus/dist/internal/globalOptions.js
var globalOpts = get_store_value(globalOptions);
var getGlobalOptions = () => {
  return globalOpts;
};
var setGlobalOptions = (options) => {
  globalOptions.update(() => Object.assign(globalOpts, options));
};
var globalOptions_default = setGlobalOptions;

// node_modules/svelte-scrolling-plus/dist/shared/utils.js
var sanitize = (hash) => {
  return hash.replace(/[^A-Z0-9]/gi, "").toLowerCase();
};
var getElement = (elementsList2, reference) => {
  const elements2 = elementsList2.filter((element) => {
    const elementRef = element.reference;
    return elementRef === reference;
  });
  return elements2.length ? elements2[0].node : null;
};
var getActor = (actorsList, reference) => {
  const actors2 = actorsList.filter((actor) => {
    const actorRef = actor.reference;
    return actorRef === reference;
  });
  return actors2.length ? actors2[0] : null;
};
var getPosition = (element) => {
  return element.offsetTop;
};

// node_modules/svelte-scrolling-plus/dist/shared/smoothScroll.js
var currentPosition = (start, end, elapsed, duration, easing) => {
  if (elapsed > duration)
    return end;
  return start + (end - start) * easing(elapsed / duration);
};
var smoothScroll = async (options, callback) => {
  return new Promise((resolve) => {
    const { start, end, duration, easing } = options;
    const clock = now();
    const step = () => {
      const elapsed = now() - clock;
      const position = currentPosition(start, end, elapsed, duration, easing);
      callback(position);
      if (elapsed > duration)
        return resolve();
      window.requestAnimationFrame(step);
    };
    window.requestAnimationFrame(step);
  });
};
var smoothScroll_default = smoothScroll;

// node_modules/svelte-scrolling-plus/dist/shared/scrolling.js
var globalOptions2 = getGlobalOptions();
var scrolling = async (endPosition, opts) => {
  const { duration, easing, offset } = Object.assign(globalOptions2, opts);
  const start = window.pageYOffset;
  const end = endPosition + offset;
  await smoothScroll_default({ start, end, duration, easing }, (position) => {
    window.scroll(0, position);
  });
};
var scrolling_default = scrolling;

// node_modules/svelte-scrolling-plus/dist/actions/ScrollTo.js
var elementsList = get_store_value(elements);
var handle = async (event, options) => {
  event.preventDefault();
  const { ref, onDone, onStart } = options;
  const duration = options.duration;
  const offset = options.offset;
  const easing = options.easing;
  const element = getElement(elementsList, ref);
  if (!element) {
    throw new Error(`Element reference '${ref}' not found`);
  }
  const endPosition = getPosition(element);
  onStart && onStart({ element, offset, duration, endPosition });
  await scrolling_default(endPosition, { duration, offset, easing });
  onDone && onDone({ element, offset, duration, endPosition });
};
var scrollTo = (node, options) => {
  if (!options) {
    throw new Error("scrollTo require a options");
  }
  let opts = Object.assign({
    // onStateChange: () => {},
    ref: ""
  }, getGlobalOptions());
  typeof options === "string" ? opts.ref = options : opts = Object.assign(opts, options);
  opts.ref = sanitize(opts.ref);
  if (!opts.ref) {
    throw new Error("scrollTo require a reference");
  }
  if (node instanceof HTMLAnchorElement) {
    node.href = `#${opts.ref}`;
  }
  if (node instanceof HTMLAnchorElement === false) {
    node.style.cursor = "pointer";
  }
  node.addEventListener("click", (event) => handle(event, opts));
  node.addEventListener("touchstart", (event) => handle(event, opts));
  if (opts.onStateChange) {
    const actorsList = get_store_value(actors);
    actorsList.push({
      node,
      reference: opts.ref,
      onStateChange: opts.onStateChange
    });
  }
  return {
    destroy() {
      node.removeEventListener("click", (event) => handle(event, opts));
      node.removeEventListener("touchstart", (event) => handle(event, opts));
    }
  };
};
var ScrollTo_default = scrollTo;

// node_modules/svelte-scrolling-plus/dist/actions/ScrollRef.js
var handleScroll = async (event, options) => {
  event.preventDefault();
  const { ref, node } = options;
  const actorsList = get_store_value(actors);
  const actor = getActor(actorsList, ref);
  if (!actor) {
    throw new Error(`Element reference '${ref}' not found`);
  }
  const isVisibile = node.getBoundingClientRect().top < window.innerHeight && node.getBoundingClientRect().bottom > 0;
  actor.onStateChange && actor.onStateChange({ active: isVisibile });
};
var scrollRef = (node, reference) => {
  if (!reference) {
    throw new Error("scrollRef require a reference");
  }
  const elementsList2 = get_store_value(elements);
  elementsList2.push({
    node,
    reference: sanitize(reference)
  });
  window.addEventListener("scroll", (e) => handleScroll(e, { node, ref: sanitize(reference) }));
  return {
    destroy() {
      elementsList2.length = 0;
      window.removeEventListener("scroll", (e) => handleScroll(e, { node, ref: sanitize(reference) }));
    }
  };
};
var ScrollRef_default = scrollRef;

// node_modules/svelte-scrolling-plus/dist/functions/scrolling.js
var globalOptions3 = getGlobalOptions();
var scrollTop = async (options) => {
  const opts = Object.assign(globalOptions3, options);
  const endPosition = 0;
  const { duration, offset, onStart, onDone } = opts;
  onStart && onStart({ offset, duration, endPosition });
  await scrolling_default(endPosition, opts);
  onDone && onDone({ offset, duration, endPosition });
};
var scrollBottom = async (options) => {
  const opts = Object.assign(globalOptions3, options);
  const { duration, offset, onStart, onDone } = opts;
  const body = document.body;
  const html = document.documentElement;
  const endPosition = Math.max(body.scrollHeight, body.offsetHeight, html.scrollHeight, html.clientHeight, html.offsetHeight);
  onStart && onStart({ offset, duration, endPosition });
  await scrolling_default(endPosition, opts);
  onDone && onDone({ offset, duration, endPosition });
};
var scrollElement = async (reference, options) => {
  if (!reference || typeof reference !== "string") {
    throw new Error("scrollElement require a reference valid");
  }
  const opts = Object.assign(globalOptions3, options);
  const ref = sanitize(reference);
  const { duration, offset, onStart, onDone } = opts;
  const elementsList2 = get_store_value(elements);
  const element = getElement(elementsList2, ref);
  if (!element) {
    throw new Error(`Element reference '${ref}' not found`);
  }
  const endPosition = getPosition(element);
  onStart && onStart({ element, offset, duration, endPosition });
  await scrolling_default(endPosition, opts);
  onDone && onDone({ element, offset, duration, endPosition });
};
var scrollPosition = async (position, options) => {
  if (!position || typeof position !== "number") {
    throw new Error("scrollPosition require a position value valid");
  }
  const opts = Object.assign(globalOptions3, options);
  const endPosition = position;
  const { duration, offset, onStart, onDone } = opts;
  onStart && onStart({ offset, duration, endPosition });
  await scrolling_default(endPosition, opts);
  onDone && onDone({ offset, duration, endPosition });
};
export {
  scrollBottom,
  scrollElement,
  scrollPosition,
  ScrollRef_default as scrollRef,
  ScrollTo_default as scrollTo,
  scrollTop,
  globalOptions_default as setGlobalOptions
};
//# sourceMappingURL=svelte-scrolling-plus.js.map
