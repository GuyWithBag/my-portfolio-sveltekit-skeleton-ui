import "./chunk-6A2TAOKG.js";
import {
  crossfade,
  fade,
  fly,
  scale,
  slide
} from "./chunk-UYDFXFL5.js";
import {
  flip
} from "./chunk-THUCJQDW.js";
import {
  BROWSER
} from "./chunk-IP2U24VQ.js";
import {
  writable
} from "./chunk-E6ZP6LG5.js";
import {
  cubicInOut
} from "./chunk-M6MB33T7.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  add_transform,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_animation,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  fix_and_outro_and_destroy_block,
  fix_position,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  head_selector,
  init,
  init_binding_group,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  select_multiple_value,
  select_option,
  select_options,
  select_value,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-RVLVW3YK.js";
import "./chunk-UXIASGQL.js";

// node_modules/@skeletonlabs/skeleton/dist/utilities/CodeBlock/stores.js
var storeHighlightJs = writable(void 0);

// node_modules/@skeletonlabs/skeleton/dist/utilities/Popup/popup.js
var storePopup = writable(void 0);
function popup(triggerNode, args) {
  const { computePosition, autoUpdate, offset, shift, flip: flip2, arrow, size, autoPlacement, hide, inline } = get_store_value(storePopup);
  const popupState = {
    open: false,
    autoUpdateCleanup: () => {
    }
  };
  const focusableAllowedList = ':is(a[href], button, input, textarea, select, details, [tabindex]):not([tabindex="-1"])';
  let focusablePopupElements;
  const documentationLink = "https://www.skeleton.dev/utilities/popups";
  let elemPopup;
  let elemArrow;
  function setDomElements() {
    elemPopup = document.querySelector(`[data-popup="${args.target}"]`) ?? document.createElement("div");
    elemArrow = elemPopup.querySelector(`.arrow`) ?? document.createElement("div");
  }
  setDomElements();
  function render() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!elemPopup)
      throw new Error(`The data-popup="${args.target}" element was not found. ${documentationLink}`);
    if (!computePosition)
      throw new Error(`Floating UI 'computePosition' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!offset)
      throw new Error(`Floating UI 'offset' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!shift)
      throw new Error(`Floating UI 'shift' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!flip2)
      throw new Error(`Floating UI 'flip' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!arrow)
      throw new Error(`Floating UI 'arrow' not found for data-popup="${args.target}". ${documentationLink}`);
    const optionalMiddleware = [];
    if (size)
      optionalMiddleware.push(size((_a = args.middleware) == null ? void 0 : _a.size));
    if (autoPlacement)
      optionalMiddleware.push(autoPlacement((_b = args.middleware) == null ? void 0 : _b.autoPlacement));
    if (hide)
      optionalMiddleware.push(hide((_c = args.middleware) == null ? void 0 : _c.hide));
    if (inline)
      optionalMiddleware.push(inline((_d = args.middleware) == null ? void 0 : _d.inline));
    computePosition(triggerNode, elemPopup, {
      placement: args.placement ?? "bottom",
      // Middleware - NOTE: the order matters:
      // https://floating-ui.com/docs/middleware#ordering
      middleware: [
        // https://floating-ui.com/docs/offset
        offset(((_e = args.middleware) == null ? void 0 : _e.offset) ?? 8),
        // https://floating-ui.com/docs/shift
        shift(((_f = args.middleware) == null ? void 0 : _f.shift) ?? { padding: 8 }),
        // https://floating-ui.com/docs/flip
        flip2((_g = args.middleware) == null ? void 0 : _g.flip),
        // https://floating-ui.com/docs/arrow
        arrow(((_h = args.middleware) == null ? void 0 : _h.arrow) ?? { element: elemArrow || null }),
        // Implement optional middleware
        ...optionalMiddleware
      ]
    }).then(({ x, y, placement, middlewareData }) => {
      Object.assign(elemPopup.style, {
        left: `${x}px`,
        top: `${y}px`
      });
      if (elemArrow) {
        const { x: arrowX, y: arrowY } = middlewareData.arrow;
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        Object.assign(elemArrow.style, {
          left: arrowX != null ? `${arrowX}px` : "",
          top: arrowY != null ? `${arrowY}px` : "",
          right: "",
          bottom: "",
          [staticSide]: "-4px"
        });
      }
    });
  }
  function open() {
    if (!elemPopup)
      return;
    popupState.open = true;
    if (args.state)
      args.state({ state: popupState.open });
    render();
    elemPopup.style.display = "block";
    elemPopup.style.opacity = "1";
    elemPopup.style.pointerEvents = "auto";
    elemPopup.removeAttribute("inert");
    popupState.autoUpdateCleanup = autoUpdate(triggerNode, elemPopup, render);
    focusablePopupElements = Array.from(elemPopup == null ? void 0 : elemPopup.querySelectorAll(focusableAllowedList));
  }
  function close(callback) {
    if (!elemPopup)
      return;
    const cssTransitionDuration = parseFloat(window.getComputedStyle(elemPopup).transitionDuration.replace("s", "")) * 1e3;
    setTimeout(() => {
      popupState.open = false;
      if (args.state)
        args.state({ state: popupState.open });
      elemPopup.style.opacity = "0";
      elemPopup.setAttribute("inert", "");
      if (popupState.autoUpdateCleanup)
        popupState.autoUpdateCleanup();
      if (callback)
        callback();
    }, cssTransitionDuration);
  }
  function toggle() {
    popupState.open === false ? open() : close();
  }
  function onWindowClick(event) {
    if (popupState.open === false)
      return;
    if (triggerNode.contains(event.target))
      return;
    if (elemPopup && elemPopup.contains(event.target) === false) {
      close();
      return;
    }
    const closeQueryString = args.closeQuery === void 0 ? "a[href], button" : args.closeQuery;
    const closableMenuElements = elemPopup == null ? void 0 : elemPopup.querySelectorAll(closeQueryString);
    closableMenuElements == null ? void 0 : closableMenuElements.forEach((elem) => {
      if (elem.contains(event.target))
        close();
    });
  }
  const onWindowKeyDown = (event) => {
    if (popupState.open === false)
      return;
    const key = event.key;
    if (key === "Escape") {
      event.preventDefault();
      triggerNode.focus();
      close();
      return;
    }
    focusablePopupElements = Array.from(elemPopup == null ? void 0 : elemPopup.querySelectorAll(focusableAllowedList));
    const triggerMenuFocused = popupState.open && document.activeElement === triggerNode;
    if (triggerMenuFocused && (key === "ArrowDown" || key === "Tab") && focusableAllowedList.length > 0 && focusablePopupElements.length > 0) {
      event.preventDefault();
      focusablePopupElements[0].focus();
    }
  };
  switch (args.event) {
    case "click":
      triggerNode.addEventListener("click", toggle, true);
      window.addEventListener("click", onWindowClick, true);
      break;
    case "hover":
      triggerNode.addEventListener("mouseover", open, true);
      triggerNode.addEventListener("mouseleave", () => close(), true);
      break;
    case "focus-blur":
      triggerNode.addEventListener("focus", toggle, true);
      triggerNode.addEventListener("blur", () => close(), true);
      break;
    case "focus-click":
      triggerNode.addEventListener("focus", open, true);
      window.addEventListener("click", onWindowClick, true);
      break;
    default:
      throw new Error(`Event value of '${args.event}' is not supported. ${documentationLink}`);
  }
  window.addEventListener("keydown", onWindowKeyDown, true);
  render();
  return {
    update(newArgs) {
      close(() => {
        args = newArgs;
        render();
        setDomElements();
      });
    },
    destroy() {
      triggerNode.removeEventListener("click", toggle, true);
      triggerNode.removeEventListener("mouseover", open, true);
      triggerNode.removeEventListener("mouseleave", () => close(), true);
      triggerNode.removeEventListener("focus", toggle, true);
      triggerNode.removeEventListener("focus", open, true);
      triggerNode.removeEventListener("blur", () => close(), true);
      window.removeEventListener("click", onWindowClick, true);
      window.removeEventListener("keydown", onWindowKeyDown, true);
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/Drawer/stores.js
function drawerService() {
  const { subscribe: subscribe2, set, update } = writable({});
  return {
    subscribe: subscribe2,
    set,
    update,
    /** Open the drawer. */
    open: (newSettings) => update(() => {
      return { open: true, ...newSettings };
    }),
    /** Close the drawer. */
    close: () => update((d) => {
      d.open = false;
      return d;
    })
  };
}
var drawerStore = drawerService();

// node_modules/@skeletonlabs/skeleton/dist/utilities/Modal/stores.js
function modalService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    set,
    update,
    /** Append to end of queue. */
    trigger: (modal) => update((mStore) => {
      mStore.push(modal);
      return mStore;
    }),
    /**  Remove first item in queue. */
    close: () => update((mStore) => {
      if (mStore.length > 0)
        mStore.shift();
      return mStore;
    }),
    /** Remove all items from queue. */
    clear: () => set([])
  };
}
var modalStore = modalService();

// node_modules/@skeletonlabs/skeleton/dist/utilities/Toast/stores.js
var toastDefaults = { message: "Missing Toast Message", autohide: true, timeout: 5e3 };
function randomUUID() {
  const random = Math.random();
  return Number(random).toString(32);
}
function handleAutoHide(toast) {
  if (toast.autohide === true) {
    return setTimeout(() => {
      toastStore.close(toast.id);
    }, toast.timeout);
  }
}
function toastService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    /** Add a new toast to the queue. */
    trigger: (toast) => {
      const id = randomUUID();
      update((tStore) => {
        if (toast && toast.callback)
          toast.callback({ id, status: "queued" });
        if (toast.hideDismiss)
          toast.autohide = true;
        const tMerged = { ...toastDefaults, ...toast, id };
        tMerged.timeoutId = handleAutoHide(tMerged);
        tStore.push(tMerged);
        return tStore;
      });
      return id;
    },
    /** Remove toast in queue*/
    close: (id) => update((tStore) => {
      if (tStore.length > 0) {
        const index = tStore.findIndex((t) => t.id === id);
        const selectedToast = tStore[index];
        if (selectedToast) {
          if (selectedToast.callback)
            selectedToast.callback({ id, status: "closed" });
          if (selectedToast.timeoutId)
            clearTimeout(selectedToast.timeoutId);
          tStore.splice(index, 1);
        }
      }
      return tStore;
    }),
    /** remain visible on hover */
    freeze: (index) => update((tStore) => {
      if (tStore.length > 0)
        clearTimeout(tStore[index].timeoutId);
      return tStore;
    }),
    /** cancel remain visible on leave */
    unfreeze: (index) => update((tStore) => {
      if (tStore.length > 0)
        tStore[index].timeoutId = handleAutoHide(tStore[index]);
      return tStore;
    }),
    /** Remove all toasts from queue */
    clear: () => set([])
  };
}
var toastStore = toastService();

// node_modules/@skeletonlabs/skeleton/dist/utilities/DataTable/actions.js
function tableInteraction(node) {
  const classAsc = "table-sort-asc";
  const classDsc = "table-sort-dsc";
  const onClick = (e) => {
    if (!(e.target instanceof Element))
      return;
    const sortTarget = e.target;
    const targetAscSorted = sortTarget.classList.contains(classAsc);
    const sortTargetKey = sortTarget.getAttribute("data-sort");
    const elemAsc = node.querySelector(`.${classAsc}`);
    if (elemAsc)
      elemAsc.classList.remove(classAsc);
    const elemDsc = node.querySelector(`.${classDsc}`);
    if (elemDsc)
      elemDsc.classList.remove(classDsc);
    if (sortTargetKey) {
      const classToApply = targetAscSorted ? classDsc : classAsc;
      e.target.classList.add(classToApply);
    }
  };
  node.addEventListener("click", onClick);
  return {
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
function tableA11y(node) {
  const keyWhitelist = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"];
  const onKeyDown2 = (event) => {
    if (keyWhitelist.includes(event.code)) {
      event.preventDefault();
      switch (event.code) {
        case "ArrowUp":
          a11ySetActiveCell(node, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(node, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(node, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(node, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(node, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(node, "last");
          break;
        default:
          break;
      }
    }
  };
  node.addEventListener("keydown", onKeyDown2);
  return {
    destroy() {
      node.removeEventListener("keydown", onKeyDown2);
    }
  };
}
function a11ySetActiveCell(node, x, y) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex || !focusedElem.ariaColIndex)
    return;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  const focusedElemColIndex = parseInt(focusedElem.ariaColIndex);
  const targetRowElement = node.querySelector(`[aria-rowindex="${focusedElemRowIndex + y}"]`);
  if (targetRowElement !== null) {
    const targetColElement = targetRowElement.querySelector(`[aria-colindex="${focusedElemColIndex + x}"]`);
    if (targetColElement !== null)
      targetColElement.focus();
  }
}
function a11yGetTargetElem(node) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex)
    return null;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  return node.querySelector(`[aria-rowindex="${focusedElemRowIndex}"]`);
}
function a11yJumpToOuterColumn(node, type = "first") {
  const targetRowElement = a11yGetTargetElem(node);
  if (targetRowElement === null)
    return;
  const lastIndex = targetRowElement.children.length;
  const selected = type === "first" ? 1 : lastIndex;
  const targetColElement = targetRowElement.querySelector(`[aria-colindex="${selected}"]`);
  if (targetColElement === null)
    return;
  targetColElement.focus();
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/DataTable/DataTable.js
function createDataTableStore(source, options = {}) {
  const modifiedList = source.map((rowObj) => ({ ...rowObj, dataTableChecked: false }));
  const { subscribe: subscribe2, set, update } = writable({
    source,
    base: modifiedList,
    filtered: modifiedList,
    sortState: { lastKey: "", asc: true },
    selection: [],
    search: options.search ?? "",
    sort: options.sort ?? "",
    pagination: options.pagination
  });
  return {
    subscribe: subscribe2,
    set,
    /** Sets a new data source while maintaining the state of the original source */
    updateSource: (data) => update((model) => {
      model.source = data;
      model.base = data.map((row, i) => {
        var _a;
        return { ...row, dataTableChecked: ((_a = model.base[i]) == null ? void 0 : _a.dataTableChecked) ?? false };
      });
      return { ...model, filtered: model.base };
    }),
    /** Triggered by the "select all" checkbox to toggle all row selection. */
    selectAll: (checked) => {
      update((model) => {
        model.base.forEach((row) => {
          row.dataTableChecked = checked;
          return row;
        });
        return model;
      });
    },
    /** Allows you to dynamically pre-select rows on-demand. */
    select: (key, valuesArr) => {
      update((model) => {
        model.filtered.map((row) => {
          if (valuesArr.includes(row[key]))
            row.dataTableChecked = true;
          return row;
        });
        return model;
      });
    },
    /** Listens for clicks to a table heading with `data-sort` attribute. Updates `$dataTableModel.sort`. */
    sort: (event) => {
      update((model) => {
        if (!(event.target instanceof Element))
          return model;
        const newSortKey = event.target.getAttribute("data-sort");
        if (newSortKey !== "" && newSortKey === model.sortState.lastKey)
          model.sortState.asc = !model.sortState.asc;
        model.sortState.lastKey = newSortKey;
        model.sort = newSortKey ?? "";
        return model;
      });
    }
  };
}
function dataTableHandler(model) {
  searchHandler(model);
  selectionHandler(model);
  sortHandler(model);
  paginationHandler(model);
}
function searchHandler(store) {
  store.filtered = store.base.filter((rowObj) => {
    var _a;
    const formattedSearchTerm = ((_a = store.search) == null ? void 0 : _a.toLowerCase()) || "";
    return Object.values(rowObj).join(" ").toLowerCase().includes(formattedSearchTerm);
  });
}
function selectionHandler(store) {
  store.selection = store.base.filter((row) => row.dataTableChecked === true);
}
function sortHandler(store) {
  if (!store.sort)
    return;
  store.sortState.asc ? sortOrder("asc", store) : sortOrder("dsc", store);
}
function sortOrder(order, store) {
  const key = store.sort;
  store.filtered = store.base.sort((x, y) => {
    if (order === "dsc")
      [x, y] = [y, x];
    if (typeof x[key] === "string" && typeof y[key] === "string") {
      return String(x[key]).localeCompare(String(y[key]));
    } else {
      const a = x[key];
      const b = y[key];
      return a < b ? -1 : a > b ? 1 : 0;
    }
  });
}
function paginationHandler(store) {
  if (store.pagination) {
    const filtered = store.base.slice(
      store.pagination.offset * store.pagination.limit,
      // start
      store.pagination.offset * store.pagination.limit + store.pagination.limit
      // end
    );
    if (store.search !== "") {
      store.filtered = store.filtered.slice(0, store.pagination.limit);
      store.pagination.size = store.filtered.length;
      store.pagination.offset = 0;
    } else {
      store.filtered = filtered;
      store.pagination.size = store.base.length;
    }
  }
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/LocalStorageStore/LocalStorageStore.js
var stores = {};
function getStorage(type) {
  return type === "local" ? localStorage : sessionStorage;
}
function localStorageStore(key, initialValue, options) {
  const serializer = (options == null ? void 0 : options.serializer) ?? JSON;
  const storageType = (options == null ? void 0 : options.storage) ?? "local";
  function updateStorage(key2, value) {
    if (!BROWSER)
      return;
    getStorage(storageType).setItem(key2, serializer.stringify(value));
  }
  if (!stores[key]) {
    const store = writable(initialValue, (set2) => {
      const json = BROWSER ? getStorage(storageType).getItem(key) : null;
      if (json) {
        set2(serializer.parse(json));
      }
      if (BROWSER) {
        const handleStorage = (event) => {
          if (event.key === key)
            set2(event.newValue ? serializer.parse(event.newValue) : null);
        };
        window.addEventListener("storage", handleStorage);
        return () => window.removeEventListener("storage", handleStorage);
      }
    });
    const { subscribe: subscribe2, set } = store;
    stores[key] = {
      set(value) {
        updateStorage(key, value);
        set(value);
      },
      update(updater) {
        const value = updater(get_store_value(store));
        updateStorage(key, value);
        set(value);
      },
      subscribe: subscribe2
    };
  }
  return stores[key];
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/LightSwitch/lightswitch.js
var modeOsPrefers = localStorageStore("modeOsPrefers", false);
var modeUserPrefers = localStorageStore("modeUserPrefers", void 0);
var modeCurrent = localStorageStore("modeCurrent", false);
function getModeOsPrefers() {
  const prefersLightMode = window.matchMedia("(prefers-color-scheme: light)").matches;
  modeOsPrefers.set(prefersLightMode);
  return prefersLightMode;
}
function getModeUserPrefers() {
  return get_store_value(modeUserPrefers);
}
function getModeAutoPrefers() {
  const os = getModeOsPrefers();
  const user = getModeUserPrefers();
  const modeValue = user !== void 0 ? user : os;
  return modeValue;
}
function setModeUserPrefers(value) {
  modeUserPrefers.set(value);
}
function setModeCurrent(value) {
  const elemHtmlClasses = document.documentElement.classList;
  const classDark = `dark`;
  value === true ? elemHtmlClasses.remove(classDark) : elemHtmlClasses.add(classDark);
  modeCurrent.set(value);
}
function setInitialClassState() {
  const elemHtmlClasses = document.documentElement.classList;
  const condLocalStorageUserPrefs = localStorage.getItem("modeUserPrefers") === "false";
  const condLocalStorageUserPrefsExists = !("modeUserPrefers" in localStorage);
  const condMatchMedia = window.matchMedia("(prefers-color-scheme: dark)").matches;
  if (condLocalStorageUserPrefs || condLocalStorageUserPrefsExists && condMatchMedia) {
    elemHtmlClasses.add("dark");
  } else {
    elemHtmlClasses.remove("dark");
  }
}
function autoModeWatcher() {
  const mql = window.matchMedia("(prefers-color-scheme: light)");
  function setMode(value) {
    const elemHtmlClasses = document.documentElement.classList;
    const classDark = `dark`;
    value === true ? elemHtmlClasses.remove(classDark) : elemHtmlClasses.add(classDark);
  }
  setMode(mql.matches);
  mql.onchange = () => {
    setMode(mql.matches);
  };
}

// node_modules/@skeletonlabs/skeleton/dist/components/Table/utils.js
function tableSourceMapper(source, keys) {
  return source.map((row) => {
    const mappedRow = {};
    keys.forEach((key) => mappedRow[key] = row[key]);
    return mappedRow;
  });
}
function tableSourceValues(source) {
  return source.map((row) => Object.values(row));
}
function tableMapperValues(source, keys) {
  return tableSourceValues(tableSourceMapper(source, keys));
}

// node_modules/@skeletonlabs/skeleton/dist/actions/Clipboard/clipboard.js
function clipboard(node, args) {
  const fireCopyCompleteEvent = () => {
    node.dispatchEvent(new CustomEvent("copyComplete"));
  };
  const onClick = () => {
    if (typeof args === "object") {
      if ("element" in args) {
        const element2 = document.querySelector(`[data-clipboard="${args.element}"]`);
        if (!element2)
          throw new Error(`Missing HTMLElement with an attribute of [data-clipboard="${args.element}"]`);
        copyToClipboard(element2.innerHTML, "text/html").then(fireCopyCompleteEvent);
        return;
      }
      if ("input" in args) {
        const input = document.querySelector(`[data-clipboard="${args.input}"]`);
        if (!input)
          throw new Error(`Missing HTMLInputElement with an attribute of [data-clipboard="${args.input}"]`);
        copyToClipboard(input.value).then(fireCopyCompleteEvent);
        return;
      }
    }
    copyToClipboard(args).then(fireCopyCompleteEvent);
  };
  node.addEventListener("click", onClick);
  return {
    update(newArgs) {
      args = newArgs;
    },
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
async function copyToClipboard(data, mimeType = "text/plain") {
  if (navigator.clipboard.write) {
    await navigator.clipboard.write([
      new ClipboardItem({
        [mimeType]: new Blob([data], {
          type: mimeType
        }),
        ["text/plain"]: new Blob([data], {
          type: "text/plain"
        })
      })
    ]);
  } else {
    await new Promise((resolve) => {
      resolve(navigator.clipboard.writeText(String(data)));
    });
  }
}

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/filter.js
function filter(node, filterName) {
  if (filterName === void 0)
    return;
  const applyFilter = () => {
    node.setAttribute("style", `filter: url("${filterName}")`);
  };
  applyFilter();
  return {
    update(newArgs) {
      filterName = newArgs;
      applyFilter();
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/actions/FocusTrap/focusTrap.js
function focusTrap(node, enabled) {
  const elemWhitelist = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
  let elemFirst;
  let elemLast;
  function onFirstElemKeydown(e) {
    if (e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemLast.focus();
    }
  }
  function onLastElemKeydown(e) {
    if (!e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemFirst.focus();
    }
  }
  const onScanElements = (fromObserver) => {
    if (enabled === false)
      return;
    const focusableElems = Array.from(node.querySelectorAll(elemWhitelist));
    if (focusableElems.length) {
      elemFirst = focusableElems[0];
      elemLast = focusableElems[focusableElems.length - 1];
      if (!fromObserver)
        elemFirst.focus();
      elemFirst.addEventListener("keydown", onFirstElemKeydown);
      elemLast.addEventListener("keydown", onLastElemKeydown);
    }
  };
  onScanElements(false);
  function onCleanUp() {
    if (elemFirst)
      elemFirst.removeEventListener("keydown", onFirstElemKeydown);
    if (elemLast)
      elemLast.removeEventListener("keydown", onLastElemKeydown);
  }
  const onObservationChange = (mutationRecords, observer2) => {
    if (mutationRecords.length) {
      onCleanUp();
      onScanElements(true);
    }
    return observer2;
  };
  const observer = new MutationObserver(onObservationChange);
  observer.observe(node, { childList: true, subtree: true });
  return {
    update(newArgs) {
      enabled = newArgs;
      newArgs ? onScanElements(false) : onCleanUp();
    },
    destroy() {
      onCleanUp();
      observer.disconnect();
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/components/Accordion/Accordion.svelte
var file = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Accordion\\Accordion.svelte";
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion " + /*classesBase*/
      ctx[0]);
      attr_dev(div, "data-testid", "accordion");
      add_location(div, file, 34, 0, 1125);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      1 && div_class_value !== (div_class_value = "accordion " + /*classesBase*/
      ctx2[0])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { autocollapse = false } = $$props;
  let { duration = 200 } = $$props;
  let { width = "w-full" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { disabled = false } = $$props;
  let { padding = "py-2 px-4" } = $$props;
  let { hover = "hover:bg-primary-hover-token" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { caretOpen = "rotate-180" } = $$props;
  let { caretClosed = "" } = $$props;
  let { regionControl = "" } = $$props;
  let { regionPanel = "space-y-4" } = $$props;
  let { regionCaret = "" } = $$props;
  const active = writable(null);
  setContext("active", active);
  setContext("autocollapse", autocollapse);
  setContext("duration", duration);
  setContext("disabled", disabled);
  setContext("padding", padding);
  setContext("hover", hover);
  setContext("rounded", rounded);
  setContext("caretOpen", caretOpen);
  setContext("caretClosed", caretClosed);
  setContext("regionControl", regionControl);
  setContext("regionPanel", regionPanel);
  setContext("regionCaret", regionCaret);
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("autocollapse" in $$new_props)
      $$invalidate(1, autocollapse = $$new_props.autocollapse);
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(4, spacing = $$new_props.spacing);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("padding" in $$new_props)
      $$invalidate(6, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(7, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(9, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(10, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$new_props)
      $$invalidate(11, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$new_props)
      $$invalidate(12, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$new_props)
      $$invalidate(13, regionCaret = $$new_props.regionCaret);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    setContext,
    autocollapse,
    duration,
    width,
    spacing,
    disabled,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    active,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    if ("autocollapse" in $$props)
      $$invalidate(1, autocollapse = $$new_props.autocollapse);
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("width" in $$props)
      $$invalidate(3, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(4, spacing = $$new_props.spacing);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("padding" in $$props)
      $$invalidate(6, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(7, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(9, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(10, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$props)
      $$invalidate(11, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$props)
      $$invalidate(12, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$props)
      $$invalidate(13, regionCaret = $$new_props.regionCaret);
    if ("classesBase" in $$props)
      $$invalidate(0, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    classesBase,
    autocollapse,
    duration,
    width,
    spacing,
    disabled,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    $$scope,
    slots
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      autocollapse: 1,
      duration: 2,
      width: 3,
      spacing: 4,
      disabled: 5,
      padding: 6,
      hover: 7,
      rounded: 8,
      caretOpen: 9,
      caretClosed: 10,
      regionControl: 11,
      regionPanel: 12,
      regionCaret: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment.name
    });
  }
  get autocollapse() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocollapse(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionControl() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionControl(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPanel() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPanel(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCaret() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCaret(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/@skeletonlabs/skeleton/dist/components/Accordion/AccordionItem.svelte
var file2 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Accordion\\AccordionItem.svelte";
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_summary_slot_changes = (dirty) => ({});
var get_summary_slot_context = (ctx) => ({});
var get_lead_slot_changes = (dirty) => ({});
var get_lead_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[24].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_lead_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "accordion-lead");
      add_location(div, file2, 72, 3, 2273);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_lead_slot_changes
            ),
            get_lead_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(72:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(summary)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(summary)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(79:24) (summary)",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let div_class_value;
  let div_id_value;
  let div_aria_hidden_value;
  let div_aria_labelledby_value;
  let div_transition;
  let current;
  const content_slot_template = (
    /*#slots*/
    ctx[24].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_content_slot_context
  );
  const content_slot_or_fallback = content_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (content_slot_or_fallback)
        content_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        id: true,
        role: true,
        "aria-hidden": true,
        "aria-labelledby": true
      });
      var div_nodes = children(div);
      if (content_slot_or_fallback)
        content_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion-panel " + /*classesPanel*/
      ctx[5]);
      attr_dev(div, "id", div_id_value = "accordion-panel-" + /*id*/
      ctx[0]);
      attr_dev(div, "role", "region");
      attr_dev(div, "aria-hidden", div_aria_hidden_value = !/*openState*/
      ctx[4]);
      attr_dev(div, "aria-labelledby", div_aria_labelledby_value = "accordion-control-" + /*id*/
      ctx[0]);
      add_location(div, file2, 92, 2, 2882);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (content_slot_or_fallback) {
        content_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (content_slot) {
        if (content_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx,
            /*$$scope*/
            ctx[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[23]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx[23],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*classesPanel*/
      32 && div_class_value !== (div_class_value = "accordion-panel " + /*classesPanel*/
      ctx[5])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1 && div_id_value !== (div_id_value = "accordion-panel-" + /*id*/
      ctx[0])) {
        attr_dev(div, "id", div_id_value);
      }
      if (!current || dirty[0] & /*openState*/
      16 && div_aria_hidden_value !== (div_aria_hidden_value = !/*openState*/
      ctx[4])) {
        attr_dev(div, "aria-hidden", div_aria_hidden_value);
      }
      if (!current || dirty[0] & /*id*/
      1 && div_aria_labelledby_value !== (div_aria_labelledby_value = "accordion-control-" + /*id*/
      ctx[0])) {
        attr_dev(div, "aria-labelledby", div_aria_labelledby_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_slot_or_fallback, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration: (
              /*duration*/
              ctx[2]
            ) }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(content_slot_or_fallback, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: (
            /*duration*/
            ctx[2]
          ) }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (content_slot_or_fallback)
        content_slot_or_fallback.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(92:1) {#if openState}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(content)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(content)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(101:24) (content)",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div2;
  let button;
  let t0;
  let div0;
  let t1;
  let div1;
  let svg;
  let path;
  let div1_class_value;
  let button_class_value;
  let button_id_value;
  let button_aria_controls_value;
  let t2;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[10].lead && create_if_block_1(ctx)
  );
  const summary_slot_template = (
    /*#slots*/
    ctx[24].summary
  );
  const summary_slot = create_slot(
    summary_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_summary_slot_context
  );
  const summary_slot_or_fallback = summary_slot || fallback_block_1(ctx);
  let if_block1 = (
    /*openState*/
    ctx[4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      button = element("button");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div2_nodes = children(div2);
      button = claim_element(div2_nodes, "BUTTON", {
        type: true,
        class: true,
        id: true,
        "aria-expanded": true,
        "aria-controls": true
      });
      var button_nodes = children(button);
      if (if_block0)
        if_block0.l(button_nodes);
      t0 = claim_space(button_nodes);
      div0 = claim_element(button_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      div1 = claim_element(button_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      svg = claim_svg_element(div1_nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block1)
        if_block1.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "accordion-summary flex-1");
      add_location(div0, file2, 77, 2, 2366);
      attr_dev(path, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z");
      add_location(path, file2, 84, 4, 2626);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      add_location(svg, file2, 83, 3, 2559);
      attr_dev(div1, "class", div1_class_value = "accordion-summary-caret " + /*classesControlCaret*/
      ctx[6]);
      add_location(div1, file2, 81, 2, 2474);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "accordion-control " + /*classesControl*/
      ctx[7]);
      attr_dev(button, "id", button_id_value = "accordion-control-" + /*id*/
      ctx[0]);
      attr_dev(
        button,
        "aria-expanded",
        /*openState*/
        ctx[4]
      );
      attr_dev(button, "aria-controls", button_aria_controls_value = "accordion-panel-" + /*id*/
      ctx[0]);
      button.disabled = /*disabled*/
      ctx[3];
      add_location(button, file2, 57, 1, 1979);
      attr_dev(div2, "class", div2_class_value = "accordion-item " + /*classesBase*/
      ctx[8]);
      attr_dev(div2, "data-testid", "accordion-item");
      add_location(div2, file2, 55, 0, 1888);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, button);
      if (if_block0)
        if_block0.m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, div0);
      if (summary_slot_or_fallback) {
        summary_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(button, t1);
      append_hydration_dev(button, div1);
      append_hydration_dev(div1, svg);
      append_hydration_dev(svg, path);
      append_hydration_dev(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*setActive*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keyup",
            /*keyup_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[10].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty[0] & /*$$scope*/
        8388608)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              summary_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_summary_slot_changes
            ),
            get_summary_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*classesControlCaret*/
      64 && div1_class_value !== (div1_class_value = "accordion-summary-caret " + /*classesControlCaret*/
      ctx2[6])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesControl*/
      128 && button_class_value !== (button_class_value = "accordion-control " + /*classesControl*/
      ctx2[7])) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1 && button_id_value !== (button_id_value = "accordion-control-" + /*id*/
      ctx2[0])) {
        attr_dev(button, "id", button_id_value);
      }
      if (!current || dirty[0] & /*openState*/
      16) {
        attr_dev(
          button,
          "aria-expanded",
          /*openState*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*id*/
      1 && button_aria_controls_value !== (button_aria_controls_value = "accordion-panel-" + /*id*/
      ctx2[0])) {
        attr_dev(button, "aria-controls", button_aria_controls_value);
      }
      if (!current || dirty[0] & /*disabled*/
      8) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (
        /*openState*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*openState*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesBase*/
      256 && div2_class_value !== (div2_class_value = "accordion-item " + /*classesBase*/
      ctx2[8])) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(summary_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(summary_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase = "";
var cControl = "text-left w-full flex items-center space-x-4";
var cControlCaret = "fill-current w-3 transition-transform duration-[200ms]";
var cPanel = "";
function instance2($$self, $$props, $$invalidate) {
  let openState;
  let classesBase;
  let classesControl;
  let classesCaretState;
  let classesControlCaret;
  let classesPanel;
  let $active, $$unsubscribe_active = noop, $$subscribe_active = () => ($$unsubscribe_active(), $$unsubscribe_active = subscribe(active, ($$value) => $$invalidate(22, $active = $$value)), active);
  $$self.$$.on_destroy.push(() => $$unsubscribe_active());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["lead", "summary", "content"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { open = false } = $$props;
  let { id = String(Math.random()) } = $$props;
  let { autocollapse = getContext("autocollapse") } = $$props;
  let { active = getContext("active") } = $$props;
  validate_store(active, "active");
  $$subscribe_active();
  let { duration = getContext("duration") } = $$props;
  let { disabled = getContext("disabled") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { caretOpen = getContext("caretOpen") } = $$props;
  let { caretClosed = getContext("caretClosed") } = $$props;
  let { regionControl = getContext("regionControl") } = $$props;
  let { regionPanel = getContext("regionPanel") } = $$props;
  let { regionCaret = getContext("regionCaret") } = $$props;
  function setActive(event) {
    if (autocollapse === true) {
      active.set(id);
    } else {
      $$invalidate(11, open = !open);
    }
    onToggle(event);
  }
  function onToggle(event) {
    const currentOpenState = autocollapse ? $active === id : open;
    dispatch("toggle", {
      event,
      id: `accordion-control-${id}`,
      open: currentOpenState,
      autocollapse
    });
  }
  if (autocollapse && open)
    setActive();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(11, open = $$new_props.open);
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("autocollapse" in $$new_props)
      $$invalidate(12, autocollapse = $$new_props.autocollapse);
    if ("active" in $$new_props)
      $$subscribe_active($$invalidate(1, active = $$new_props.active));
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("padding" in $$new_props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(16, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(17, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$new_props)
      $$invalidate(18, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$new_props)
      $$invalidate(19, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$new_props)
      $$invalidate(20, regionCaret = $$new_props.regionCaret);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    createEventDispatcher,
    slide,
    dispatch,
    open,
    id,
    cBase,
    cControl,
    cControlCaret,
    cPanel,
    autocollapse,
    active,
    duration,
    disabled,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    setActive,
    onToggle,
    classesPanel,
    classesCaretState,
    classesControlCaret,
    openState,
    classesControl,
    classesBase,
    $active
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    if ("open" in $$props)
      $$invalidate(11, open = $$new_props.open);
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("autocollapse" in $$props)
      $$invalidate(12, autocollapse = $$new_props.autocollapse);
    if ("active" in $$props)
      $$subscribe_active($$invalidate(1, active = $$new_props.active));
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("padding" in $$props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(16, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(17, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$props)
      $$invalidate(18, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$props)
      $$invalidate(19, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$props)
      $$invalidate(20, regionCaret = $$new_props.regionCaret);
    if ("classesPanel" in $$props)
      $$invalidate(5, classesPanel = $$new_props.classesPanel);
    if ("classesCaretState" in $$props)
      $$invalidate(21, classesCaretState = $$new_props.classesCaretState);
    if ("classesControlCaret" in $$props)
      $$invalidate(6, classesControlCaret = $$new_props.classesControlCaret);
    if ("openState" in $$props)
      $$invalidate(4, openState = $$new_props.openState);
    if ("classesControl" in $$props)
      $$invalidate(7, classesControl = $$new_props.classesControl);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*open, autocollapse*/
    6144) {
      $:
        if (open && autocollapse)
          setActive();
    }
    if ($$self.$$.dirty[0] & /*autocollapse, $active, id, open*/
    4200449) {
      $:
        $$invalidate(4, openState = autocollapse ? $active === id : open);
    }
    $:
      $$invalidate(8, classesBase = `${cBase} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*padding, hover, rounded, regionControl*/
    319488) {
      $:
        $$invalidate(7, classesControl = `${cControl} ${padding} ${hover} ${rounded} ${regionControl}`);
    }
    if ($$self.$$.dirty[0] & /*openState, caretOpen, caretClosed*/
    196624) {
      $:
        $$invalidate(21, classesCaretState = openState ? caretOpen : caretClosed);
    }
    if ($$self.$$.dirty[0] & /*regionCaret, classesCaretState*/
    3145728) {
      $:
        $$invalidate(6, classesControlCaret = `${cControlCaret} ${regionCaret} ${classesCaretState}`);
    }
    if ($$self.$$.dirty[0] & /*padding, rounded, regionPanel*/
    565248) {
      $:
        $$invalidate(5, classesPanel = `${cPanel} ${padding} ${rounded} ${regionPanel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    active,
    duration,
    disabled,
    openState,
    classesPanel,
    classesControlCaret,
    classesControl,
    classesBase,
    setActive,
    $$slots,
    open,
    autocollapse,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    classesCaretState,
    $active,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        open: 11,
        id: 0,
        autocollapse: 12,
        active: 1,
        duration: 2,
        disabled: 3,
        padding: 13,
        hover: 14,
        rounded: 15,
        caretOpen: 16,
        caretClosed: 17,
        regionControl: 18,
        regionPanel: 19,
        regionCaret: 20
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment2.name
    });
  }
  get open() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocollapse() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocollapse(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionControl() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionControl(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPanel() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPanel(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCaret() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCaret(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/@skeletonlabs/skeleton/dist/components/AppBar/AppBar.svelte
var file3 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\AppBar\\AppBar.svelte";
var get_headline_slot_changes = (dirty) => ({});
var get_headline_slot_context = (ctx) => ({});
var get_trail_slot_changes = (dirty) => ({});
var get_trail_slot_context = (ctx) => ({});
var get_lead_slot_changes2 = (dirty) => ({});
var get_lead_slot_context2 = (ctx) => ({});
function create_if_block_2(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[22].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_lead_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-slot-lead " + /*classesSlotLead*/
      ctx[4]);
      add_location(div, file3, 39, 3, 1366);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_lead_slot_changes2
            ),
            get_lead_slot_context2
          );
        }
      }
      if (!current || dirty & /*classesSlotLead*/
      16 && div_class_value !== (div_class_value = "app-bar-slot-lead " + /*classesSlotLead*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(39:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let div_class_value;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[22].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_trail_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-slot-trail " + /*classesSlotTrail*/
      ctx[2]);
      add_location(div, file3, 45, 3, 1595);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_trail_slot_changes
            ),
            get_trail_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSlotTrail*/
      4 && div_class_value !== (div_class_value = "app-bar-slot-trail " + /*classesSlotTrail*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(45:2) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let div_class_value;
  let current;
  const headline_slot_template = (
    /*#slots*/
    ctx[22].headline
  );
  const headline_slot = create_slot(
    headline_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_headline_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (headline_slot)
        headline_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (headline_slot)
        headline_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-row-headline " + /*classesRowHeadline*/
      ctx[5]);
      add_location(div, file3, 50, 2, 1740);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (headline_slot) {
        headline_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (headline_slot) {
        if (headline_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            headline_slot,
            headline_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              headline_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_headline_slot_changes
            ),
            get_headline_slot_context
          );
        }
      }
      if (!current || dirty & /*classesRowHeadline*/
      32 && div_class_value !== (div_class_value = "app-bar-row-headline " + /*classesRowHeadline*/
      ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(headline_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(headline_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (headline_slot)
        headline_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(50:1) {#if $$slots.headline}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let t2;
  let div2_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[8].lead && create_if_block_2(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx[8].trail && create_if_block_12(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[8].headline && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-labelledby": true
      });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-slot-default " + /*classesSlotDefault*/
      ctx[3]);
      add_location(div0, file3, 42, 2, 1477);
      attr_dev(div1, "class", div1_class_value = "app-bar-row-main " + /*classesRowMain*/
      ctx[6]);
      add_location(div1, file3, 36, 1, 1272);
      attr_dev(div2, "class", div2_class_value = "app-bar " + /*classesBase*/
      ctx[7]);
      attr_dev(div2, "data-testid", "app-bar");
      attr_dev(div2, "role", "toolbar");
      attr_dev(
        div2,
        "aria-label",
        /*label*/
        ctx[0]
      );
      attr_dev(
        div2,
        "aria-labelledby",
        /*labelledby*/
        ctx[1]
      );
      add_location(div2, file3, 34, 0, 1130);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[8].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesSlotDefault*/
      8 && div0_class_value !== (div0_class_value = "app-bar-slot-default " + /*classesSlotDefault*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[8].trail
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesRowMain*/
      64 && div1_class_value !== (div1_class_value = "app-bar-row-main " + /*classesRowMain*/
      ctx2[6])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*$$slots*/
        ctx2[8].headline
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      128 && div2_class_value !== (div2_class_value = "app-bar " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*label*/
      1) {
        attr_dev(
          div2,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*labelledby*/
      2) {
        attr_dev(
          div2,
          "aria-labelledby",
          /*labelledby*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase2 = "flex flex-col";
var cRowMain = "grid items-center";
var cRowHeadline = "";
var cSlotLead = "flex-none flex justify-between items-center";
var cSlotDefault = "flex-auto";
var cSlotTrail = "flex-none flex items-center space-x-4";
function instance3($$self, $$props, $$invalidate) {
  let classesBase;
  let classesRowMain;
  let classesRowHeadline;
  let classesSlotLead;
  let classesSlotDefault;
  let classesSlotTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppBar", slots, ["lead", "default", "trail", "headline"]);
  const $$slots = compute_slots(slots);
  let { background = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { padding = "p-4" } = $$props;
  let { shadow = "" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { gridColumns = "grid-cols-[auto_1fr_auto]" } = $$props;
  let { gap = "gap-4" } = $$props;
  let { regionRowMain = "" } = $$props;
  let { regionRowHeadline = "" } = $$props;
  let { slotLead = "" } = $$props;
  let { slotDefault = "" } = $$props;
  let { slotTrail = "" } = $$props;
  let { label = "" } = $$props;
  let { labelledby = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(9, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(10, border = $$new_props.border);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("shadow" in $$new_props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("spacing" in $$new_props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("gridColumns" in $$new_props)
      $$invalidate(14, gridColumns = $$new_props.gridColumns);
    if ("gap" in $$new_props)
      $$invalidate(15, gap = $$new_props.gap);
    if ("regionRowMain" in $$new_props)
      $$invalidate(16, regionRowMain = $$new_props.regionRowMain);
    if ("regionRowHeadline" in $$new_props)
      $$invalidate(17, regionRowHeadline = $$new_props.regionRowHeadline);
    if ("slotLead" in $$new_props)
      $$invalidate(18, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$new_props)
      $$invalidate(19, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$new_props)
      $$invalidate(20, slotTrail = $$new_props.slotTrail);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    background,
    border,
    padding,
    shadow,
    spacing,
    gridColumns,
    gap,
    regionRowMain,
    regionRowHeadline,
    slotLead,
    slotDefault,
    slotTrail,
    label,
    labelledby,
    cBase: cBase2,
    cRowMain,
    cRowHeadline,
    cSlotLead,
    cSlotDefault,
    cSlotTrail,
    classesSlotTrail,
    classesSlotDefault,
    classesSlotLead,
    classesRowHeadline,
    classesRowMain,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(9, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(10, border = $$new_props.border);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("shadow" in $$props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("spacing" in $$props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("gridColumns" in $$props)
      $$invalidate(14, gridColumns = $$new_props.gridColumns);
    if ("gap" in $$props)
      $$invalidate(15, gap = $$new_props.gap);
    if ("regionRowMain" in $$props)
      $$invalidate(16, regionRowMain = $$new_props.regionRowMain);
    if ("regionRowHeadline" in $$props)
      $$invalidate(17, regionRowHeadline = $$new_props.regionRowHeadline);
    if ("slotLead" in $$props)
      $$invalidate(18, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$props)
      $$invalidate(19, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$props)
      $$invalidate(20, slotTrail = $$new_props.slotTrail);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("classesSlotTrail" in $$props)
      $$invalidate(2, classesSlotTrail = $$new_props.classesSlotTrail);
    if ("classesSlotDefault" in $$props)
      $$invalidate(3, classesSlotDefault = $$new_props.classesSlotDefault);
    if ("classesSlotLead" in $$props)
      $$invalidate(4, classesSlotLead = $$new_props.classesSlotLead);
    if ("classesRowHeadline" in $$props)
      $$invalidate(5, classesRowHeadline = $$new_props.classesRowHeadline);
    if ("classesRowMain" in $$props)
      $$invalidate(6, classesRowMain = $$new_props.classesRowMain);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${cBase2} ${background} ${border} ${spacing} ${padding} ${shadow} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*gridColumns, gap, regionRowMain*/
    114688) {
      $:
        $$invalidate(6, classesRowMain = `${cRowMain} ${gridColumns} ${gap} ${regionRowMain}`);
    }
    if ($$self.$$.dirty & /*regionRowHeadline*/
    131072) {
      $:
        $$invalidate(5, classesRowHeadline = `${cRowHeadline} ${regionRowHeadline}`);
    }
    if ($$self.$$.dirty & /*slotLead*/
    262144) {
      $:
        $$invalidate(4, classesSlotLead = `${cSlotLead} ${slotLead}`);
    }
    if ($$self.$$.dirty & /*slotDefault*/
    524288) {
      $:
        $$invalidate(3, classesSlotDefault = `${cSlotDefault} ${slotDefault}`);
    }
    if ($$self.$$.dirty & /*slotTrail*/
    1048576) {
      $:
        $$invalidate(2, classesSlotTrail = `${cSlotTrail} ${slotTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    labelledby,
    classesSlotTrail,
    classesSlotDefault,
    classesSlotLead,
    classesRowHeadline,
    classesRowMain,
    classesBase,
    $$slots,
    background,
    border,
    padding,
    shadow,
    spacing,
    gridColumns,
    gap,
    regionRowMain,
    regionRowHeadline,
    slotLead,
    slotDefault,
    slotTrail,
    $$scope,
    slots
  ];
}
var AppBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      background: 9,
      border: 10,
      padding: 11,
      shadow: 12,
      spacing: 13,
      gridColumns: 14,
      gap: 15,
      regionRowMain: 16,
      regionRowHeadline: 17,
      slotLead: 18,
      slotDefault: 19,
      slotTrail: 20,
      label: 0,
      labelledby: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppBar",
      options,
      id: create_fragment3.name
    });
  }
  get background() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gridColumns() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gridColumns(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionRowMain() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionRowMain(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionRowHeadline() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionRowHeadline(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotDefault() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotDefault(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotTrail() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotTrail(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppBar_default = AppBar;

// node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRail.svelte
var file4 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\AppRail\\AppRail.svelte";
var get_trail_slot_changes2 = (dirty) => ({});
var get_trail_slot_context2 = (ctx) => ({});
var get_lead_slot_changes3 = (dirty) => ({});
var get_lead_slot_context3 = (ctx) => ({});
function create_fragment4(ctx) {
  let div3;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let div3_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[17].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_lead_slot_context3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const trail_slot_template = (
    /*#slots*/
    ctx[17].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_trail_slot_context2
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      if (lead_slot)
        lead_slot.c();
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div2 = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (lead_slot)
        lead_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (trail_slot)
        trail_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-lead " + /*classesRegionLead*/
      ctx[2]);
      add_location(div0, file4, 35, 1, 1199);
      attr_dev(div1, "class", div1_class_value = "app-bar-default " + /*classesRegionDefault*/
      ctx[1]);
      add_location(div1, file4, 37, 1, 1297);
      attr_dev(div2, "class", div2_class_value = "app-bar-trail " + /*classesRegionTrail*/
      ctx[0]);
      add_location(div2, file4, 39, 1, 1386);
      attr_dev(div3, "class", div3_class_value = "app-rail " + /*classesBase*/
      ctx[3]);
      attr_dev(div3, "data-testid", "app-rail");
      add_location(div3, file4, 33, 0, 1117);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      if (lead_slot) {
        lead_slot.m(div0, null);
      }
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      if (trail_slot) {
        trail_slot.m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_lead_slot_changes3
            ),
            get_lead_slot_context3
          );
        }
      }
      if (!current || dirty & /*classesRegionLead*/
      4 && div0_class_value !== (div0_class_value = "app-bar-lead " + /*classesRegionLead*/
      ctx2[2])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesRegionDefault*/
      2 && div1_class_value !== (div1_class_value = "app-bar-default " + /*classesRegionDefault*/
      ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_trail_slot_changes2
            ),
            get_trail_slot_context2
          );
        }
      }
      if (!current || dirty & /*classesRegionTrail*/
      1 && div2_class_value !== (div2_class_value = "app-bar-trail " + /*classesRegionTrail*/
      ctx2[0])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*classesBase*/
      8 && div3_class_value !== (div3_class_value = "app-rail " + /*classesBase*/
      ctx2[3])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      transition_in(default_slot, local);
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      transition_out(default_slot, local);
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (lead_slot)
        lead_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase3 = "grid grid-rows-[auto_1fr_auto] overflow-y-auto";
var cRegionLead = "box-border";
var cRegionDefault = "box-border";
var cRegionTrail = "box-border";
function instance4($$self, $$props, $$invalidate) {
  let classesBase;
  let classesRegionLead;
  let classesRegionDefault;
  let classesRegionTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRail", slots, ["lead", "default", "trail"]);
  let { background = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { width = "w-20" } = $$props;
  let { height = "h-full" } = $$props;
  let { gap = "gap-0" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionDefault = "" } = $$props;
  let { regionTrail = "" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { active = "bg-primary-active-token" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { aspectRatio = "aspect-square" } = $$props;
  setContext("active", active);
  setContext("hover", hover);
  setContext("spacing", spacing);
  setContext("aspectRatio", aspectRatio);
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(4, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(5, border = $$new_props.border);
    if ("width" in $$new_props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(7, height = $$new_props.height);
    if ("gap" in $$new_props)
      $$invalidate(8, gap = $$new_props.gap);
    if ("regionLead" in $$new_props)
      $$invalidate(9, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$new_props)
      $$invalidate(10, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$new_props)
      $$invalidate(11, regionTrail = $$new_props.regionTrail);
    if ("hover" in $$new_props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(13, active = $$new_props.active);
    if ("spacing" in $$new_props)
      $$invalidate(14, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$new_props)
      $$invalidate(15, aspectRatio = $$new_props.aspectRatio);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    background,
    border,
    width,
    height,
    gap,
    regionLead,
    regionDefault,
    regionTrail,
    hover,
    active,
    spacing,
    aspectRatio,
    cBase: cBase3,
    cRegionLead,
    cRegionDefault,
    cRegionTrail,
    classesRegionTrail,
    classesRegionDefault,
    classesRegionLead,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(4, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(5, border = $$new_props.border);
    if ("width" in $$props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(7, height = $$new_props.height);
    if ("gap" in $$props)
      $$invalidate(8, gap = $$new_props.gap);
    if ("regionLead" in $$props)
      $$invalidate(9, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$props)
      $$invalidate(10, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$props)
      $$invalidate(11, regionTrail = $$new_props.regionTrail);
    if ("hover" in $$props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(13, active = $$new_props.active);
    if ("spacing" in $$props)
      $$invalidate(14, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$props)
      $$invalidate(15, aspectRatio = $$new_props.aspectRatio);
    if ("classesRegionTrail" in $$props)
      $$invalidate(0, classesRegionTrail = $$new_props.classesRegionTrail);
    if ("classesRegionDefault" in $$props)
      $$invalidate(1, classesRegionDefault = $$new_props.classesRegionDefault);
    if ("classesRegionLead" in $$props)
      $$invalidate(2, classesRegionLead = $$new_props.classesRegionLead);
    if ("classesBase" in $$props)
      $$invalidate(3, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classesBase = `${cBase3} ${background} ${border} ${width} ${height} ${gap} ${$$props.class || ""}`);
    if ($$self.$$.dirty & /*regionLead*/
    512) {
      $:
        $$invalidate(2, classesRegionLead = `${cRegionLead} ${regionLead}`);
    }
    if ($$self.$$.dirty & /*regionDefault*/
    1024) {
      $:
        $$invalidate(1, classesRegionDefault = `${cRegionDefault} ${regionDefault}`);
    }
    if ($$self.$$.dirty & /*regionTrail*/
    2048) {
      $:
        $$invalidate(0, classesRegionTrail = `${cRegionTrail} ${regionTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    classesRegionTrail,
    classesRegionDefault,
    classesRegionLead,
    classesBase,
    background,
    border,
    width,
    height,
    gap,
    regionLead,
    regionDefault,
    regionTrail,
    hover,
    active,
    spacing,
    aspectRatio,
    $$scope,
    slots
  ];
}
var AppRail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      background: 4,
      border: 5,
      width: 6,
      height: 7,
      gap: 8,
      regionLead: 9,
      regionDefault: 10,
      regionTrail: 11,
      hover: 12,
      active: 13,
      spacing: 14,
      aspectRatio: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRail",
      options,
      id: create_fragment4.name
    });
  }
  get background() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDefault() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDefault(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTrail() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTrail(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRail_default = AppRail;

// node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRailTile.svelte
var file5 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\AppRail\\AppRailTile.svelte";
var get_lead_slot_changes4 = (dirty) => ({});
var get_lead_slot_context4 = (ctx) => ({});
function create_if_block3(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[21].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_lead_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-lead " + /*classesLead*/
      ctx[6]);
      add_location(div, file5, 46, 21, 1693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_lead_slot_changes4
            ),
            get_lead_slot_context4
          );
        }
      }
      if (!current || dirty[0] & /*classesLead*/
      64 && div_class_value !== (div_class_value = "app-rail-lead " + /*classesLead*/
      ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(47:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let label;
  let div3;
  let div0;
  let input;
  let t0;
  let div2;
  let t1;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let div3_class_value;
  let label_class_value;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    { __value: (
      /*value*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[10](),
    { tabindex: "-1" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[11].lead && create_if_block3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[33][0]
  );
  const block = {
    c: function create() {
      label = element("label");
      div3 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {
        class: true,
        "data-testid": true,
        title: true
      });
      var label_nodes = children(label);
      div3 = claim_element(label_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true, tabindex: true });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file5, 42, 3, 1461);
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file5, 41, 2, 1420);
      attr_dev(div1, "class", div1_class_value = "app-rail-label " + /*classesLabel*/
      ctx[5]);
      add_location(div1, file5, 47, 3, 1769);
      attr_dev(div2, "class", div2_class_value = "app-rail-interface " + /*classesInterface*/
      ctx[7]);
      add_location(div2, file5, 45, 2, 1620);
      attr_dev(div3, "class", div3_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx[8]);
      add_location(div3, file5, 39, 1, 1261);
      attr_dev(label, "class", label_class_value = "app-rail-tile " + /*classesBase*/
      ctx[9]);
      attr_dev(label, "data-testid", "app-rail-tile");
      attr_dev(
        label,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(label, file5, 35, 0, 993);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[31](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[32]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keyup",
            /*keyup_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keypress",
            /*keypress_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseover",
            /*mouseover_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "focus",
            /*focus_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "blur",
            /*blur_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty[0] & /*value*/
        4) && { __value: (
          /*value*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[10](),
        { tabindex: "-1" }
      ]));
      if (dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (
        /*$$slots*/
        ctx2[11].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesLabel*/
      32 && div1_class_value !== (div1_class_value = "app-rail-label " + /*classesLabel*/
      ctx2[5])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesInterface*/
      128 && div2_class_value !== (div2_class_value = "app-rail-interface " + /*classesInterface*/
      ctx2[7])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesWrapper*/
      256 && div3_class_value !== (div3_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx2[8])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      512 && label_class_value !== (label_class_value = "app-rail-tile " + /*classesBase*/
      ctx2[9])) {
        attr_dev(label, "class", label_class_value);
      }
      if (!current || dirty[0] & /*title*/
      8) {
        attr_dev(
          label,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[31](null);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase4 = "cursor-pointer";
var cWrapper = "flex flex-col justify-center items-stretch";
var cInterface = "text-center";
var cLabel = "font-bold text-xs";
function instance5($$self, $$props, $$invalidate) {
  let classActive;
  let classesBase;
  let classesWrapper;
  let classesInterface;
  let classesLead;
  let classesLabel;
  const omit_props_names = [
    "group",
    "name",
    "value",
    "title",
    "regionLead",
    "regionLabel",
    "hover",
    "active",
    "spacing",
    "width",
    "aspectRatio"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRailTile", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { title = "" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionLabel = "" } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { active = getContext("active") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let { width = getContext("width") } = $$props;
  let { aspectRatio = getContext("aspectRatio") } = $$props;
  let elemInput;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<AppRailTile> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<AppRailTile> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<AppRailTile> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(4, elemInput);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(35, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(34, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("regionLead" in $$new_props)
      $$invalidate(12, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$new_props)
      $$invalidate(13, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$new_props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(15, active = $$new_props.active);
    if ("spacing" in $$new_props)
      $$invalidate(16, spacing = $$new_props.spacing);
    if ("width" in $$new_props)
      $$invalidate(17, width = $$new_props.width);
    if ("aspectRatio" in $$new_props)
      $$invalidate(18, aspectRatio = $$new_props.aspectRatio);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    title,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    width,
    aspectRatio,
    cBase: cBase4,
    cWrapper,
    cInterface,
    cLabel,
    elemInput,
    prunedRestProps,
    classesLabel,
    classesLead,
    classesInterface,
    classActive,
    classesWrapper,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(35, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("regionLead" in $$props)
      $$invalidate(12, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$props)
      $$invalidate(13, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(15, active = $$new_props.active);
    if ("spacing" in $$props)
      $$invalidate(16, spacing = $$new_props.spacing);
    if ("width" in $$props)
      $$invalidate(17, width = $$new_props.width);
    if ("aspectRatio" in $$props)
      $$invalidate(18, aspectRatio = $$new_props.aspectRatio);
    if ("elemInput" in $$props)
      $$invalidate(4, elemInput = $$new_props.elemInput);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("classesLead" in $$props)
      $$invalidate(6, classesLead = $$new_props.classesLead);
    if ("classesInterface" in $$props)
      $$invalidate(7, classesInterface = $$new_props.classesInterface);
    if ("classActive" in $$props)
      $$invalidate(19, classActive = $$new_props.classActive);
    if ("classesWrapper" in $$props)
      $$invalidate(8, classesWrapper = $$new_props.classesWrapper);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*group, value, active*/
    32773) {
      $:
        $$invalidate(19, classActive = group === value ? active : "");
    }
    $:
      $$invalidate(9, classesBase = `${cBase4} ${$$props.class || ""}`);
    if ($$self.$$.dirty[0] & /*aspectRatio, width, hover, classActive*/
    933888) {
      $:
        $$invalidate(8, classesWrapper = `${cWrapper} ${aspectRatio} ${width} ${hover} ${classActive}`);
    }
    if ($$self.$$.dirty[0] & /*spacing*/
    65536) {
      $:
        $$invalidate(7, classesInterface = `${cInterface} ${spacing}`);
    }
    if ($$self.$$.dirty[0] & /*regionLead*/
    4096) {
      $:
        $$invalidate(6, classesLead = `${regionLead}`);
    }
    if ($$self.$$.dirty[0] & /*regionLabel*/
    8192) {
      $:
        $$invalidate(5, classesLabel = `${cLabel} ${regionLabel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    title,
    elemInput,
    classesLabel,
    classesLead,
    classesInterface,
    classesWrapper,
    classesBase,
    prunedRestProps,
    $$slots,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    width,
    aspectRatio,
    classActive,
    $$scope,
    slots,
    mouseover_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    input_binding,
    input_change_handler,
    $$binding_groups
  ];
}
var AppRailTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        regionLead: 12,
        regionLabel: 13,
        hover: 14,
        active: 15,
        spacing: 16,
        width: 17,
        aspectRatio: 18
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRailTile",
      options,
      id: create_fragment5.name
    });
  }
  get group() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRailTile_default = AppRailTile;

// node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRailAnchor.svelte
var file6 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\AppRail\\AppRailAnchor.svelte";
var get_lead_slot_changes5 = (dirty) => ({});
var get_lead_slot_context5 = (ctx) => ({});
function create_if_block4(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[16].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_lead_slot_context5
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-lead " + /*classesLead*/
      ctx[1]);
      add_location(div, file6, 42, 20, 1137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_lead_slot_changes5
            ),
            get_lead_slot_context5
          );
        }
      }
      if (!current || dirty & /*classesLead*/
      2 && div_class_value !== (div_class_value = "app-rail-lead " + /*classesLead*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(43:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let a;
  let div1;
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let a_class_value;
  let a_href_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[6].lead && create_if_block4(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let a_levels = [
    {
      class: a_class_value = "app-rail-anchor " + /*classesBase*/
      ctx[3]
    },
    {
      href: a_href_value = /*$$props*/
      ctx[5].href
    },
    /*prunedRestProps*/
    ctx[4](),
    { "data-testid": "app-rail-anchor" }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        class: true,
        href: true,
        "data-testid": true
      });
      var a_nodes = children(a);
      div1 = claim_element(a_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-rail-label " + /*classesLabel*/
      ctx[0]);
      add_location(div0, file6, 43, 2, 1212);
      attr_dev(div1, "class", div1_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx[2]);
      add_location(div1, file6, 41, 1, 1069);
      set_attributes(a, a_data);
      add_location(a, file6, 27, 0, 855);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keypress",
            /*keypress_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[6].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesLabel*/
      1 && div0_class_value !== (div0_class_value = "app-rail-label " + /*classesLabel*/
      ctx2[0])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classesWrapper*/
      4 && div1_class_value !== (div1_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx2[2])) {
        attr_dev(div1, "class", div1_class_value);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classesBase*/
        8 && a_class_value !== (a_class_value = "app-rail-anchor " + /*classesBase*/
        ctx2[3])) && { class: a_class_value },
        (!current || dirty & /*$$props*/
        32 && a_href_value !== (a_href_value = /*$$props*/
        ctx2[5].href)) && { href: a_href_value },
        /*prunedRestProps*/
        ctx2[4](),
        { "data-testid": "app-rail-anchor" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase5 = "unstyled";
var cWrapper2 = "w-full flex flex-col justify-center items-stretch text-center space-y-1";
var cLabel2 = "font-bold text-xs";
function instance6($$self, $$props, $$invalidate) {
  let classActive;
  let classesBase;
  let classesWrapper;
  let classesLead;
  let classesLabel;
  const omit_props_names = ["selected", "regionLead", "regionLabel", "hover", "active", "spacing", "aspectRatio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRailAnchor", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { regionLead = "flex justify-center items-center" } = $$props;
  let { regionLabel = "" } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { active = getContext("active") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let { aspectRatio = getContext("aspectRatio") } = $$props;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("regionLead" in $$new_props)
      $$invalidate(8, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$new_props)
      $$invalidate(9, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$new_props)
      $$invalidate(13, aspectRatio = $$new_props.aspectRatio);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    selected,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    aspectRatio,
    cBase: cBase5,
    cWrapper: cWrapper2,
    cLabel: cLabel2,
    prunedRestProps,
    classesLabel,
    classesLead,
    classActive,
    classesWrapper,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("regionLead" in $$props)
      $$invalidate(8, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$props)
      $$invalidate(9, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$props)
      $$invalidate(13, aspectRatio = $$new_props.aspectRatio);
    if ("classesLabel" in $$props)
      $$invalidate(0, classesLabel = $$new_props.classesLabel);
    if ("classesLead" in $$props)
      $$invalidate(1, classesLead = $$new_props.classesLead);
    if ("classActive" in $$props)
      $$invalidate(14, classActive = $$new_props.classActive);
    if ("classesWrapper" in $$props)
      $$invalidate(2, classesWrapper = $$new_props.classesWrapper);
    if ("classesBase" in $$props)
      $$invalidate(3, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected, active*/
    2176) {
      $:
        $$invalidate(14, classActive = selected ? active : "");
    }
    $:
      $$invalidate(3, classesBase = `${cBase5} ${$$props.class || ""}`);
    if ($$self.$$.dirty & /*aspectRatio, hover, spacing, classActive*/
    29696) {
      $:
        $$invalidate(2, classesWrapper = `${cWrapper2} ${aspectRatio} ${hover} ${spacing} ${classActive}`);
    }
    if ($$self.$$.dirty & /*regionLead*/
    256) {
      $:
        $$invalidate(1, classesLead = `${regionLead}`);
    }
    if ($$self.$$.dirty & /*regionLabel*/
    512) {
      $:
        $$invalidate(0, classesLabel = `${cLabel2} ${regionLabel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    classesLabel,
    classesLead,
    classesWrapper,
    classesBase,
    prunedRestProps,
    $$props,
    $$slots,
    selected,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    aspectRatio,
    classActive,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler
  ];
}
var AppRailAnchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      selected: 7,
      regionLead: 8,
      regionLabel: 9,
      hover: 10,
      active: 11,
      spacing: 12,
      aspectRatio: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRailAnchor",
      options,
      id: create_fragment6.name
    });
  }
  get selected() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRailAnchor_default = AppRailAnchor;

// node_modules/@skeletonlabs/skeleton/dist/components/AppShell/AppShell.svelte
var file7 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\AppShell\\AppShell.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
var get_sidebarRight_slot_changes = (dirty) => ({});
var get_sidebarRight_slot_context = (ctx) => ({});
var get_pageFooter_slot_changes = (dirty) => ({});
var get_pageFooter_slot_context = (ctx) => ({});
var get_pageHeader_slot_changes = (dirty) => ({});
var get_pageHeader_slot_context = (ctx) => ({});
var get_sidebarLeft_slot_changes = (dirty) => ({});
var get_sidebarLeft_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block_5(ctx) {
  let header;
  let header_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[18].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      header = element("header");
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (header_slot)
        header_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "shell-header");
      attr_dev(header, "class", header_class_value = "flex-none " + /*classesHeader*/
      ctx[7]);
      add_location(header, file7, 34, 2, 1124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (header_slot) {
        header_slot.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*classesHeader*/
      128 && header_class_value !== (header_class_value = "flex-none " + /*classesHeader*/
      ctx2[7])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(34:1) {#if $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let aside;
  let current;
  const sidebarLeft_slot_template = (
    /*#slots*/
    ctx[18].sidebarLeft
  );
  const sidebarLeft_slot = create_slot(
    sidebarLeft_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_sidebarLeft_slot_context
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarLeft_slot)
        sidebarLeft_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-left");
      attr_dev(
        aside,
        "class",
        /*classesSidebarLeft*/
        ctx[6]
      );
      add_location(aside, file7, 41, 3, 1350);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarLeft_slot) {
        sidebarLeft_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarLeft_slot) {
        if (sidebarLeft_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            sidebarLeft_slot,
            sidebarLeft_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              sidebarLeft_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_sidebarLeft_slot_changes
            ),
            get_sidebarLeft_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSidebarLeft*/
      64) {
        attr_dev(
          aside,
          "class",
          /*classesSidebarLeft*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarLeft_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarLeft_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(41:2) {#if $$slots.sidebarLeft}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let header;
  let header_class_value;
  let current;
  const pageHeader_slot_template = (
    /*#slots*/
    ctx[18].pageHeader
  );
  const pageHeader_slot = create_slot(
    pageHeader_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_pageHeader_slot_context
  );
  const pageHeader_slot_or_fallback = pageHeader_slot || fallback_block_12(ctx);
  const block = {
    c: function create() {
      header = element("header");
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "page-header");
      attr_dev(header, "class", header_class_value = "flex-none " + /*classesPageHeader*/
      ctx[4]);
      add_location(header, file7, 48, 4, 1582);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (pageHeader_slot_or_fallback) {
        pageHeader_slot_or_fallback.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageHeader_slot) {
        if (pageHeader_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            pageHeader_slot,
            pageHeader_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              pageHeader_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_pageHeader_slot_changes
            ),
            get_pageHeader_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPageHeader*/
      16 && header_class_value !== (header_class_value = "flex-none " + /*classesPageHeader*/
      ctx2[4])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageHeader_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageHeader_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(48:3) {#if $$slots.pageHeader}",
    ctx
  });
  return block;
}
function fallback_block_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:header)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:header)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(49:91) (slot:header)",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const pageFooter_slot_template = (
    /*#slots*/
    ctx[18].pageFooter
  );
  const pageFooter_slot = create_slot(
    pageFooter_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_pageFooter_slot_context
  );
  const pageFooter_slot_or_fallback = pageFooter_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      footer = element("footer");
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "page-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + /*classesPageFooter*/
      ctx[2]);
      add_location(footer, file7, 56, 4, 1895);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (pageFooter_slot_or_fallback) {
        pageFooter_slot_or_fallback.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageFooter_slot) {
        if (pageFooter_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            pageFooter_slot,
            pageFooter_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              pageFooter_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_pageFooter_slot_changes
            ),
            get_pageFooter_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPageFooter*/
      4 && footer_class_value !== (footer_class_value = "flex-none " + /*classesPageFooter*/
      ctx2[2])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageFooter_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageFooter_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(56:3) {#if $$slots.pageFooter}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:footer)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:footer)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(57:91) (slot:footer)",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let aside;
  let current;
  const sidebarRight_slot_template = (
    /*#slots*/
    ctx[18].sidebarRight
  );
  const sidebarRight_slot = create_slot(
    sidebarRight_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_sidebarRight_slot_context
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarRight_slot)
        sidebarRight_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-right");
      attr_dev(
        aside,
        "class",
        /*classesSidebarRight*/
        ctx[5]
      );
      add_location(aside, file7, 62, 3, 2096);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarRight_slot) {
        sidebarRight_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarRight_slot) {
        if (sidebarRight_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            sidebarRight_slot,
            sidebarRight_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              sidebarRight_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_sidebarRight_slot_changes
            ),
            get_sidebarRight_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSidebarRight*/
      32) {
        attr_dev(
          aside,
          "class",
          /*classesSidebarRight*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarRight_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarRight_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(62:2) {#if $$slots.sidebarRight}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[18].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      footer = element("footer");
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (footer_slot)
        footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "shell-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + /*classesFooter*/
      ctx[1]);
      add_location(footer, file7, 68, 2, 2251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty & /*classesFooter*/
      2 && footer_class_value !== (footer_class_value = "flex-none " + /*classesFooter*/
      ctx2[1])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(68:1) {#if $$slots.footer}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let main;
  let main_class_value;
  let t3;
  let div0_class_value;
  let t4;
  let div1_class_value;
  let t5;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[9].header && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[9].sidebarLeft && create_if_block_4(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[9].pageHeader && create_if_block_3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let if_block3 = (
    /*$$slots*/
    ctx[9].pageFooter && create_if_block_22(ctx)
  );
  let if_block4 = (
    /*$$slots*/
    ctx[9].sidebarRight && create_if_block_13(ctx)
  );
  let if_block5 = (
    /*$$slots*/
    ctx[9].footer && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      main = element("main");
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true
      });
      var div2_nodes = children(div2);
      if (if_block0)
        if_block0.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
      var div0_nodes = children(div0);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      main = claim_element(div0_nodes, "MAIN", { id: true, class: true });
      var main_nodes = children(main);
      if (default_slot)
        default_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      if (if_block4)
        if_block4.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t5 = claim_space(div2_nodes);
      if (if_block5)
        if_block5.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(main, "id", "page-content");
      attr_dev(main, "class", main_class_value = "flex-auto " + /*classesPageContent*/
      ctx[3]);
      add_location(main, file7, 52, 3, 1753);
      attr_dev(div0, "id", "page");
      attr_dev(div0, "class", div0_class_value = /*regionPage*/
      ctx[0] + " " + cPage);
      add_location(div0, file7, 45, 2, 1465);
      attr_dev(div1, "class", div1_class_value = "flex-auto " + cContentArea);
      add_location(div1, file7, 38, 1, 1248);
      attr_dev(div2, "id", "appShell");
      attr_dev(
        div2,
        "class",
        /*classesBase*/
        ctx[8]
      );
      attr_dev(div2, "data-testid", "app-shell");
      add_location(div2, file7, 31, 0, 1013);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, main);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append_hydration_dev(div0, t3);
      if (if_block3)
        if_block3.m(div0, null);
      append_hydration_dev(div1, t4);
      if (if_block4)
        if_block4.m(div1, null);
      append_hydration_dev(div2, t5);
      if (if_block5)
        if_block5.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div0,
          "scroll",
          /*scroll_handler*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[9].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[9].sidebarLeft
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[9].pageHeader
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesPageContent*/
      8 && main_class_value !== (main_class_value = "flex-auto " + /*classesPageContent*/
      ctx2[3])) {
        attr_dev(main, "class", main_class_value);
      }
      if (
        /*$$slots*/
        ctx2[9].pageFooter
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_22(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*regionPage*/
      1 && div0_class_value !== (div0_class_value = /*regionPage*/
      ctx2[0] + " " + cPage)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[9].sidebarRight
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_13(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[9].footer
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block5(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      256) {
        attr_dev(
          div2,
          "class",
          /*classesBase*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseAppShell = "w-full h-full flex flex-col overflow-hidden";
var cContentArea = "w-full h-full flex overflow-hidden";
var cPage = "flex-1 overflow-x-hidden flex flex-col";
var cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto";
var cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance7($$self, $$props, $$invalidate) {
  let classesBase;
  let classesHeader;
  let classesSidebarLeft;
  let classesSidebarRight;
  let classesPageHeader;
  let classesPageContent;
  let classesPageFooter;
  let classesFooter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppShell", slots, [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ]);
  const $$slots = compute_slots(slots);
  let { regionPage = "" } = $$props;
  let { slotHeader = "z-10" } = $$props;
  let { slotSidebarLeft = "w-auto" } = $$props;
  let { slotSidebarRight = "w-auto" } = $$props;
  let { slotPageHeader = "" } = $$props;
  let { slotPageContent = "" } = $$props;
  let { slotPageFooter = "" } = $$props;
  let { slotFooter = "" } = $$props;
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("regionPage" in $$new_props)
      $$invalidate(0, regionPage = $$new_props.regionPage);
    if ("slotHeader" in $$new_props)
      $$invalidate(10, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$new_props)
      $$invalidate(11, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$new_props)
      $$invalidate(12, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$new_props)
      $$invalidate(13, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$new_props)
      $$invalidate(14, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$new_props)
      $$invalidate(15, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$new_props)
      $$invalidate(16, slotFooter = $$new_props.slotFooter);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    regionPage,
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    cBaseAppShell,
    cContentArea,
    cPage,
    cSidebarLeft,
    cSidebarRight,
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesHeader,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    if ("regionPage" in $$props)
      $$invalidate(0, regionPage = $$new_props.regionPage);
    if ("slotHeader" in $$props)
      $$invalidate(10, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$props)
      $$invalidate(11, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$props)
      $$invalidate(12, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$props)
      $$invalidate(13, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$props)
      $$invalidate(14, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$props)
      $$invalidate(15, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$props)
      $$invalidate(16, slotFooter = $$new_props.slotFooter);
    if ("classesFooter" in $$props)
      $$invalidate(1, classesFooter = $$new_props.classesFooter);
    if ("classesPageFooter" in $$props)
      $$invalidate(2, classesPageFooter = $$new_props.classesPageFooter);
    if ("classesPageContent" in $$props)
      $$invalidate(3, classesPageContent = $$new_props.classesPageContent);
    if ("classesPageHeader" in $$props)
      $$invalidate(4, classesPageHeader = $$new_props.classesPageHeader);
    if ("classesSidebarRight" in $$props)
      $$invalidate(5, classesSidebarRight = $$new_props.classesSidebarRight);
    if ("classesSidebarLeft" in $$props)
      $$invalidate(6, classesSidebarLeft = $$new_props.classesSidebarLeft);
    if ("classesHeader" in $$props)
      $$invalidate(7, classesHeader = $$new_props.classesHeader);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(8, classesBase = `${cBaseAppShell} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*slotHeader*/
    1024) {
      $:
        $$invalidate(7, classesHeader = `${slotHeader}`);
    }
    if ($$self.$$.dirty & /*slotSidebarLeft*/
    2048) {
      $:
        $$invalidate(6, classesSidebarLeft = `${cSidebarLeft} ${slotSidebarLeft}`);
    }
    if ($$self.$$.dirty & /*slotSidebarRight*/
    4096) {
      $:
        $$invalidate(5, classesSidebarRight = `${cSidebarRight} ${slotSidebarRight}`);
    }
    if ($$self.$$.dirty & /*slotPageHeader*/
    8192) {
      $:
        $$invalidate(4, classesPageHeader = `${slotPageHeader}`);
    }
    if ($$self.$$.dirty & /*slotPageContent*/
    16384) {
      $:
        $$invalidate(3, classesPageContent = `${slotPageContent}`);
    }
    if ($$self.$$.dirty & /*slotPageFooter*/
    32768) {
      $:
        $$invalidate(2, classesPageFooter = `${slotPageFooter}`);
    }
    if ($$self.$$.dirty & /*slotFooter*/
    65536) {
      $:
        $$invalidate(1, classesFooter = `${slotFooter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    regionPage,
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesHeader,
    classesBase,
    $$slots,
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    $$scope,
    slots,
    scroll_handler
  ];
}
var AppShell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      regionPage: 0,
      slotHeader: 10,
      slotSidebarLeft: 11,
      slotSidebarRight: 12,
      slotPageHeader: 13,
      slotPageContent: 14,
      slotPageFooter: 15,
      slotFooter: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppShell",
      options,
      id: create_fragment7.name
    });
  }
  get regionPage() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPage(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarLeft() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarLeft(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarRight() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarRight(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageContent() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageContent(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppShell_default = AppShell;

// node_modules/@skeletonlabs/skeleton/dist/components/Autocomplete/Autocomplete.svelte
var file8 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Autocomplete\\Autocomplete.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*emptyState*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*emptyState*/
        ctx[0]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "autocomplete-empty " + /*classesEmpty*/
      ctx[2]);
      add_location(div, file8, 81, 2, 2485);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*emptyState*/
      1)
        set_data_dev(
          t,
          /*emptyState*/
          ctx2[0]
        );
      if (dirty[0] & /*classesEmpty*/
      4 && div_class_value !== (div_class_value = "autocomplete-empty " + /*classesEmpty*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(81:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let nav;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let ul_class_value;
  let nav_class_value;
  let each_value = (
    /*optionsFiltered*/
    ctx[1].slice(
      0,
      /*sliceLimit*/
      ctx[8]
    )
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*option*/
    ctx2[32]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "autocomplete-list " + /*classesList*/
      ctx[5]);
      add_location(ul, file8, 70, 3, 2095);
      attr_dev(nav, "class", nav_class_value = "autocomplete-nav " + /*classesNav*/
      ctx[6]);
      add_location(nav, file8, 69, 2, 2048);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*classesItem, classesButton, onSelection, optionsFiltered, sliceLimit*/
      794) {
        each_value = /*optionsFiltered*/
        ctx2[1].slice(
          0,
          /*sliceLimit*/
          ctx2[8]
        );
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block, null, get_each_context);
      }
      if (dirty[0] & /*classesList*/
      32 && ul_class_value !== (ul_class_value = "autocomplete-list " + /*classesList*/
      ctx2[5])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (dirty[0] & /*classesNav*/
      64 && nav_class_value !== (nav_class_value = "autocomplete-nav " + /*classesNav*/
      ctx2[6])) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(69:1) {#if optionsFiltered.length > 0}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let li;
  let button;
  let raw_value = (
    /*option*/
    ctx[32].label + ""
  );
  let button_class_value;
  let t;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[26](
        /*option*/
        ctx[32]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      button = element("button");
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { class: true, type: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "autocomplete-button " + /*classesButton*/
      ctx[3]);
      attr_dev(button, "type", "button");
      add_location(button, file8, 73, 6, 2264);
      attr_dev(li, "class", li_class_value = "autocomplete-item " + /*classesItem*/
      ctx[4]);
      add_location(li, file8, 72, 5, 2213);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      button.innerHTML = raw_value;
      append_hydration_dev(li, t);
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler_1, false, false, false, false),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*optionsFiltered, sliceLimit*/
      258 && raw_value !== (raw_value = /*option*/
      ctx[32].label + ""))
        button.innerHTML = raw_value;
      ;
      if (dirty[0] & /*classesButton*/
      8 && button_class_value !== (button_class_value = "autocomplete-button " + /*classesButton*/
      ctx[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*classesItem*/
      16 && li_class_value !== (li_class_value = "autocomplete-item " + /*classesItem*/
      ctx[4])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(72:4) {#each optionsFiltered.slice(0, sliceLimit) as option (option)}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let div;
  let div_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*optionsFiltered*/
      ctx2[1].length > 0
    )
      return create_if_block6;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "autocomplete " + /*classesBase*/
      ctx[7]);
      attr_dev(div, "data-testid", "autocomplete");
      add_location(div, file8, 67, 0, 1944);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_block.m(div, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty[0] & /*classesBase*/
      128 && div_class_value !== (div_class_value = "autocomplete " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let listedOptions;
  let optionsFiltered;
  let sliceLimit;
  let classesBase;
  let classesNav;
  let classesList;
  let classesItem;
  let classesButton;
  let classesEmpty;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Autocomplete", slots, []);
  const dispatch = createEventDispatcher();
  let { input = void 0 } = $$props;
  let { options = [] } = $$props;
  let { limit = void 0 } = $$props;
  let { allowlist = [] } = $$props;
  let { denylist = [] } = $$props;
  let { emptyState = "No Results Found." } = $$props;
  let { regionNav = "" } = $$props;
  let { regionList = "list-nav" } = $$props;
  let { regionItem = "" } = $$props;
  let { regionButton = "w-full" } = $$props;
  let { regionEmpty = "text-center" } = $$props;
  let { whitelist = [] } = $$props;
  let { blacklist = [] } = $$props;
  let { duration = 200 } = $$props;
  const deprecated = [whitelist, blacklist, duration];
  function filterByAllowDeny() {
    let _options = [...options];
    if (allowlist.length) {
      _options = _options.filter((option) => allowlist.includes(option.value));
    }
    if (denylist.length) {
      _options = _options.filter((option) => !denylist.includes(option.value));
    }
    if (!allowlist.length && !denylist.length) {
      _options = options;
    }
    $$invalidate(23, listedOptions = _options);
  }
  function filterOptions() {
    let _options = [...listedOptions];
    _options = _options.filter((option) => {
      const inputFormatted = String(input).toLowerCase().trim();
      let optionFormatted = JSON.stringify([option.label, option.value, option.keywords]).toLowerCase();
      if (optionFormatted.includes(inputFormatted))
        return option;
    });
    return _options;
  }
  function onSelection(option) {
    dispatch("selection", option);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = (option) => onSelection(option);
  $$self.$$set = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("input" in $$new_props)
      $$invalidate(10, input = $$new_props.input);
    if ("options" in $$new_props)
      $$invalidate(11, options = $$new_props.options);
    if ("limit" in $$new_props)
      $$invalidate(12, limit = $$new_props.limit);
    if ("allowlist" in $$new_props)
      $$invalidate(13, allowlist = $$new_props.allowlist);
    if ("denylist" in $$new_props)
      $$invalidate(14, denylist = $$new_props.denylist);
    if ("emptyState" in $$new_props)
      $$invalidate(0, emptyState = $$new_props.emptyState);
    if ("regionNav" in $$new_props)
      $$invalidate(15, regionNav = $$new_props.regionNav);
    if ("regionList" in $$new_props)
      $$invalidate(16, regionList = $$new_props.regionList);
    if ("regionItem" in $$new_props)
      $$invalidate(17, regionItem = $$new_props.regionItem);
    if ("regionButton" in $$new_props)
      $$invalidate(18, regionButton = $$new_props.regionButton);
    if ("regionEmpty" in $$new_props)
      $$invalidate(19, regionEmpty = $$new_props.regionEmpty);
    if ("whitelist" in $$new_props)
      $$invalidate(20, whitelist = $$new_props.whitelist);
    if ("blacklist" in $$new_props)
      $$invalidate(21, blacklist = $$new_props.blacklist);
    if ("duration" in $$new_props)
      $$invalidate(22, duration = $$new_props.duration);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    input,
    options,
    limit,
    allowlist,
    denylist,
    emptyState,
    regionNav,
    regionList,
    regionItem,
    regionButton,
    regionEmpty,
    whitelist,
    blacklist,
    duration,
    deprecated,
    filterByAllowDeny,
    filterOptions,
    onSelection,
    classesEmpty,
    classesButton,
    classesItem,
    classesList,
    classesNav,
    classesBase,
    optionsFiltered,
    sliceLimit,
    listedOptions
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    if ("input" in $$props)
      $$invalidate(10, input = $$new_props.input);
    if ("options" in $$props)
      $$invalidate(11, options = $$new_props.options);
    if ("limit" in $$props)
      $$invalidate(12, limit = $$new_props.limit);
    if ("allowlist" in $$props)
      $$invalidate(13, allowlist = $$new_props.allowlist);
    if ("denylist" in $$props)
      $$invalidate(14, denylist = $$new_props.denylist);
    if ("emptyState" in $$props)
      $$invalidate(0, emptyState = $$new_props.emptyState);
    if ("regionNav" in $$props)
      $$invalidate(15, regionNav = $$new_props.regionNav);
    if ("regionList" in $$props)
      $$invalidate(16, regionList = $$new_props.regionList);
    if ("regionItem" in $$props)
      $$invalidate(17, regionItem = $$new_props.regionItem);
    if ("regionButton" in $$props)
      $$invalidate(18, regionButton = $$new_props.regionButton);
    if ("regionEmpty" in $$props)
      $$invalidate(19, regionEmpty = $$new_props.regionEmpty);
    if ("whitelist" in $$props)
      $$invalidate(20, whitelist = $$new_props.whitelist);
    if ("blacklist" in $$props)
      $$invalidate(21, blacklist = $$new_props.blacklist);
    if ("duration" in $$props)
      $$invalidate(22, duration = $$new_props.duration);
    if ("classesEmpty" in $$props)
      $$invalidate(2, classesEmpty = $$new_props.classesEmpty);
    if ("classesButton" in $$props)
      $$invalidate(3, classesButton = $$new_props.classesButton);
    if ("classesItem" in $$props)
      $$invalidate(4, classesItem = $$new_props.classesItem);
    if ("classesList" in $$props)
      $$invalidate(5, classesList = $$new_props.classesList);
    if ("classesNav" in $$props)
      $$invalidate(6, classesNav = $$new_props.classesNav);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
    if ("optionsFiltered" in $$props)
      $$invalidate(1, optionsFiltered = $$new_props.optionsFiltered);
    if ("sliceLimit" in $$props)
      $$invalidate(8, sliceLimit = $$new_props.sliceLimit);
    if ("listedOptions" in $$props)
      $$invalidate(23, listedOptions = $$new_props.listedOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    2048) {
      $:
        $$invalidate(23, listedOptions = options);
    }
    if ($$self.$$.dirty[0] & /*allowlist, denylist*/
    24576) {
      $:
        if (allowlist.length || denylist.length)
          filterByAllowDeny();
    }
    if ($$self.$$.dirty[0] & /*input, listedOptions*/
    8389632) {
      $:
        $$invalidate(1, optionsFiltered = input ? filterOptions() : listedOptions);
    }
    if ($$self.$$.dirty[0] & /*limit, optionsFiltered*/
    4098) {
      $:
        $$invalidate(8, sliceLimit = limit !== void 0 ? limit : optionsFiltered.length);
    }
    $:
      $$invalidate(7, classesBase = `${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*regionNav*/
    32768) {
      $:
        $$invalidate(6, classesNav = `${regionNav}`);
    }
    if ($$self.$$.dirty[0] & /*regionList*/
    65536) {
      $:
        $$invalidate(5, classesList = `${regionList}`);
    }
    if ($$self.$$.dirty[0] & /*regionItem*/
    131072) {
      $:
        $$invalidate(4, classesItem = `${regionItem}`);
    }
    if ($$self.$$.dirty[0] & /*regionButton*/
    262144) {
      $:
        $$invalidate(3, classesButton = `${regionButton}`);
    }
    if ($$self.$$.dirty[0] & /*regionEmpty*/
    524288) {
      $:
        $$invalidate(2, classesEmpty = `${regionEmpty}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    emptyState,
    optionsFiltered,
    classesEmpty,
    classesButton,
    classesItem,
    classesList,
    classesNav,
    classesBase,
    sliceLimit,
    onSelection,
    input,
    options,
    limit,
    allowlist,
    denylist,
    regionNav,
    regionList,
    regionItem,
    regionButton,
    regionEmpty,
    whitelist,
    blacklist,
    duration,
    listedOptions,
    click_handler,
    keypress_handler,
    click_handler_1
  ];
}
var Autocomplete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        input: 10,
        options: 11,
        limit: 12,
        allowlist: 13,
        denylist: 14,
        emptyState: 0,
        regionNav: 15,
        regionList: 16,
        regionItem: 17,
        regionButton: 18,
        regionEmpty: 19,
        whitelist: 20,
        blacklist: 21,
        duration: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Autocomplete",
      options,
      id: create_fragment8.name
    });
  }
  get input() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowlist() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowlist(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get denylist() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set denylist(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyState() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyState(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionNav() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionNav(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionItem() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionItem(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionButton() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionButton(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionEmpty() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionEmpty(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get whitelist() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set whitelist(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blacklist() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blacklist(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Autocomplete_default = Autocomplete;

// node_modules/@skeletonlabs/skeleton/dist/components/Avatar/Avatar.svelte
var file9 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Avatar\\Avatar.svelte";
function create_else_block2(ctx) {
  let svg;
  let text_1;
  let t_value = String(
    /*initials*/
    ctx[1]
  ).substring(0, 2).toUpperCase() + "";
  let t;
  let text_1_font_size_value;
  let text_1_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      text_1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "dominant-baseline": true,
        "text-anchor": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "dominant-baseline", "central");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(text_1, "font-size", text_1_font_size_value = 150);
      attr_dev(text_1, "class", text_1_class_value = "avatar-text " + /*fill*/
      ctx[2]);
      add_location(text_1, file9, 38, 3, 1224);
      attr_dev(svg, "class", "avatar-initials w-full h-full");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file9, 37, 2, 1155);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, text_1);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*initials*/
      2 && t_value !== (t_value = String(
        /*initials*/
        ctx2[1]
      ).substring(0, 2).toUpperCase() + ""))
        set_data_dev(t, t_value);
      if (dirty & /*fill*/
      4 && text_1_class_value !== (text_1_class_value = "avatar-text " + /*fill*/
      ctx2[2])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(37:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let img;
  let img_class_value;
  let img_style_value;
  let img_src_value;
  let img_alt_value;
  let action_action;
  let mounted;
  let dispose;
  let img_levels = [
    {
      class: img_class_value = "avatar-image " + /*cImage*/
      ctx[7]
    },
    {
      style: img_style_value = /*$$props*/
      ctx[9].style ?? ""
    },
    { src: img_src_value = /*src*/
    ctx[0] },
    {
      alt: img_alt_value = /*$$props*/
      ctx[9].alt || ""
    },
    /*prunedRestProps*/
    ctx[8]()
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file9, 27, 2, 942);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(action_action = /*action*/
          ctx[4].call(
            null,
            img,
            /*actionParams*/
            ctx[5]
          )),
          listen_dev(
            img,
            "error",
            /*error_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        { class: img_class_value },
        dirty & /*$$props*/
        512 && img_style_value !== (img_style_value = /*$$props*/
        ctx2[9].style ?? "") && { style: img_style_value },
        dirty & /*src*/
        1 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[0]) && { src: img_src_value },
        dirty & /*$$props*/
        512 && img_alt_value !== (img_alt_value = /*$$props*/
        ctx2[9].alt || "") && { alt: img_alt_value },
        /*prunedRestProps*/
        ctx2[8]()
      ]));
      if (action_action && is_function(action_action.update) && dirty & /*actionParams*/
      32)
        action_action.update.call(
          null,
          /*actionParams*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(27:1) {#if src}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let figure;
  let figure_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[0]
    )
      return create_if_block7;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      figure = element("figure");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if_block.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "avatar " + /*classesBase*/
      ctx[6]);
      attr_dev(figure, "data-testid", "avatar");
      add_location(figure, file9, 25, 0, 829);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if_block.m(figure, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            figure,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keydown",
            /*keydown_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keyup",
            /*keyup_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(figure, null);
        }
      }
      if (dirty & /*classesBase*/
      64 && figure_class_value !== (figure_class_value = "avatar " + /*classesBase*/
      ctx2[6])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let classesBase;
  const omit_props_names = [
    "initials",
    "fill",
    "src",
    "fallback",
    "action",
    "actionParams",
    "background",
    "width",
    "border",
    "rounded",
    "shadow",
    "cursor"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Avatar", slots, []);
  let { initials = "AB" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { src = "" } = $$props;
  let { fallback = "" } = $$props;
  let { action = () => {
  } } = $$props;
  let { actionParams = "" } = $$props;
  let { background = "bg-surface-400-500-token" } = $$props;
  let { width = "w-16" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { shadow = "" } = $$props;
  let { cursor = "" } = $$props;
  let cBase25 = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate";
  let cImage = "w-full h-full object-cover";
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const error_handler = () => $$invalidate(0, src = fallback);
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("initials" in $$new_props)
      $$invalidate(1, initials = $$new_props.initials);
    if ("fill" in $$new_props)
      $$invalidate(2, fill = $$new_props.fill);
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("fallback" in $$new_props)
      $$invalidate(3, fallback = $$new_props.fallback);
    if ("action" in $$new_props)
      $$invalidate(4, action = $$new_props.action);
    if ("actionParams" in $$new_props)
      $$invalidate(5, actionParams = $$new_props.actionParams);
    if ("background" in $$new_props)
      $$invalidate(10, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("border" in $$new_props)
      $$invalidate(12, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(14, shadow = $$new_props.shadow);
    if ("cursor" in $$new_props)
      $$invalidate(15, cursor = $$new_props.cursor);
  };
  $$self.$capture_state = () => ({
    initials,
    fill,
    src,
    fallback,
    action,
    actionParams,
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    cBase: cBase25,
    cImage,
    prunedRestProps,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("initials" in $$props)
      $$invalidate(1, initials = $$new_props.initials);
    if ("fill" in $$props)
      $$invalidate(2, fill = $$new_props.fill);
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("fallback" in $$props)
      $$invalidate(3, fallback = $$new_props.fallback);
    if ("action" in $$props)
      $$invalidate(4, action = $$new_props.action);
    if ("actionParams" in $$props)
      $$invalidate(5, actionParams = $$new_props.actionParams);
    if ("background" in $$props)
      $$invalidate(10, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("border" in $$props)
      $$invalidate(12, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(14, shadow = $$new_props.shadow);
    if ("cursor" in $$props)
      $$invalidate(15, cursor = $$new_props.cursor);
    if ("cBase" in $$props)
      $$invalidate(21, cBase25 = $$new_props.cBase);
    if ("cImage" in $$props)
      $$invalidate(7, cImage = $$new_props.cImage);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase25} ${background} ${width} ${border} ${rounded} ${shadow} ${cursor} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    src,
    initials,
    fill,
    fallback,
    action,
    actionParams,
    classesBase,
    cImage,
    prunedRestProps,
    $$props,
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    error_handler
  ];
}
var Avatar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      initials: 1,
      fill: 2,
      src: 0,
      fallback: 3,
      action: 4,
      actionParams: 5,
      background: 10,
      width: 11,
      border: 12,
      rounded: 13,
      shadow: 14,
      cursor: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Avatar",
      options,
      id: create_fragment9.name
    });
  }
  get initials() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initials(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionParams() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionParams(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cursor() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cursor(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Avatar_default = Avatar;

// node_modules/@skeletonlabs/skeleton/dist/components/ConicGradient/settings.js
var tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      "50": { hex: "#f8fafc", rgb: "248 250 252" },
      "100": { hex: "#f1f5f9", rgb: "241 245 249" },
      "200": { hex: "#e2e8f0", rgb: "226 232 240" },
      "300": { hex: "#cbd5e1", rgb: "203 213 225" },
      "400": { hex: "#94a3b8", rgb: "148 163 184" },
      "500": { hex: "#64748b", rgb: "100 116 139" },
      "600": { hex: "#475569", rgb: "71 85 105" },
      "700": { hex: "#334155", rgb: "51 65 85" },
      "800": { hex: "#1e293b", rgb: "30 41 59" },
      "900": { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      "50": { hex: "#f9fafb", rgb: "249 250 251" },
      "100": { hex: "#f3f4f6", rgb: "243 244 246" },
      "200": { hex: "#e5e7eb", rgb: "229 231 235" },
      "300": { hex: "#d1d5db", rgb: "209 213 219" },
      "400": { hex: "#9ca3af", rgb: "156 163 175" },
      "500": { hex: "#6b7280", rgb: "107 114 128" },
      "600": { hex: "#4b5563", rgb: "75 85 99" },
      "700": { hex: "#374151", rgb: "55 65 81" },
      "800": { hex: "#1f2937", rgb: "31 41 55" },
      "900": { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f4f4f5", rgb: "244 244 245" },
      "200": { hex: "#e4e4e7", rgb: "228 228 231" },
      "300": { hex: "#d4d4d8", rgb: "212 212 216" },
      "400": { hex: "#a1a1aa", rgb: "161 161 170" },
      "500": { hex: "#71717a", rgb: "113 113 122" },
      "600": { hex: "#52525b", rgb: "82 82 91" },
      "700": { hex: "#3f3f46", rgb: "63 63 70" },
      "800": { hex: "#27272a", rgb: "39 39 42" },
      "900": { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f5f5f5", rgb: "245 245 245" },
      "200": { hex: "#e5e5e5", rgb: "229 229 229" },
      "300": { hex: "#d4d4d4", rgb: "212 212 212" },
      "400": { hex: "#a3a3a3", rgb: "163 163 163" },
      "500": { hex: "#737373", rgb: "115 115 115" },
      "600": { hex: "#525252", rgb: "82 82 82" },
      "700": { hex: "#404040", rgb: "64 64 64" },
      "800": { hex: "#262626", rgb: "38 38 38" },
      "900": { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      "50": { hex: "#fafaf9", rgb: "250 250 249" },
      "100": { hex: "#f5f5f4", rgb: "245 245 244" },
      "200": { hex: "#e7e5e4", rgb: "231 229 228" },
      "300": { hex: "#d6d3d1", rgb: "214 211 209" },
      "400": { hex: "#a8a29e", rgb: "168 162 158" },
      "500": { hex: "#78716c", rgb: "120 113 108" },
      "600": { hex: "#57534e", rgb: "87 83 78" },
      "700": { hex: "#44403c", rgb: "68 64 60" },
      "800": { hex: "#292524", rgb: "41 37 36" },
      "900": { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      "50": { hex: "#fef2f2", rgb: "254 242 242" },
      "100": { hex: "#fee2e2", rgb: "254 226 226" },
      "200": { hex: "#fecaca", rgb: "254 202 202" },
      "300": { hex: "#fca5a5", rgb: "252 165 165" },
      "400": { hex: "#f87171", rgb: "248 113 113" },
      "500": { hex: "#ef4444", rgb: "239 68 68" },
      "600": { hex: "#dc2626", rgb: "220 38 38" },
      "700": { hex: "#b91c1c", rgb: "185 28 28" },
      "800": { hex: "#991b1b", rgb: "153 27 27" },
      "900": { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      "50": { hex: "#fff7ed", rgb: "255 247 237" },
      "100": { hex: "#ffedd5", rgb: "255 237 213" },
      "200": { hex: "#fed7aa", rgb: "254 215 170" },
      "300": { hex: "#fdba74", rgb: "253 186 116" },
      "400": { hex: "#fb923c", rgb: "251 146 60" },
      "500": { hex: "#f97316", rgb: "249 115 22" },
      "600": { hex: "#ea580c", rgb: "234 88 12" },
      "700": { hex: "#c2410c", rgb: "194 65 12" },
      "800": { hex: "#9a3412", rgb: "154 52 18" },
      "900": { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      "50": { hex: "#fffbeb", rgb: "255 251 235" },
      "100": { hex: "#fef3c7", rgb: "254 243 199" },
      "200": { hex: "#fde68a", rgb: "253 230 138" },
      "300": { hex: "#fcd34d", rgb: "252 211 77" },
      "400": { hex: "#fbbf24", rgb: "251 191 36" },
      "500": { hex: "#f59e0b", rgb: "245 158 11" },
      "600": { hex: "#d97706", rgb: "217 119 6" },
      "700": { hex: "#b45309", rgb: "180 83 9" },
      "800": { hex: "#92400e", rgb: "146 64 14" },
      "900": { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      "50": { hex: "#fefce8", rgb: "254 252 232" },
      "100": { hex: "#fef9c3", rgb: "254 249 195" },
      "200": { hex: "#fef08a", rgb: "254 240 138" },
      "300": { hex: "#fde047", rgb: "253 224 71" },
      "400": { hex: "#facc15", rgb: "250 204 21" },
      "500": { hex: "#eab308", rgb: "234 179 8" },
      "600": { hex: "#ca8a04", rgb: "202 138 4" },
      "700": { hex: "#a16207", rgb: "161 98 7" },
      "800": { hex: "#854d0e", rgb: "133 77 14" },
      "900": { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      "50": { hex: "#f7fee7", rgb: "247 254 231" },
      "100": { hex: "#ecfccb", rgb: "236 252 203" },
      "200": { hex: "#d9f99d", rgb: "217 249 157" },
      "300": { hex: "#bef264", rgb: "190 242 100" },
      "400": { hex: "#a3e635", rgb: "163 230 53" },
      "500": { hex: "#84cc16", rgb: "132 204 22" },
      "600": { hex: "#65a30d", rgb: "101 163 13" },
      "700": { hex: "#4d7c0f", rgb: "77 124 15" },
      "800": { hex: "#3f6212", rgb: "63 98 18" },
      "900": { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      "50": { hex: "#f0fdf4", rgb: "240 253 244" },
      "100": { hex: "#dcfce7", rgb: "220 252 231" },
      "200": { hex: "#bbf7d0", rgb: "187 247 208" },
      "300": { hex: "#86efac", rgb: "134 239 172" },
      "400": { hex: "#4ade80", rgb: "74 222 128" },
      "500": { hex: "#22c55e", rgb: "34 197 94" },
      "600": { hex: "#16a34a", rgb: "22 163 74" },
      "700": { hex: "#15803d", rgb: "21 128 61" },
      "800": { hex: "#166534", rgb: "22 101 52" },
      "900": { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      "50": { hex: "#ecfdf5", rgb: "236 253 245" },
      "100": { hex: "#d1fae5", rgb: "209 250 229" },
      "200": { hex: "#a7f3d0", rgb: "167 243 208" },
      "300": { hex: "#6ee7b7", rgb: "110 231 183" },
      "400": { hex: "#34d399", rgb: "52 211 153" },
      "500": { hex: "#10b981", rgb: "16 185 129" },
      "600": { hex: "#059669", rgb: "5 150 105" },
      "700": { hex: "#047857", rgb: "4 120 87" },
      "800": { hex: "#065f46", rgb: "6 95 70" },
      "900": { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      "50": { hex: "#f0fdfa", rgb: "240 253 250" },
      "100": { hex: "#ccfbf1", rgb: "204 251 241" },
      "200": { hex: "#99f6e4", rgb: "153 246 228" },
      "300": { hex: "#5eead4", rgb: "94 234 212" },
      "400": { hex: "#2dd4bf", rgb: "45 212 191" },
      "500": { hex: "#14b8a6", rgb: "20 184 166" },
      "600": { hex: "#0d9488", rgb: "13 148 136" },
      "700": { hex: "#0f766e", rgb: "15 118 110" },
      "800": { hex: "#115e59", rgb: "17 94 89" },
      "900": { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      "50": { hex: "#ecfeff", rgb: "236 254 255" },
      "100": { hex: "#cffafe", rgb: "207 250 254" },
      "200": { hex: "#a5f3fc", rgb: "165 243 252" },
      "300": { hex: "#67e8f9", rgb: "103 232 249" },
      "400": { hex: "#22d3ee", rgb: "34 211 238" },
      "500": { hex: "#06b6d4", rgb: "6 182 212" },
      "600": { hex: "#0891b2", rgb: "8 145 178" },
      "700": { hex: "#0e7490", rgb: "14 116 144" },
      "800": { hex: "#155e75", rgb: "21 94 117" },
      "900": { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      "50": { hex: "#f0f9ff", rgb: "240 249 255" },
      "100": { hex: "#e0f2fe", rgb: "224 242 254" },
      "200": { hex: "#bae6fd", rgb: "186 230 253" },
      "300": { hex: "#7dd3fc", rgb: "125 211 252" },
      "400": { hex: "#38bdf8", rgb: "56 189 248" },
      "500": { hex: "#0ea5e9", rgb: "14 165 233" },
      "600": { hex: "#0284c7", rgb: "2 132 199" },
      "700": { hex: "#0369a1", rgb: "3 105 161" },
      "800": { hex: "#075985", rgb: "7 89 133" },
      "900": { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      "50": { hex: "#eff6ff", rgb: "239 246 255" },
      "100": { hex: "#dbeafe", rgb: "219 234 254" },
      "200": { hex: "#bfdbfe", rgb: "191 219 254" },
      "300": { hex: "#93c5fd", rgb: "147 197 253" },
      "400": { hex: "#60a5fa", rgb: "96 165 250" },
      "500": { hex: "#3b82f6", rgb: "59 130 246" },
      "600": { hex: "#2563eb", rgb: "37 99 235" },
      "700": { hex: "#1d4ed8", rgb: "29 78 216" },
      "800": { hex: "#1e40af", rgb: "30 64 175" },
      "900": { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      "50": { hex: "#eef2ff", rgb: "238 242 255" },
      "100": { hex: "#e0e7ff", rgb: "224 231 255" },
      "200": { hex: "#c7d2fe", rgb: "199 210 254" },
      "300": { hex: "#a5b4fc", rgb: "165 180 252" },
      "400": { hex: "#818cf8", rgb: "129 140 248" },
      "500": { hex: "#6366f1", rgb: "99 102 241" },
      "600": { hex: "#4f46e5", rgb: "79 70 229" },
      "700": { hex: "#4338ca", rgb: "67 56 202" },
      "800": { hex: "#3730a3", rgb: "55 48 163" },
      "900": { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      "50": { hex: "#f5f3ff", rgb: "245 243 255" },
      "100": { hex: "#ede9fe", rgb: "237 233 254" },
      "200": { hex: "#ddd6fe", rgb: "221 214 254" },
      "300": { hex: "#c4b5fd", rgb: "196 181 253" },
      "400": { hex: "#a78bfa", rgb: "167 139 250" },
      "500": { hex: "#8b5cf6", rgb: "139 92 246" },
      "600": { hex: "#7c3aed", rgb: "124 58 237" },
      "700": { hex: "#6d28d9", rgb: "109 40 217" },
      "800": { hex: "#5b21b6", rgb: "91 33 182" },
      "900": { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      "50": { hex: "#faf5ff", rgb: "250 245 255" },
      "100": { hex: "#f3e8ff", rgb: "243 232 255" },
      "200": { hex: "#e9d5ff", rgb: "233 213 255" },
      "300": { hex: "#d8b4fe", rgb: "216 180 254" },
      "400": { hex: "#c084fc", rgb: "192 132 252" },
      "500": { hex: "#a855f7", rgb: "168 85 247" },
      "600": { hex: "#9333ea", rgb: "147 51 234" },
      "700": { hex: "#7e22ce", rgb: "126 34 206" },
      "800": { hex: "#6b21a8", rgb: "107 33 168" },
      "900": { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      "50": { hex: "#fdf4ff", rgb: "253 244 255" },
      "100": { hex: "#fae8ff", rgb: "250 232 255" },
      "200": { hex: "#f5d0fe", rgb: "245 208 254" },
      "300": { hex: "#f0abfc", rgb: "240 171 252" },
      "400": { hex: "#e879f9", rgb: "232 121 249" },
      "500": { hex: "#d946ef", rgb: "217 70 239" },
      "600": { hex: "#c026d3", rgb: "192 38 211" },
      "700": { hex: "#a21caf", rgb: "162 28 175" },
      "800": { hex: "#86198f", rgb: "134 25 143" },
      "900": { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      "50": { hex: "#fdf2f8", rgb: "253 242 248" },
      "100": { hex: "#fce7f3", rgb: "252 231 243" },
      "200": { hex: "#fbcfe8", rgb: "251 207 232" },
      "300": { hex: "#f9a8d4", rgb: "249 168 212" },
      "400": { hex: "#f472b6", rgb: "244 114 182" },
      "500": { hex: "#ec4899", rgb: "236 72 153" },
      "600": { hex: "#db2777", rgb: "219 39 119" },
      "700": { hex: "#be185d", rgb: "190 24 93" },
      "800": { hex: "#9d174d", rgb: "157 23 77" },
      "900": { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      "50": { hex: "#fff1f2", rgb: "255 241 242" },
      "100": { hex: "#ffe4e6", rgb: "255 228 230" },
      "200": { hex: "#fecdd3", rgb: "254 205 211" },
      "300": { hex: "#fda4af", rgb: "253 164 175" },
      "400": { hex: "#fb7185", rgb: "251 113 133" },
      "500": { hex: "#f43f5e", rgb: "244 63 94" },
      "600": { hex: "#e11d48", rgb: "225 29 72" },
      "700": { hex: "#be123c", rgb: "190 18 60" },
      "800": { hex: "#9f1239", rgb: "159 18 57" },
      "900": { hex: "#881337", rgb: "136 19 55" }
    }
  }
];

// node_modules/@skeletonlabs/skeleton/dist/components/ConicGradient/ConicGradient.svelte
var file10 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\ConicGradient\\ConicGradient.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i].color;
  child_ctx[27] = list[i].label;
  child_ctx[28] = list[i].value;
  return child_ctx;
}
function create_if_block_23(ctx) {
  let figcaption;
  let figcaption_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      figcaption = claim_element(nodes, "FIGCAPTION", { class: true });
      var figcaption_nodes = children(figcaption);
      if (default_slot)
        default_slot.l(figcaption_nodes);
      figcaption_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figcaption, "class", figcaption_class_value = "conic-caption " + /*classesCaption*/
      ctx[7]);
      add_location(figcaption, file10, 56, 2, 1670);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figcaption, anchor);
      if (default_slot) {
        default_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesCaption*/
      128 && figcaption_class_value !== (figcaption_class_value = "conic-caption " + /*classesCaption*/
      ctx2[7])) {
        attr_dev(figcaption, "class", figcaption_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figcaption);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(56:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "conic-cone " + /*classesCone*/
      ctx[6]);
      toggle_class(
        div,
        "animate-spin",
        /*spin*/
        ctx[1]
      );
      set_style(
        div,
        "background",
        /*cone*/
        ctx[3]
      );
      add_location(div, file10, 60, 2, 1789);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*classesCone*/
      64 && div_class_value !== (div_class_value = "conic-cone " + /*classesCone*/
      ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*classesCone, spin*/
      66) {
        toggle_class(
          div,
          "animate-spin",
          /*spin*/
          ctx2[1]
        );
      }
      if (dirty & /*cone*/
      8) {
        set_style(
          div,
          "background",
          /*cone*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(60:1) {#if cone}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let ul;
  let ul_class_value;
  let each_value = (
    /*generatedLegendList*/
    ctx[4]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "conic-list list " + /*classesLegend*/
      ctx[5]);
      add_location(ul, file10, 64, 2, 1943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*hover, generatedLegendList, cSwatch*/
      20) {
        each_value = /*generatedLegendList*/
        ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*classesLegend*/
      32 && ul_class_value !== (ul_class_value = "conic-list list " + /*classesLegend*/
      ctx2[5])) {
        attr_dev(ul, "class", ul_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(64:1) {#if legend && generatedLegendList}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let li;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1_value = (
    /*label*/
    ctx[27] + ""
  );
  let t1;
  let t2;
  let strong;
  let t3_value = (
    /*value*/
    ctx[28] + ""
  );
  let t3;
  let t4;
  let t5;
  let li_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      strong = element("strong");
      t3 = text(t3_value);
      t4 = text("%");
      t5 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      span0 = claim_element(li_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(li_nodes);
      span1 = claim_element(li_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      strong = claim_element(li_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      t3 = claim_text(strong_nodes, t3_value);
      t4 = claim_text(strong_nodes, "%");
      strong_nodes.forEach(detach_dev);
      t5 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = "conic-swatch " + cSwatch);
      set_style(
        span0,
        "background",
        /*color*/
        ctx[26]
      );
      add_location(span0, file10, 69, 5, 2232);
      attr_dev(span1, "class", "conic-label flex-auto");
      add_location(span1, file10, 70, 5, 2302);
      attr_dev(strong, "class", "conic-value");
      add_location(strong, file10, 71, 5, 2358);
      attr_dev(li, "class", li_class_value = "conic-item " + /*hover*/
      ctx[2]);
      add_location(li, file10, 68, 4, 2154);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span0);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(li, t2);
      append_hydration_dev(li, strong);
      append_hydration_dev(strong, t3);
      append_hydration_dev(strong, t4);
      append_hydration_dev(li, t5);
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keyup",
            /*keyup_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*generatedLegendList*/
      16) {
        set_style(
          span0,
          "background",
          /*color*/
          ctx2[26]
        );
      }
      if (dirty & /*generatedLegendList*/
      16 && t1_value !== (t1_value = /*label*/
      ctx2[27] + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*generatedLegendList*/
      16 && t3_value !== (t3_value = /*value*/
      ctx2[28] + ""))
        set_data_dev(t3, t3_value);
      if (dirty & /*hover*/
      4 && li_class_value !== (li_class_value = "conic-item " + /*hover*/
      ctx2[2])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(66:3) {#each generatedLegendList as { color, label, value }}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let figure;
  let t0;
  let t1;
  let figure_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[9].default && create_if_block_23(ctx)
  );
  let if_block1 = (
    /*cone*/
    ctx[3] && create_if_block_14(ctx)
  );
  let if_block2 = (
    /*legend*/
    ctx[0] && /*generatedLegendList*/
    ctx[4] && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if (if_block0)
        if_block0.l(figure_nodes);
      t0 = claim_space(figure_nodes);
      if (if_block1)
        if_block1.l(figure_nodes);
      t1 = claim_space(figure_nodes);
      if (if_block2)
        if_block2.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "conic-gradient " + /*classesBase*/
      ctx[8]);
      attr_dev(figure, "data-testid", "conic-gradient");
      add_location(figure, file10, 53, 0, 1554);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if (if_block0)
        if_block0.m(figure, null);
      append_hydration_dev(figure, t0);
      if (if_block1)
        if_block1.m(figure, null);
      append_hydration_dev(figure, t1);
      if (if_block2)
        if_block2.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[9].default
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(figure, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*cone*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_14(ctx2);
          if_block1.c();
          if_block1.m(figure, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*legend*/
        ctx2[0] && /*generatedLegendList*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block8(ctx2);
          if_block2.c();
          if_block2.m(figure, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*classesBase*/
      256 && figure_class_value !== (figure_class_value = "conic-gradient " + /*classesBase*/
      ctx2[8])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase6 = "flex flex-col items-center space-y-4 w-";
var cCaption = "text-center";
var cCone = "block aspect-square rounded-full";
var cLegend = "text-sm w-full";
var cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance10($$self, $$props, $$invalidate) {
  let classesBase;
  let classesCaption;
  let classesCone;
  let classesLegend;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConicGradient", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { stops = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = $$props;
  let { legend = false } = $$props;
  let { spin = false } = $$props;
  let { width = "w-24" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { digits = 0 } = $$props;
  let { regionCaption = "" } = $$props;
  let { regionCone = "" } = $$props;
  let { regionLegend = "" } = $$props;
  let cone;
  let generatedLegendList;
  function setColorValue(color) {
    if (typeof color === "string")
      return color;
    const colorSet = tailwindDefaultColors.find((c) => c.label === color[0]);
    return colorSet == null ? void 0 : colorSet.shades[color[1]].hex;
  }
  function genConicGradient() {
    let d = stops.map((v) => `${setColorValue(v.color)} ${v.start}% ${v.end}%`);
    $$invalidate(3, cone = `conic-gradient(${d.join(", ")})`);
  }
  function genLegend() {
    if (!legend)
      return;
    $$invalidate(4, generatedLegendList = stops.map((v) => {
      return {
        label: v.label,
        color: setColorValue(v.color),
        value: (v.end - v.start).toFixed(digits)
      };
    }));
  }
  afterUpdate(() => {
    genConicGradient();
    genLegend();
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("stops" in $$new_props)
      $$invalidate(10, stops = $$new_props.stops);
    if ("legend" in $$new_props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$new_props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("hover" in $$new_props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("digits" in $$new_props)
      $$invalidate(12, digits = $$new_props.digits);
    if ("regionCaption" in $$new_props)
      $$invalidate(13, regionCaption = $$new_props.regionCaption);
    if ("regionCone" in $$new_props)
      $$invalidate(14, regionCone = $$new_props.regionCone);
    if ("regionLegend" in $$new_props)
      $$invalidate(15, regionLegend = $$new_props.regionLegend);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    tailwindDefaultColors,
    stops,
    legend,
    spin,
    width,
    hover,
    digits,
    regionCaption,
    regionCone,
    regionLegend,
    cone,
    generatedLegendList,
    cBase: cBase6,
    cCaption,
    cCone,
    cLegend,
    cSwatch,
    setColorValue,
    genConicGradient,
    genLegend,
    classesLegend,
    classesCone,
    classesCaption,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(25, $$props = assign(assign({}, $$props), $$new_props));
    if ("stops" in $$props)
      $$invalidate(10, stops = $$new_props.stops);
    if ("legend" in $$props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("hover" in $$props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("digits" in $$props)
      $$invalidate(12, digits = $$new_props.digits);
    if ("regionCaption" in $$props)
      $$invalidate(13, regionCaption = $$new_props.regionCaption);
    if ("regionCone" in $$props)
      $$invalidate(14, regionCone = $$new_props.regionCone);
    if ("regionLegend" in $$props)
      $$invalidate(15, regionLegend = $$new_props.regionLegend);
    if ("cone" in $$props)
      $$invalidate(3, cone = $$new_props.cone);
    if ("generatedLegendList" in $$props)
      $$invalidate(4, generatedLegendList = $$new_props.generatedLegendList);
    if ("classesLegend" in $$props)
      $$invalidate(5, classesLegend = $$new_props.classesLegend);
    if ("classesCone" in $$props)
      $$invalidate(6, classesCone = $$new_props.classesCone);
    if ("classesCaption" in $$props)
      $$invalidate(7, classesCaption = $$new_props.classesCaption);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(8, classesBase = `${cBase6} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*regionCaption*/
    8192) {
      $:
        $$invalidate(7, classesCaption = `${cCaption} ${regionCaption}`);
    }
    if ($$self.$$.dirty & /*width, regionCone*/
    18432) {
      $:
        $$invalidate(6, classesCone = `${cCone} ${width} ${regionCone}`);
    }
    if ($$self.$$.dirty & /*regionLegend*/
    32768) {
      $:
        $$invalidate(5, classesLegend = `${cLegend} ${regionLegend}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    legend,
    spin,
    hover,
    cone,
    generatedLegendList,
    classesLegend,
    classesCone,
    classesCaption,
    classesBase,
    $$slots,
    stops,
    width,
    digits,
    regionCaption,
    regionCone,
    regionLegend,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var ConicGradient = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      stops: 10,
      legend: 0,
      spin: 1,
      width: 11,
      hover: 2,
      digits: 12,
      regionCaption: 13,
      regionCone: 14,
      regionLegend: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConicGradient",
      options,
      id: create_fragment10.name
    });
  }
  get stops() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stops(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get digits() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set digits(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCaption() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCaption(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCone() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCone(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLegend() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLegend(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConicGradient_default = ConicGradient;

// node_modules/@skeletonlabs/skeleton/dist/components/FileButton/FileButton.svelte
var file11 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\FileButton\\FileButton.svelte";
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Select a File");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Select a File");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(35:8) Select a File",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div1;
  let div0;
  let input;
  let t;
  let button_1;
  let button_1_class_value;
  let button_1_disabled_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "file" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    /*prunedRestProps*/
    ctx[6]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block3(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t = space();
      button_1 = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true });
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      button_1 = claim_element(div1_nodes, "BUTTON", { type: true, class: true });
      var button_1_nodes = children(button_1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file11, 22, 2, 583);
      attr_dev(div0, "class", "w-0 h-0 overflow-hidden");
      add_location(div0, file11, 21, 1, 543);
      attr_dev(button_1, "type", "button");
      attr_dev(button_1, "class", button_1_class_value = "file-button-btn " + /*classesButton*/
      ctx[3]);
      button_1.disabled = button_1_disabled_value = /*$$restProps*/
      ctx[7].disabled;
      add_location(button_1, file11, 25, 1, 708);
      attr_dev(div1, "class", div1_class_value = "file-button " + /*classesBase*/
      ctx[4]);
      attr_dev(div1, "data-testid", "file-button");
      add_location(div1, file11, 19, 0, 400);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[16](input);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, button_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[17]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "click",
            /*onButtonClick*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keydown",
            /*keydown_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keyup",
            /*keyup_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keypress",
            /*keypress_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        (!current || dirty & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        /*prunedRestProps*/
        ctx2[6]()
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesButton*/
      8 && button_1_class_value !== (button_1_class_value = "file-button-btn " + /*classesButton*/
      ctx2[3])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (!current || dirty & /*$$restProps*/
      128 && button_1_disabled_value !== (button_1_disabled_value = /*$$restProps*/
      ctx2[7].disabled)) {
        prop_dev(button_1, "disabled", button_1_disabled_value);
      }
      if (!current || dirty & /*classesBase*/
      16 && div1_class_value !== (div1_class_value = "file-button " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      ctx[16](null);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cButton = "btn";
function instance11($$self, $$props, $$invalidate) {
  let classesBase;
  let classesButton;
  const omit_props_names = ["files", "name", "width", "button"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileButton", slots, ["default"]);
  let { files = void 0 } = $$props;
  let { name } = $$props;
  let { width = "" } = $$props;
  let { button = "variant-filled" } = $$props;
  let elemFileInput;
  function onButtonClick() {
    elemFileInput.click();
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<FileButton> was created without expected prop 'name'");
    }
  });
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemFileInput = $$value;
      $$invalidate(2, elemFileInput);
    });
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("width" in $$new_props)
      $$invalidate(8, width = $$new_props.width);
    if ("button" in $$new_props)
      $$invalidate(9, button = $$new_props.button);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    files,
    name,
    width,
    button,
    cButton,
    elemFileInput,
    onButtonClick,
    prunedRestProps,
    classesButton,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("width" in $$props)
      $$invalidate(8, width = $$new_props.width);
    if ("button" in $$props)
      $$invalidate(9, button = $$new_props.button);
    if ("elemFileInput" in $$props)
      $$invalidate(2, elemFileInput = $$new_props.elemFileInput);
    if ("classesButton" in $$props)
      $$invalidate(3, classesButton = $$new_props.classesButton);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*button, width*/
    768) {
      $:
        $$invalidate(3, classesButton = `${cButton} ${button} ${width}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    files,
    name,
    elemFileInput,
    classesButton,
    classesBase,
    onButtonClick,
    prunedRestProps,
    $$restProps,
    width,
    button,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    change_handler,
    input_binding,
    input_change_handler
  ];
}
var FileButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { files: 0, name: 1, width: 8, button: 9 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileButton",
      options,
      id: create_fragment11.name
    });
  }
  get files() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileButton_default = FileButton;

// node_modules/@skeletonlabs/skeleton/dist/components/FileDropzone/FileDropzone.svelte
var file12 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\FileDropzone\\FileDropzone.svelte";
var get_meta_slot_changes = (dirty) => ({});
var get_meta_slot_context = (ctx) => ({});
var get_message_slot_changes = (dirty) => ({});
var get_message_slot_context = (ctx) => ({});
var get_lead_slot_changes6 = (dirty) => ({});
var get_lead_slot_context6 = (ctx) => ({});
function create_if_block_15(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[17].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_lead_slot_context6
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "dropzone-lead " + /*slotLead*/
      ctx[4]);
      add_location(div, file12, 48, 21, 1459);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_lead_slot_changes6
            ),
            get_lead_slot_context6
          );
        }
      }
      if (!current || dirty & /*slotLead*/
      16 && div_class_value !== (div_class_value = "dropzone-lead " + /*slotLead*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(49:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let strong;
  let t0;
  let t1;
  const block = {
    c: function create() {
      strong = element("strong");
      t0 = text("Upload a file");
      t1 = text(" or drag and drop");
      this.h();
    },
    l: function claim(nodes) {
      strong = claim_element(nodes, "STRONG", {});
      var strong_nodes = children(strong);
      t0 = claim_text(strong_nodes, "Upload a file");
      strong_nodes.forEach(detach_dev);
      t1 = claim_text(nodes, " or drag and drop");
      this.h();
    },
    h: function hydrate() {
      add_location(strong, file12, 51, 25, 1622);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, strong, anchor);
      append_hydration_dev(strong, t0);
      insert_hydration_dev(target, t1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(strong);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(52:25) <strong>",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let small;
  let small_class_value;
  let current;
  const meta_slot_template = (
    /*#slots*/
    ctx[17].meta
  );
  const meta_slot = create_slot(
    meta_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_meta_slot_context
  );
  const block = {
    c: function create() {
      small = element("small");
      if (meta_slot)
        meta_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      small = claim_element(nodes, "SMALL", { class: true });
      var small_nodes = children(small);
      if (meta_slot)
        meta_slot.l(small_nodes);
      small_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(small, "class", small_class_value = "dropzone-meta " + /*slotMeta*/
      ctx[6]);
      add_location(small, file12, 54, 21, 1730);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, small, anchor);
      if (meta_slot) {
        meta_slot.m(small, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (meta_slot) {
        if (meta_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            meta_slot,
            meta_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              meta_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_meta_slot_changes
            ),
            get_meta_slot_context
          );
        }
      }
      if (!current || dirty & /*slotMeta*/
      64 && small_class_value !== (small_class_value = "dropzone-meta " + /*slotMeta*/
      ctx2[6])) {
        attr_dev(small, "class", small_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meta_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meta_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(small);
      if (meta_slot)
        meta_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(55:3) {#if $$slots.meta}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div3;
  let input;
  let input_class_value;
  let t0;
  let div2;
  let div1;
  let t1;
  let div0;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let div2_class_value;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "file" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    {
      class: input_class_value = "dropzone-input " + /*classesInput*/
      ctx[8]
    },
    /*prunedRestProps*/
    ctx[10]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block0 = (
    /*$$slots*/
    ctx[12].lead && create_if_block_15(ctx)
  );
  const message_slot_template = (
    /*#slots*/
    ctx[17].message
  );
  const message_slot = create_slot(
    message_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_message_slot_context
  );
  const message_slot_or_fallback = message_slot || fallback_block4(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[12].meta && create_if_block9(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      div0 = element("div");
      if (message_slot_or_fallback)
        message_slot_or_fallback.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div3_nodes = children(div3);
      input = claim_element(div3_nodes, "INPUT", { type: true, name: true, class: true });
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (message_slot_or_fallback)
        message_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file12, 28, 1, 1041);
      attr_dev(div0, "class", div0_class_value = "dropzone-message " + /*slotMessage*/
      ctx[5]);
      add_location(div0, file12, 50, 3, 1552);
      attr_dev(div1, "class", div1_class_value = "dropzone-interface-text " + /*regionInterfaceText*/
      ctx[3]);
      add_location(div1, file12, 46, 2, 1361);
      attr_dev(div2, "class", div2_class_value = "dropzone-interface " + /*classesInterface*/
      ctx[7] + " " + /*regionInterface*/
      ctx[2]);
      add_location(div2, file12, 45, 1, 1289);
      attr_dev(div3, "class", div3_class_value = "dropzone " + /*classesBase*/
      ctx[9]);
      attr_dev(div3, "data-testid", "file-dropzone");
      toggle_class(
        div3,
        "opacity-50",
        /*$$restProps*/
        ctx[11].disabled
      );
      add_location(div3, file12, 25, 0, 846);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, input);
      if (input.autofocus)
        input.focus();
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (message_slot_or_fallback) {
        message_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[27]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "dragenter",
            /*dragenter_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "dragover",
            /*dragover_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "dragleave",
            /*dragleave_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "drop",
            /*drop_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        (!current || dirty & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty & /*classesInput*/
        256 && input_class_value !== (input_class_value = "dropzone-input " + /*classesInput*/
        ctx2[8])) && { class: input_class_value },
        /*prunedRestProps*/
        ctx2[10]()
      ]));
      if (
        /*$$slots*/
        ctx2[12].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (message_slot) {
        if (message_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            message_slot,
            message_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              message_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_message_slot_changes
            ),
            get_message_slot_context
          );
        }
      }
      if (!current || dirty & /*slotMessage*/
      32 && div0_class_value !== (div0_class_value = "dropzone-message " + /*slotMessage*/
      ctx2[5])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[12].meta
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*regionInterfaceText*/
      8 && div1_class_value !== (div1_class_value = "dropzone-interface-text " + /*regionInterfaceText*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*classesInterface, regionInterface*/
      132 && div2_class_value !== (div2_class_value = "dropzone-interface " + /*classesInterface*/
      ctx2[7] + " " + /*regionInterface*/
      ctx2[2])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*classesBase*/
      512 && div3_class_value !== (div3_class_value = "dropzone " + /*classesBase*/
      ctx2[9])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty & /*classesBase, $$restProps*/
      2560) {
        toggle_class(
          div3,
          "opacity-50",
          /*$$restProps*/
          ctx2[11].disabled
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(message_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(message_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block0)
        if_block0.d();
      if (message_slot_or_fallback)
        message_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase7 = "textarea relative flex justify-center items-center";
var cInput = "w-full absolute top-0 left-0 right-0 bottom-0 z-[1] opacity-0 disabled:!opacity-0 cursor-pointer";
var cInterface2 = "flex justify-center items-center text-center";
function instance12($$self, $$props, $$invalidate) {
  let classesBase;
  let classesInput;
  let classesInterface;
  const omit_props_names = [
    "files",
    "name",
    "border",
    "padding",
    "rounded",
    "regionInterface",
    "regionInterfaceText",
    "slotLead",
    "slotMessage",
    "slotMeta"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileDropzone", slots, ["lead", "message", "meta"]);
  const $$slots = compute_slots(slots);
  let { files = void 0 } = $$props;
  let { name } = $$props;
  let { border = "border-2 border-dashed" } = $$props;
  let { padding = "p-4 py-8" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { regionInterface = "" } = $$props;
  let { regionInterfaceText = "" } = $$props;
  let { slotLead = "mb-4" } = $$props;
  let { slotMessage = "" } = $$props;
  let { slotMeta = "opacity-75" } = $$props;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<FileDropzone> was created without expected prop 'name'");
    }
  });
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function drop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("border" in $$new_props)
      $$invalidate(13, border = $$new_props.border);
    if ("padding" in $$new_props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("regionInterface" in $$new_props)
      $$invalidate(2, regionInterface = $$new_props.regionInterface);
    if ("regionInterfaceText" in $$new_props)
      $$invalidate(3, regionInterfaceText = $$new_props.regionInterfaceText);
    if ("slotLead" in $$new_props)
      $$invalidate(4, slotLead = $$new_props.slotLead);
    if ("slotMessage" in $$new_props)
      $$invalidate(5, slotMessage = $$new_props.slotMessage);
    if ("slotMeta" in $$new_props)
      $$invalidate(6, slotMeta = $$new_props.slotMeta);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    files,
    name,
    border,
    padding,
    rounded,
    regionInterface,
    regionInterfaceText,
    slotLead,
    slotMessage,
    slotMeta,
    cBase: cBase7,
    cInput,
    cInterface: cInterface2,
    prunedRestProps,
    classesInterface,
    classesInput,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("border" in $$props)
      $$invalidate(13, border = $$new_props.border);
    if ("padding" in $$props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("regionInterface" in $$props)
      $$invalidate(2, regionInterface = $$new_props.regionInterface);
    if ("regionInterfaceText" in $$props)
      $$invalidate(3, regionInterfaceText = $$new_props.regionInterfaceText);
    if ("slotLead" in $$props)
      $$invalidate(4, slotLead = $$new_props.slotLead);
    if ("slotMessage" in $$props)
      $$invalidate(5, slotMessage = $$new_props.slotMessage);
    if ("slotMeta" in $$props)
      $$invalidate(6, slotMeta = $$new_props.slotMeta);
    if ("classesInterface" in $$props)
      $$invalidate(7, classesInterface = $$new_props.classesInterface);
    if ("classesInput" in $$props)
      $$invalidate(8, classesInput = $$new_props.classesInput);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${cBase7} ${border} ${padding} ${rounded} ${$$props.class ?? ""}`);
  };
  $:
    $$invalidate(8, classesInput = `${cInput}`);
  $:
    $$invalidate(7, classesInterface = `${cInterface2}`);
  $$props = exclude_internal_props($$props);
  return [
    files,
    name,
    regionInterface,
    regionInterfaceText,
    slotLead,
    slotMessage,
    slotMeta,
    classesInterface,
    classesInput,
    classesBase,
    prunedRestProps,
    $$restProps,
    $$slots,
    border,
    padding,
    rounded,
    $$scope,
    slots,
    change_handler,
    dragenter_handler,
    dragover_handler,
    dragleave_handler,
    drop_handler,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    input_change_handler
  ];
}
var FileDropzone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      files: 0,
      name: 1,
      border: 13,
      padding: 14,
      rounded: 15,
      regionInterface: 2,
      regionInterfaceText: 3,
      slotLead: 4,
      slotMessage: 5,
      slotMeta: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileDropzone",
      options,
      id: create_fragment12.name
    });
  }
  get files() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionInterface() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionInterface(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionInterfaceText() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionInterfaceText(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotMessage() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotMessage(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotMeta() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotMeta(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileDropzone_default = FileDropzone;

// node_modules/@skeletonlabs/skeleton/dist/components/InputChip/InputChip.svelte
var file13 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\InputChip\\InputChip.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i].id;
  child_ctx[44] = list[i].val;
  child_ctx[46] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let t_value = (
    /*option*/
    ctx[47] + ""
  );
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*option*/
      ctx[47];
      option.value = option.__value;
      add_location(option, file13, 109, 26, 3333);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1 && t_value !== (t_value = /*option*/
      ctx2[47] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*value*/
      1 && option_value_value !== (option_value_value = /*option*/
      ctx2[47])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(110:3) {#each value as option}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let div_transition;
  let current;
  let each_value = (
    /*chipValues*/
    ctx[6]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*id*/
    ctx2[43]
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "input-chip-list " + /*classesChipList*/
      ctx[9]);
      add_location(div, file13, 130, 3, 3859);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*chips, duration, removeChip, chipValues*/
      16488) {
        each_value = /*chipValues*/
        ctx[6];
        validate_each_argument(each_value);
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block3, null, get_each_context3);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty[0] & /*classesChipList*/
      512 && div_class_value !== (div_class_value = "input-chip-list " + /*classesChipList*/
      ctx[9])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              fly,
              {
                duration: (
                  /*duration*/
                  ctx[3]
                ),
                opacity: 0,
                y: -20
              },
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fly,
            {
              duration: (
                /*duration*/
                ctx[3]
              ),
              opacity: 0,
              y: -20
            },
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(130:2) {#if chipValues.length}",
    ctx
  });
  return block;
}
function create_each_block3(key_1, ctx) {
  let div;
  let button;
  let span0;
  let t0_value = (
    /*val*/
    ctx[44] + ""
  );
  let t0;
  let t1;
  let span1;
  let t2;
  let button_class_value;
  let button_transition;
  let t3;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[38](
        /*i*/
        ctx[46],
        /*val*/
        ctx[44],
        ...args
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("✕");
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, "✕");
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span0, file13, 146, 7, 4374);
      add_location(span1, file13, 147, 7, 4400);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "chip " + /*chips*/
      ctx[5]);
      add_location(button, file13, 134, 6, 4109);
      add_location(div, file13, 133, 5, 4069);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      append_hydration_dev(span1, t2);
      append_hydration_dev(div, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler_1, false, false, false, false),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keyup",
            /*keyup_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*chipValues*/
      64) && t0_value !== (t0_value = /*val*/
      ctx[44] + ""))
        set_data_dev(t0, t0_value);
      if (!current || dirty[0] & /*chips*/
      32 && button_class_value !== (button_class_value = "chip " + /*chips*/
      ctx[5])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    r: function measure() {
      rect = div.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div);
      stop_animation();
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, { duration: (
        /*duration*/
        ctx[3]
      ) });
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!button_transition)
            button_transition = create_bidirectional_transition(
              button,
              scale,
              {
                duration: (
                  /*duration*/
                  ctx[3]
                ),
                opacity: 0
              },
              true
            );
          button_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!button_transition)
          button_transition = create_bidirectional_transition(
            button,
            scale,
            {
              duration: (
                /*duration*/
                ctx[3]
              ),
              opacity: 0
            },
            false
          );
        button_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching && button_transition)
        button_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(132:4) {#each chipValues as { id, val }",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div2;
  let div0;
  let select;
  let t0;
  let div1;
  let form;
  let input_1;
  let input_1_placeholder_value;
  let input_1_class_value;
  let input_1_disabled_value;
  let t1;
  let div1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = (
    /*value*/
    ctx[0]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let if_block = (
    /*chipValues*/
    ctx[6].length && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      form = element("form");
      input_1 = element("input");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", { name: true, tabindex: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      form = claim_element(div1_nodes, "FORM", {});
      var form_nodes = children(form);
      input_1 = claim_element(form_nodes, "INPUT", {
        type: true,
        placeholder: true,
        class: true
      });
      form_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[2]
      );
      select.multiple = true;
      select.required = /*required*/
      ctx[4];
      attr_dev(select, "tabindex", "-1");
      if (
        /*value*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[36].call(select)
        ));
      add_location(select, file13, 107, 2, 3180);
      attr_dev(div0, "class", "h-0 overflow-hidden");
      add_location(div0, file13, 106, 1, 3144);
      attr_dev(input_1, "type", "text");
      attr_dev(input_1, "placeholder", input_1_placeholder_value = /*$$restProps*/
      ctx[15].placeholder ?? "Enter values...");
      attr_dev(input_1, "class", input_1_class_value = "input-chip-field " + /*classesInputField*/
      ctx[8]);
      input_1.disabled = input_1_disabled_value = /*$$restProps*/
      ctx[15].disabled;
      add_location(input_1, file13, 116, 3, 3531);
      add_location(form, file13, 115, 2, 3501);
      attr_dev(div1, "class", div1_class_value = "input-chip-interface " + /*classesInterface*/
      ctx[10]);
      add_location(div1, file13, 113, 1, 3422);
      attr_dev(div2, "class", div2_class_value = "input-chip " + /*classesBase*/
      ctx[11]);
      toggle_class(
        div2,
        "opacity-50",
        /*$$restProps*/
        ctx[15].disabled
      );
      add_location(div2, file13, 104, 0, 2988);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      ctx[35](select);
      select_options(
        select,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, form);
      append_hydration_dev(form, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[1]
      );
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[36]
          ),
          listen_dev(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[37]
          ),
          listen_dev(
            input_1,
            "input",
            /*onInputHandler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "input",
            /*input_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "focus",
            /*focus_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "blur",
            /*blur_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "submit",
            /*addChip*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1) {
        each_value_1 = /*value*/
        ctx2[0];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*required*/
      16) {
        prop_dev(
          select,
          "required",
          /*required*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*value*/
      1) {
        select_options(
          select,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*$$restProps*/
      32768 && input_1_placeholder_value !== (input_1_placeholder_value = /*$$restProps*/
      ctx2[15].placeholder ?? "Enter values...")) {
        attr_dev(input_1, "placeholder", input_1_placeholder_value);
      }
      if (!current || dirty[0] & /*classesInputField*/
      256 && input_1_class_value !== (input_1_class_value = "input-chip-field " + /*classesInputField*/
      ctx2[8])) {
        attr_dev(input_1, "class", input_1_class_value);
      }
      if (!current || dirty[0] & /*$$restProps*/
      32768 && input_1_disabled_value !== (input_1_disabled_value = /*$$restProps*/
      ctx2[15].disabled)) {
        prop_dev(input_1, "disabled", input_1_disabled_value);
      }
      if (dirty[0] & /*input*/
      2 && input_1.value !== /*input*/
      ctx2[1]) {
        set_input_value(
          input_1,
          /*input*/
          ctx2[1]
        );
      }
      if (
        /*chipValues*/
        ctx2[6].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*chipValues*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesInterface*/
      1024 && div1_class_value !== (div1_class_value = "input-chip-interface " + /*classesInterface*/
      ctx2[10])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      2048 && div2_class_value !== (div2_class_value = "input-chip " + /*classesBase*/
      ctx2[11])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesBase, $$restProps*/
      34816) {
        toggle_class(
          div2,
          "opacity-50",
          /*$$restProps*/
          ctx2[15].disabled
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_each(each_blocks, detaching);
      ctx[35](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase8 = "textarea cursor-pointer";
var cInterface3 = "space-y-4";
var cChipList = "flex flex-wrap gap-2";
var cInputField = "unstyled bg-transparent border-0 !ring-0 p-0 w-full";
function instance13($$self, $$props, $$invalidate) {
  let classesInvalid;
  let classesBase;
  let classesInterface;
  let classesChipList;
  let classesInputField;
  const omit_props_names = [
    "input",
    "name",
    "value",
    "whitelist",
    "max",
    "minlength",
    "maxlength",
    "allowUpperCase",
    "allowDuplicates",
    "validation",
    "duration",
    "required",
    "chips",
    "invalid",
    "padding",
    "rounded"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputChip", slots, []);
  const dispatch = createEventDispatcher();
  let { input = "" } = $$props;
  let { name } = $$props;
  let { value = [] } = $$props;
  let { whitelist = [] } = $$props;
  let { max = -1 } = $$props;
  let { minlength = -1 } = $$props;
  let { maxlength = -1 } = $$props;
  let { allowUpperCase = false } = $$props;
  let { allowDuplicates = false } = $$props;
  let { validation = () => true } = $$props;
  let { duration = 150 } = $$props;
  let { required = false } = $$props;
  let { chips = "variant-filled" } = $$props;
  let { invalid = "input-error" } = $$props;
  let { padding = "p-2" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let inputValid = true;
  let chipValues = (value == null ? void 0 : value.map((val) => {
    return { val, id: Math.random() };
  })) || [];
  function resetFormHandler() {
    $$invalidate(0, value = []);
  }
  let selectElement;
  onMount(() => {
    if (!selectElement.form)
      return;
    const externalForm = selectElement.form;
    externalForm.addEventListener("reset", resetFormHandler);
    return () => {
      externalForm.removeEventListener("reset", resetFormHandler);
    };
  });
  function onInputHandler() {
    $$invalidate(26, inputValid = true);
  }
  function validate() {
    if (!input)
      return false;
    $$invalidate(1, input = input.trim());
    if (validation !== void 0 && !validation(input))
      return false;
    if (max !== -1 && value.length >= max)
      return false;
    if (minlength !== -1 && input.length < minlength)
      return false;
    if (maxlength !== -1 && input.length > maxlength)
      return false;
    if (whitelist.length > 0 && !whitelist.includes(input))
      return false;
    if (allowDuplicates === false && value.includes(input))
      return false;
    return true;
  }
  function addChip(event) {
    event.preventDefault();
    $$invalidate(26, inputValid = validate());
    if (inputValid === false) {
      dispatch("invalid", { event, input });
      return;
    }
    $$invalidate(1, input = allowUpperCase ? input : input.toLowerCase());
    value.push(input);
    $$invalidate(0, value);
    chipValues.push({ val: input, id: Math.random() });
    $$invalidate(6, chipValues), $$invalidate(0, value);
    dispatch("add", {
      event,
      chipIndex: value.length - 1,
      chipValue: input
    });
    $$invalidate(1, input = "");
  }
  function removeChip(event, chipIndex, chipValue) {
    if ($$restProps.disabled)
      return;
    value.splice(chipIndex, 1);
    $$invalidate(0, value);
    chipValues.splice(chipIndex, 1);
    $$invalidate(6, chipValues), $$invalidate(0, value);
    dispatch("remove", { event, chipIndex, chipValue });
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<InputChip> was created without expected prop 'name'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      selectElement = $$value;
      $$invalidate(7, selectElement);
    });
  }
  function select_change_handler() {
    value = select_multiple_value(this);
    $$invalidate(0, value);
  }
  function input_1_input_handler() {
    input = this.value;
    $$invalidate(1, input);
  }
  const click_handler_1 = (i, val, e) => {
    removeChip(e, i, val);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(42, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("input" in $$new_props)
      $$invalidate(1, input = $$new_props.input);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("whitelist" in $$new_props)
      $$invalidate(16, whitelist = $$new_props.whitelist);
    if ("max" in $$new_props)
      $$invalidate(17, max = $$new_props.max);
    if ("minlength" in $$new_props)
      $$invalidate(18, minlength = $$new_props.minlength);
    if ("maxlength" in $$new_props)
      $$invalidate(19, maxlength = $$new_props.maxlength);
    if ("allowUpperCase" in $$new_props)
      $$invalidate(20, allowUpperCase = $$new_props.allowUpperCase);
    if ("allowDuplicates" in $$new_props)
      $$invalidate(21, allowDuplicates = $$new_props.allowDuplicates);
    if ("validation" in $$new_props)
      $$invalidate(22, validation = $$new_props.validation);
    if ("duration" in $$new_props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("required" in $$new_props)
      $$invalidate(4, required = $$new_props.required);
    if ("chips" in $$new_props)
      $$invalidate(5, chips = $$new_props.chips);
    if ("invalid" in $$new_props)
      $$invalidate(23, invalid = $$new_props.invalid);
    if ("padding" in $$new_props)
      $$invalidate(24, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(25, rounded = $$new_props.rounded);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    fly,
    scale,
    flip,
    dispatch,
    input,
    name,
    value,
    whitelist,
    max,
    minlength,
    maxlength,
    allowUpperCase,
    allowDuplicates,
    validation,
    duration,
    required,
    chips,
    invalid,
    padding,
    rounded,
    cBase: cBase8,
    cInterface: cInterface3,
    cChipList,
    cInputField,
    inputValid,
    chipValues,
    resetFormHandler,
    selectElement,
    onInputHandler,
    validate,
    addChip,
    removeChip,
    classesInputField,
    classesChipList,
    classesInterface,
    classesInvalid,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(42, $$props = assign(assign({}, $$props), $$new_props));
    if ("input" in $$props)
      $$invalidate(1, input = $$new_props.input);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("whitelist" in $$props)
      $$invalidate(16, whitelist = $$new_props.whitelist);
    if ("max" in $$props)
      $$invalidate(17, max = $$new_props.max);
    if ("minlength" in $$props)
      $$invalidate(18, minlength = $$new_props.minlength);
    if ("maxlength" in $$props)
      $$invalidate(19, maxlength = $$new_props.maxlength);
    if ("allowUpperCase" in $$props)
      $$invalidate(20, allowUpperCase = $$new_props.allowUpperCase);
    if ("allowDuplicates" in $$props)
      $$invalidate(21, allowDuplicates = $$new_props.allowDuplicates);
    if ("validation" in $$props)
      $$invalidate(22, validation = $$new_props.validation);
    if ("duration" in $$props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("required" in $$props)
      $$invalidate(4, required = $$new_props.required);
    if ("chips" in $$props)
      $$invalidate(5, chips = $$new_props.chips);
    if ("invalid" in $$props)
      $$invalidate(23, invalid = $$new_props.invalid);
    if ("padding" in $$props)
      $$invalidate(24, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(25, rounded = $$new_props.rounded);
    if ("inputValid" in $$props)
      $$invalidate(26, inputValid = $$new_props.inputValid);
    if ("chipValues" in $$props)
      $$invalidate(6, chipValues = $$new_props.chipValues);
    if ("selectElement" in $$props)
      $$invalidate(7, selectElement = $$new_props.selectElement);
    if ("classesInputField" in $$props)
      $$invalidate(8, classesInputField = $$new_props.classesInputField);
    if ("classesChipList" in $$props)
      $$invalidate(9, classesChipList = $$new_props.classesChipList);
    if ("classesInterface" in $$props)
      $$invalidate(10, classesInterface = $$new_props.classesInterface);
    if ("classesInvalid" in $$props)
      $$invalidate(27, classesInvalid = $$new_props.classesInvalid);
    if ("classesBase" in $$props)
      $$invalidate(11, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*inputValid, invalid*/
    75497472) {
      $:
        $$invalidate(27, classesInvalid = inputValid === false ? invalid : "");
    }
    $:
      $$invalidate(11, classesBase = `${cBase8} ${padding} ${rounded} ${$$props.class ?? ""} ${classesInvalid}`);
    if ($$self.$$.dirty[0] & /*value, chipValues*/
    65) {
      $:
        $$invalidate(6, chipValues = (value == null ? void 0 : value.map((val, i) => {
          var _a;
          if (((_a = chipValues[i]) == null ? void 0 : _a.val) === val)
            return chipValues[i];
          return { id: Math.random(), val };
        })) || []);
    }
  };
  $:
    $$invalidate(10, classesInterface = `${cInterface3}`);
  $:
    $$invalidate(9, classesChipList = `${cChipList}`);
  $:
    $$invalidate(8, classesInputField = `${cInputField}`);
  $$props = exclude_internal_props($$props);
  return [
    value,
    input,
    name,
    duration,
    required,
    chips,
    chipValues,
    selectElement,
    classesInputField,
    classesChipList,
    classesInterface,
    classesBase,
    onInputHandler,
    addChip,
    removeChip,
    $$restProps,
    whitelist,
    max,
    minlength,
    maxlength,
    allowUpperCase,
    allowDuplicates,
    validation,
    invalid,
    padding,
    rounded,
    inputValid,
    classesInvalid,
    click_handler,
    keypress_handler,
    keydown_handler,
    keyup_handler,
    input_handler,
    focus_handler,
    blur_handler,
    select_binding,
    select_change_handler,
    input_1_input_handler,
    click_handler_1
  ];
}
var InputChip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        input: 1,
        name: 2,
        value: 0,
        whitelist: 16,
        max: 17,
        minlength: 18,
        maxlength: 19,
        allowUpperCase: 20,
        allowDuplicates: 21,
        validation: 22,
        duration: 3,
        required: 4,
        chips: 5,
        invalid: 23,
        padding: 24,
        rounded: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputChip",
      options,
      id: create_fragment13.name
    });
  }
  get input() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get whitelist() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set whitelist(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minlength() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minlength(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowUpperCase() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowUpperCase(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowDuplicates() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowDuplicates(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validation() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validation(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chips() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chips(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputChip_default = InputChip;

// node_modules/@skeletonlabs/skeleton/dist/components/ListBox/ListBox.svelte
var file14 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\ListBox\\ListBox.svelte";
function create_fragment14(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-labelledby": true,
        "data-testid": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "listbox " + /*classesBase*/
      ctx[1]);
      attr_dev(div, "role", "listbox");
      attr_dev(
        div,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      attr_dev(div, "data-testid", "listbox");
      add_location(div, file14, 18, 0, 548);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      2 && div_class_value !== (div_class_value = "listbox " + /*classesBase*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div,
          "aria-labelledby",
          /*labelledby*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase9 = "";
function instance14($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBox", slots, ["default"]);
  let { multiple = false } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { active = "variant-filled" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { labelledby = "" } = $$props;
  setContext("multiple", multiple);
  setContext("rounded", rounded);
  setContext("active", active);
  setContext("hover", hover);
  setContext("padding", padding);
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("multiple" in $$new_props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("spacing" in $$new_props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(4, rounded = $$new_props.rounded);
    if ("active" in $$new_props)
      $$invalidate(5, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    multiple,
    spacing,
    rounded,
    active,
    hover,
    padding,
    labelledby,
    cBase: cBase9,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("multiple" in $$props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("spacing" in $$props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(4, rounded = $$new_props.rounded);
    if ("active" in $$props)
      $$invalidate(5, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${cBase9} ${spacing} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    classesBase,
    multiple,
    spacing,
    rounded,
    active,
    hover,
    padding,
    $$scope,
    slots
  ];
}
var ListBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      multiple: 2,
      spacing: 3,
      rounded: 4,
      active: 5,
      hover: 6,
      padding: 7,
      labelledby: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBox",
      options,
      id: create_fragment14.name
    });
  }
  get multiple() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBox_default = ListBox;

// node_modules/@skeletonlabs/skeleton/dist/components/ListBox/ListBoxItem.svelte
var file15 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\ListBox\\ListBoxItem.svelte";
var get_trail_slot_changes3 = (dirty) => ({});
var get_trail_slot_context3 = (ctx) => ({});
var get_lead_slot_changes7 = (dirty) => ({});
var get_lead_slot_context7 = (ctx) => ({});
function create_else_block3(ctx) {
  let input;
  let value_has_changed = false;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[29][0]
  );
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true, tabindex: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.__value = /*value*/
      ctx[2];
      input.value = input.__value;
      attr_dev(input, "tabindex", "-1");
      add_location(input, file15, 87, 4, 2295);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[27](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[28]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_1*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*value*/
      4) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[2]
        );
        input.value = input.__value;
        value_has_changed = true;
      }
      if (value_has_changed || dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[27](null);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(87:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true, tabindex: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.__value = /*value*/
      ctx[2];
      input.value = input.__value;
      attr_dev(input, "tabindex", "-1");
      add_location(input, file15, 85, 4, 2171);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[25](input);
      input.checked = /*checked*/
      ctx[4];
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[26]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*value*/
      4) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[2]
        );
        input.value = input.__value;
      }
      if (dirty[0] & /*checked*/
      16) {
        input.checked = /*checked*/
        ctx2[4];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(85:3) {#if multiple}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[17].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_lead_slot_context7
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listbox-label-lead");
      add_location(div, file15, 93, 21, 2526);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        65536)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_lead_slot_changes7
            ),
            get_lead_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(94:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let div;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[17].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_trail_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listbox-label-trail");
      add_location(div, file15, 97, 22, 2722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty[0] & /*$$scope*/
        65536)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_trail_slot_changes3
            ),
            get_trail_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(98:3) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let label;
  let div3;
  let div0;
  let t0;
  let div2;
  let t1;
  let div1;
  let t2;
  let div2_class_value;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[3]
    )
      return create_if_block_24;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[10].lead && create_if_block_16(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block2 = (
    /*$$slots*/
    ctx[10].trail && create_if_block11(ctx)
  );
  const block = {
    c: function create() {
      label = element("label");
      div3 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {});
      var label_nodes = children(label);
      div3 = claim_element(label_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-selected": true,
        tabindex: true
      });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block1)
        if_block1.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file15, 83, 2, 2111);
      attr_dev(div1, "class", "listbox-label-content flex-1");
      add_location(div1, file15, 95, 3, 2619);
      attr_dev(div2, "class", div2_class_value = "listbox-label " + /*classesLabel*/
      ctx[7]);
      add_location(div2, file15, 91, 2, 2439);
      attr_dev(div3, "class", div3_class_value = "listbox-item " + /*classesBase*/
      ctx[8]);
      attr_dev(div3, "data-testid", "listbox-item");
      attr_dev(div3, "role", "option");
      attr_dev(
        div3,
        "aria-selected",
        /*selected*/
        ctx[5]
      );
      attr_dev(div3, "tabindex", "0");
      add_location(div3, file15, 71, 1, 1837);
      add_location(label, file15, 69, 0, 1775);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, div3);
      append_hydration_dev(div3, div0);
      if_block0.m(div0, null);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div3,
            "keydown",
            /*onKeyDown*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keyup",
            /*keyup_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keypress",
            /*keypress_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (
        /*$$slots*/
        ctx2[10].lead
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[10].trail
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block11(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesLabel*/
      128 && div2_class_value !== (div2_class_value = "listbox-label " + /*classesLabel*/
      ctx2[7])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      256 && div3_class_value !== (div3_class_value = "listbox-item " + /*classesBase*/
      ctx2[8])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*selected*/
      32) {
        attr_dev(
          div3,
          "aria-selected",
          /*selected*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase10 = "cursor-pointer -outline-offset-[3px]";
var cLabel3 = "flex items-center space-x-4";
function areDeeplyEqual(param1, param2) {
  if (param1 === param2)
    return true;
  if (!(param1 instanceof Object) || !(param2 instanceof Object))
    return false;
  const keys1 = Object.keys(param1);
  const keys2 = Object.keys(param2);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    const value1 = param1[key];
    const value2 = param2[key];
    if (!areDeeplyEqual(value1, value2))
      return false;
  }
  return true;
}
function instance15($$self, $$props, $$invalidate) {
  let selected;
  let classesActive;
  let classesBase;
  let classesLabel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxItem", slots, ["lead", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { multiple = getContext("multiple") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let checked;
  let elemInput;
  function updateCheckbox(group2) {
    $$invalidate(4, checked = group2.indexOf(value) >= 0);
  }
  function updateGroup(checked2) {
    const index = group.indexOf(value);
    if (checked2) {
      if (index < 0) {
        group.push(value);
        $$invalidate(0, group);
      }
    } else {
      if (index >= 0) {
        group.splice(index, 1);
        $$invalidate(0, group);
      }
    }
  }
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemInput.click();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<ListBoxItem> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<ListBoxItem> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ListBoxItem> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(4, checked);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler_1() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("multiple" in $$new_props)
      $$invalidate(3, multiple = $$new_props.multiple);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("active" in $$new_props)
      $$invalidate(12, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("padding" in $$new_props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    multiple,
    rounded,
    active,
    hover,
    padding,
    cBase: cBase10,
    cLabel: cLabel3,
    checked,
    elemInput,
    areDeeplyEqual,
    updateCheckbox,
    updateGroup,
    onKeyDown: onKeyDown2,
    classesLabel,
    classesActive,
    classesBase,
    selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("multiple" in $$props)
      $$invalidate(3, multiple = $$new_props.multiple);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("active" in $$props)
      $$invalidate(12, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("padding" in $$props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("checked" in $$props)
      $$invalidate(4, checked = $$new_props.checked);
    if ("elemInput" in $$props)
      $$invalidate(6, elemInput = $$new_props.elemInput);
    if ("classesLabel" in $$props)
      $$invalidate(7, classesLabel = $$new_props.classesLabel);
    if ("classesActive" in $$props)
      $$invalidate(15, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*multiple, group*/
    9) {
      $:
        if (multiple)
          updateCheckbox(group);
    }
    if ($$self.$$.dirty[0] & /*multiple, checked*/
    24) {
      $:
        if (multiple)
          updateGroup(checked);
    }
    if ($$self.$$.dirty[0] & /*multiple, group, value*/
    13) {
      $:
        $$invalidate(5, selected = multiple ? group.some((groupVal) => areDeeplyEqual(value, groupVal)) : areDeeplyEqual(group, value));
    }
    if ($$self.$$.dirty[0] & /*selected, active, hover*/
    12320) {
      $:
        $$invalidate(15, classesActive = selected ? active : hover);
    }
    $:
      $$invalidate(8, classesBase = `${cBase10} ${rounded} ${padding} ${classesActive} ${$$props.class ?? ""}`);
  };
  $:
    $$invalidate(7, classesLabel = `${cLabel3}`);
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    multiple,
    checked,
    selected,
    elemInput,
    classesLabel,
    classesBase,
    onKeyDown2,
    $$slots,
    rounded,
    active,
    hover,
    padding,
    classesActive,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    click_handler_1,
    change_handler_1,
    input_binding,
    input_change_handler,
    input_binding_1,
    input_change_handler_1,
    $$binding_groups
  ];
}
var ListBoxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        multiple: 3,
        rounded: 11,
        active: 12,
        hover: 13,
        padding: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxItem",
      options,
      id: create_fragment15.name
    });
  }
  get group() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxItem_default = ListBoxItem;

// node_modules/@skeletonlabs/skeleton/dist/components/Paginator/icons.js
var leftArrow = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>`;
var rightArrow = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"/></svg>`;
var leftAngles = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"/></svg>`;
var rightAngles = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>`;

// node_modules/@skeletonlabs/skeleton/dist/components/Paginator/Paginator.svelte
var file16 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Paginator\\Paginator.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[45] = list[i];
  return child_ctx;
}
function create_if_block_52(ctx) {
  let label;
  let select_1;
  let select_1_class_value;
  let label_class_value;
  let mounted;
  let dispose;
  let each_value_1 = (
    /*settings*/
    ctx[0].amounts
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      label = element("label");
      select_1 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      select_1 = claim_element(label_nodes, "SELECT", { class: true, "aria-label": true });
      var select_1_nodes = children(select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_1_nodes);
      }
      select_1_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select_1, "class", select_1_class_value = "paginator-select " + /*classesSelect*/
      ctx[18]);
      select_1.disabled = /*disabled*/
      ctx[1];
      attr_dev(select_1, "aria-label", "Select Amount");
      if (
        /*settings*/
        ctx[0].limit === void 0
      )
        add_render_callback(() => (
          /*select_1_change_handler*/
          ctx[31].call(select_1)
        ));
      add_location(select_1, file16, 100, 3, 3365);
      attr_dev(label, "class", label_class_value = "paginator-label " + /*classesLabel*/
      ctx[19]);
      add_location(label, file16, 99, 2, 3315);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select_1, null);
        }
      }
      select_option(
        select_1,
        /*settings*/
        ctx[0].limit,
        true
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            select_1,
            "change",
            /*select_1_change_handler*/
            ctx[31]
          ),
          listen_dev(
            select_1,
            "change",
            /*onChangeLength*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*settings, amountText*/
      33) {
        each_value_1 = /*settings*/
        ctx2[0].amounts;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select_1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*classesSelect*/
      262144 && select_1_class_value !== (select_1_class_value = "paginator-select " + /*classesSelect*/
      ctx2[18])) {
        attr_dev(select_1, "class", select_1_class_value);
      }
      if (dirty[0] & /*disabled*/
      2) {
        prop_dev(
          select_1,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*settings*/
      1) {
        select_option(
          select_1,
          /*settings*/
          ctx2[0].limit
        );
      }
      if (dirty[0] & /*classesLabel*/
      524288 && label_class_value !== (label_class_value = "paginator-label " + /*classesLabel*/
      ctx2[19])) {
        attr_dev(label, "class", label_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(99:1) {#if settings.amounts.length}",
    ctx
  });
  return block;
}
function create_each_block_12(ctx) {
  let option;
  let t0_value = (
    /*amount*/
    ctx[45] + ""
  );
  let t0;
  let t1;
  let t2;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(
        /*amountText*/
        ctx[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      t2 = claim_text(
        option_nodes,
        /*amountText*/
        ctx[5]
      );
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*amount*/
      ctx[45];
      option.value = option.__value;
      add_location(option, file16, 107, 38, 3570);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
      append_hydration_dev(option, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*settings*/
      1 && t0_value !== (t0_value = /*amount*/
      ctx2[45] + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*amountText*/
      32)
        set_data_dev(
          t2,
          /*amountText*/
          ctx2[5]
        );
      if (dirty[0] & /*settings*/
      1 && option_value_value !== (option_value_value = /*amount*/
      ctx2[45])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(108:4) {#each settings.amounts as amount}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let button;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelFirst*/
        ctx[11]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      ctx[0].offset === 0;
      add_location(button, file16, 115, 3, 3790);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextFirst*/
      ctx[9];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[32],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextFirst*/
      512)
        button.innerHTML = /*buttonTextFirst*/
        ctx2[9];
      ;
      if (dirty[0] & /*labelFirst*/
      2048) {
        attr_dev(
          button,
          "aria-label",
          /*labelFirst*/
          ctx2[11]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      ctx2[0].offset === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(115:2) {#if showFirstLastButtons}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let button;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelPrevious*/
        ctx[12]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      ctx[0].offset === 0;
      add_location(button, file16, 129, 3, 4079);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextPrevious*/
      ctx[7];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[33],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextPrevious*/
      128)
        button.innerHTML = /*buttonTextPrevious*/
        ctx2[7];
      ;
      if (dirty[0] & /*labelPrevious*/
      4096) {
        attr_dev(
          button,
          "aria-label",
          /*labelPrevious*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      ctx2[0].offset === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(129:2) {#if showPreviousNextButtons}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let each_1_anchor;
  let each_value = (
    /*controlPages*/
    ctx[16]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonClasses, classesButtonActive, controlPages, gotoPage*/
      10551360) {
        each_value = /*controlPages*/
        ctx2[16];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(150:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let button;
  let t0_value = (
    /*settings*/
    ctx[0].offset * /*settings*/
    ctx[0].limit + 1 + ""
  );
  let t0;
  let t1;
  let t2_value = Math.min(
    /*settings*/
    ctx[0].offset * /*settings*/
    ctx[0].limit + /*settings*/
    ctx[0].limit,
    /*settings*/
    ctx[0].size
  ) + "";
  let t2;
  let t3;
  let span;
  let t4;
  let t5_value = (
    /*settings*/
    ctx[0].size + ""
  );
  let t5;
  let button_class_value;
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = text("-");
      t2 = text(t2_value);
      t3 = text(" ");
      span = element("span");
      t4 = text("of ");
      t5 = text(t5_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_text(button_nodes, "-");
      t2 = claim_text(button_nodes, t2_value);
      t3 = claim_text(button_nodes, " ");
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t4 = claim_text(span_nodes, "of ");
      t5 = claim_text(span_nodes, t5_value);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "opacity-50");
      add_location(span, file16, 145, 125, 4606);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = /*buttonClasses*/
      ctx[6] + " pointer-events-none !text-sm");
      add_location(button, file16, 144, 3, 4405);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, t3);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t4);
      append_hydration_dev(span, t5);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*settings*/
      1 && t0_value !== (t0_value = /*settings*/
      ctx2[0].offset * /*settings*/
      ctx2[0].limit + 1 + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*settings*/
      1 && t2_value !== (t2_value = Math.min(
        /*settings*/
        ctx2[0].offset * /*settings*/
        ctx2[0].limit + /*settings*/
        ctx2[0].limit,
        /*settings*/
        ctx2[0].size
      ) + ""))
        set_data_dev(t2, t2_value);
      if (dirty[0] & /*settings*/
      1 && t5_value !== (t5_value = /*settings*/
      ctx2[0].size + ""))
        set_data_dev(t5, t5_value);
      if (dirty[0] & /*buttonClasses*/
      64 && button_class_value !== (button_class_value = /*buttonClasses*/
      ctx2[6] + " pointer-events-none !text-sm")) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(143:2) {#if showNumerals === false}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let button;
  let t0_value = (
    /*page*/
    (ctx[42] >= 0 ? (
      /*page*/
      ctx[42] + 1
    ) : "...") + ""
  );
  let t0;
  let t1;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[34](
        /*page*/
        ctx[42]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = /*buttonClasses*/
      ctx[6] + " " + /*classesButtonActive*/
      ctx[21](
        /*page*/
        ctx[42]
      ));
      add_location(button, file16, 152, 4, 4750);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_2, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*controlPages*/
      65536 && t0_value !== (t0_value = /*page*/
      (ctx[42] >= 0 ? (
        /*page*/
        ctx[42] + 1
      ) : "...") + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*buttonClasses, classesButtonActive, controlPages*/
      2162752 && button_class_value !== (button_class_value = /*buttonClasses*/
      ctx[6] + " " + /*classesButtonActive*/
      ctx[21](
        /*page*/
        ctx[42]
      ))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(152:3) {#each controlPages as page}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let button;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelNext*/
        ctx[13]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      (ctx[0].offset + 1) * /*settings*/
      ctx[0].limit >= /*settings*/
      ctx[0].size;
      add_location(button, file16, 159, 3, 4985);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextNext*/
      ctx[8];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_3*/
          ctx[35],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextNext*/
      256)
        button.innerHTML = /*buttonTextNext*/
        ctx2[8];
      ;
      if (dirty[0] & /*labelNext*/
      8192) {
        attr_dev(
          button,
          "aria-label",
          /*labelNext*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      (ctx2[0].offset + 1) * /*settings*/
      ctx2[0].limit >= /*settings*/
      ctx2[0].size)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(159:2) {#if showPreviousNextButtons}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let button;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelLast*/
        ctx[14]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      (ctx[0].offset + 1) * /*settings*/
      ctx[0].limit >= /*settings*/
      ctx[0].size;
      add_location(button, file16, 173, 3, 5321);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextLast*/
      ctx[10];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_4*/
          ctx[36],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextLast*/
      1024)
        button.innerHTML = /*buttonTextLast*/
        ctx2[10];
      ;
      if (dirty[0] & /*labelLast*/
      16384) {
        attr_dev(
          button,
          "aria-label",
          /*labelLast*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      (ctx2[0].offset + 1) * /*settings*/
      ctx2[0].limit >= /*settings*/
      ctx2[0].size)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(173:2) {#if showFirstLastButtons}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let t3;
  let t4;
  let div0_class_value;
  let div1_class_value;
  let if_block0 = (
    /*settings*/
    ctx[0].amounts.length && create_if_block_52(ctx)
  );
  let if_block1 = (
    /*showFirstLastButtons*/
    ctx[3] && create_if_block_42(ctx)
  );
  let if_block2 = (
    /*showPreviousNextButtons*/
    ctx[2] && create_if_block_32(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*showNumerals*/
      ctx2[4] === false
    )
      return create_if_block_25;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block3 = current_block_type(ctx);
  let if_block4 = (
    /*showPreviousNextButtons*/
    ctx[2] && create_if_block_17(ctx)
  );
  let if_block5 = (
    /*showFirstLastButtons*/
    ctx[3] && create_if_block12(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if_block3.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block4)
        if_block4.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      if (if_block5)
        if_block5.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "paginator-controls " + /*classesControls*/
      ctx[17]);
      add_location(div0, file16, 112, 1, 3682);
      attr_dev(div1, "class", div1_class_value = "paginator " + /*classesBase*/
      ctx[20]);
      attr_dev(div1, "data-testid", "paginator");
      add_location(div1, file16, 96, 0, 3196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      if_block3.m(div0, null);
      append_hydration_dev(div0, t3);
      if (if_block4)
        if_block4.m(div0, null);
      append_hydration_dev(div0, t4);
      if (if_block5)
        if_block5.m(div0, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*settings*/
        ctx2[0].amounts.length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*showFirstLastButtons*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*showPreviousNextButtons*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if_block3.d(1);
        if_block3 = current_block_type(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div0, t3);
        }
      }
      if (
        /*showPreviousNextButtons*/
        ctx2[2]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_17(ctx2);
          if_block4.c();
          if_block4.m(div0, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*showFirstLastButtons*/
        ctx2[3]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block12(ctx2);
          if_block5.c();
          if_block5.m(div0, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (dirty[0] & /*classesControls*/
      131072 && div0_class_value !== (div0_class_value = "paginator-controls " + /*classesControls*/
      ctx2[17])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty[0] & /*classesBase*/
      1048576 && div1_class_value !== (div1_class_value = "paginator " + /*classesBase*/
      ctx2[20])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase11 = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4";
var cLabel4 = "w-full md:w-auto";
function instance16($$self, $$props, $$invalidate) {
  let classesButtonActive;
  let classesBase;
  let classesLabel;
  let classesSelect;
  let classesControls;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paginator", slots, []);
  const dispatch = createEventDispatcher();
  let { settings = {
    offset: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = $$props;
  let { disabled = false } = $$props;
  let { showPreviousNextButtons = true } = $$props;
  let { showFirstLastButtons = false } = $$props;
  let { showNumerals = false } = $$props;
  let { maxNumerals = 1 } = $$props;
  let { justify = "justify-between" } = $$props;
  let { select = "select min-w-[150px]" } = $$props;
  let { amountText = "Items" } = $$props;
  let { regionControl = "btn-group" } = $$props;
  let { controlVariant = "variant-filled" } = $$props;
  let { controlSeparator = "" } = $$props;
  let { active = "variant-filled-primary" } = $$props;
  let { buttonClasses = "!px-3 !py-1.5 fill-current" } = $$props;
  let { buttonTextPrevious = leftArrow } = $$props;
  let { buttonTextNext = rightArrow } = $$props;
  let { buttonTextFirst = leftAngles } = $$props;
  let { buttonTextLast = rightAngles } = $$props;
  let { labelFirst = "First page" } = $$props;
  let { labelPrevious = "Previous page" } = $$props;
  let { labelNext = "Next page" } = $$props;
  let { labelLast = "Last page" } = $$props;
  let lastPage = Math.max(0, Math.ceil(settings.size / settings.limit - 1));
  let controlPages = getNumerals();
  function onChangeLength() {
    $$invalidate(0, settings.offset = 0, settings);
    dispatch("amount", settings.limit);
    $$invalidate(15, lastPage = Math.max(0, Math.ceil(settings.size / settings.limit - 1)));
    $$invalidate(16, controlPages = getNumerals());
  }
  function gotoPage(page) {
    if (page < 0)
      return;
    $$invalidate(0, settings.offset = page, settings);
    dispatch("page", settings.offset);
    $$invalidate(16, controlPages = getNumerals());
  }
  function getFullNumerals() {
    const pages = [];
    for (let index = 0; index <= lastPage; index++) {
      pages.push(index);
    }
    return pages;
  }
  function getNumerals() {
    const pages = [];
    const isWithinLeftSection = settings.offset < maxNumerals + 2;
    const isWithinRightSection = settings.offset > lastPage - (maxNumerals + 2);
    if (lastPage <= maxNumerals * 2 + 1)
      return getFullNumerals();
    pages.push(0);
    if (!isWithinLeftSection)
      pages.push(-1);
    if (isWithinLeftSection || isWithinRightSection) {
      const sectionStart = isWithinLeftSection ? 1 : lastPage - (maxNumerals + 2);
      const sectionEnd = isWithinRightSection ? lastPage - 1 : maxNumerals + 2;
      for (let i = sectionStart; i <= sectionEnd; i++) {
        pages.push(i);
      }
    } else {
      for (let i = settings.offset - maxNumerals; i <= settings.offset + maxNumerals; i++) {
        pages.push(i);
      }
    }
    if (!isWithinRightSection)
      pages.push(-1);
    pages.push(lastPage);
    return pages;
  }
  function updateSize(size) {
    $$invalidate(15, lastPage = Math.max(0, Math.ceil(size / settings.limit - 1)));
    $$invalidate(16, controlPages = getNumerals());
  }
  function select_1_change_handler() {
    settings.limit = select_value(this);
    $$invalidate(0, settings);
  }
  const click_handler = () => {
    gotoPage(0);
  };
  const click_handler_1 = () => {
    gotoPage(settings.offset - 1);
  };
  const click_handler_2 = (page) => gotoPage(page);
  const click_handler_3 = () => {
    gotoPage(settings.offset + 1);
  };
  const click_handler_4 = () => {
    gotoPage(lastPage);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(41, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("settings" in $$new_props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("showPreviousNextButtons" in $$new_props)
      $$invalidate(2, showPreviousNextButtons = $$new_props.showPreviousNextButtons);
    if ("showFirstLastButtons" in $$new_props)
      $$invalidate(3, showFirstLastButtons = $$new_props.showFirstLastButtons);
    if ("showNumerals" in $$new_props)
      $$invalidate(4, showNumerals = $$new_props.showNumerals);
    if ("maxNumerals" in $$new_props)
      $$invalidate(24, maxNumerals = $$new_props.maxNumerals);
    if ("justify" in $$new_props)
      $$invalidate(25, justify = $$new_props.justify);
    if ("select" in $$new_props)
      $$invalidate(26, select = $$new_props.select);
    if ("amountText" in $$new_props)
      $$invalidate(5, amountText = $$new_props.amountText);
    if ("regionControl" in $$new_props)
      $$invalidate(27, regionControl = $$new_props.regionControl);
    if ("controlVariant" in $$new_props)
      $$invalidate(28, controlVariant = $$new_props.controlVariant);
    if ("controlSeparator" in $$new_props)
      $$invalidate(29, controlSeparator = $$new_props.controlSeparator);
    if ("active" in $$new_props)
      $$invalidate(30, active = $$new_props.active);
    if ("buttonClasses" in $$new_props)
      $$invalidate(6, buttonClasses = $$new_props.buttonClasses);
    if ("buttonTextPrevious" in $$new_props)
      $$invalidate(7, buttonTextPrevious = $$new_props.buttonTextPrevious);
    if ("buttonTextNext" in $$new_props)
      $$invalidate(8, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextFirst" in $$new_props)
      $$invalidate(9, buttonTextFirst = $$new_props.buttonTextFirst);
    if ("buttonTextLast" in $$new_props)
      $$invalidate(10, buttonTextLast = $$new_props.buttonTextLast);
    if ("labelFirst" in $$new_props)
      $$invalidate(11, labelFirst = $$new_props.labelFirst);
    if ("labelPrevious" in $$new_props)
      $$invalidate(12, labelPrevious = $$new_props.labelPrevious);
    if ("labelNext" in $$new_props)
      $$invalidate(13, labelNext = $$new_props.labelNext);
    if ("labelLast" in $$new_props)
      $$invalidate(14, labelLast = $$new_props.labelLast);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    leftAngles,
    leftArrow,
    rightAngles,
    rightArrow,
    dispatch,
    settings,
    disabled,
    showPreviousNextButtons,
    showFirstLastButtons,
    showNumerals,
    maxNumerals,
    justify,
    select,
    amountText,
    regionControl,
    controlVariant,
    controlSeparator,
    active,
    buttonClasses,
    buttonTextPrevious,
    buttonTextNext,
    buttonTextFirst,
    buttonTextLast,
    labelFirst,
    labelPrevious,
    labelNext,
    labelLast,
    cBase: cBase11,
    cLabel: cLabel4,
    lastPage,
    controlPages,
    onChangeLength,
    gotoPage,
    getFullNumerals,
    getNumerals,
    updateSize,
    classesControls,
    classesSelect,
    classesLabel,
    classesBase,
    classesButtonActive
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(41, $$props = assign(assign({}, $$props), $$new_props));
    if ("settings" in $$props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("showPreviousNextButtons" in $$props)
      $$invalidate(2, showPreviousNextButtons = $$new_props.showPreviousNextButtons);
    if ("showFirstLastButtons" in $$props)
      $$invalidate(3, showFirstLastButtons = $$new_props.showFirstLastButtons);
    if ("showNumerals" in $$props)
      $$invalidate(4, showNumerals = $$new_props.showNumerals);
    if ("maxNumerals" in $$props)
      $$invalidate(24, maxNumerals = $$new_props.maxNumerals);
    if ("justify" in $$props)
      $$invalidate(25, justify = $$new_props.justify);
    if ("select" in $$props)
      $$invalidate(26, select = $$new_props.select);
    if ("amountText" in $$props)
      $$invalidate(5, amountText = $$new_props.amountText);
    if ("regionControl" in $$props)
      $$invalidate(27, regionControl = $$new_props.regionControl);
    if ("controlVariant" in $$props)
      $$invalidate(28, controlVariant = $$new_props.controlVariant);
    if ("controlSeparator" in $$props)
      $$invalidate(29, controlSeparator = $$new_props.controlSeparator);
    if ("active" in $$props)
      $$invalidate(30, active = $$new_props.active);
    if ("buttonClasses" in $$props)
      $$invalidate(6, buttonClasses = $$new_props.buttonClasses);
    if ("buttonTextPrevious" in $$props)
      $$invalidate(7, buttonTextPrevious = $$new_props.buttonTextPrevious);
    if ("buttonTextNext" in $$props)
      $$invalidate(8, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextFirst" in $$props)
      $$invalidate(9, buttonTextFirst = $$new_props.buttonTextFirst);
    if ("buttonTextLast" in $$props)
      $$invalidate(10, buttonTextLast = $$new_props.buttonTextLast);
    if ("labelFirst" in $$props)
      $$invalidate(11, labelFirst = $$new_props.labelFirst);
    if ("labelPrevious" in $$props)
      $$invalidate(12, labelPrevious = $$new_props.labelPrevious);
    if ("labelNext" in $$props)
      $$invalidate(13, labelNext = $$new_props.labelNext);
    if ("labelLast" in $$props)
      $$invalidate(14, labelLast = $$new_props.labelLast);
    if ("lastPage" in $$props)
      $$invalidate(15, lastPage = $$new_props.lastPage);
    if ("controlPages" in $$props)
      $$invalidate(16, controlPages = $$new_props.controlPages);
    if ("classesControls" in $$props)
      $$invalidate(17, classesControls = $$new_props.classesControls);
    if ("classesSelect" in $$props)
      $$invalidate(18, classesSelect = $$new_props.classesSelect);
    if ("classesLabel" in $$props)
      $$invalidate(19, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(20, classesBase = $$new_props.classesBase);
    if ("classesButtonActive" in $$props)
      $$invalidate(21, classesButtonActive = $$new_props.classesButtonActive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*settings, active*/
    1073741825) {
      $:
        $$invalidate(21, classesButtonActive = (page) => {
          return page === settings.offset ? `${active} pointer-events-none` : "";
        });
    }
    if ($$self.$$.dirty[0] & /*maxNumerals*/
    16777216) {
      $:
        maxNumerals, onChangeLength();
    }
    if ($$self.$$.dirty[0] & /*settings*/
    1) {
      $:
        updateSize(settings.size);
    }
    $:
      $$invalidate(20, classesBase = `${cBase11} ${justify} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*select*/
    67108864) {
      $:
        $$invalidate(18, classesSelect = `${select}`);
    }
    if ($$self.$$.dirty[0] & /*regionControl, controlVariant, controlSeparator*/
    939524096) {
      $:
        $$invalidate(17, classesControls = `${regionControl} ${controlVariant} ${controlSeparator}`);
    }
  };
  $:
    $$invalidate(19, classesLabel = `${cLabel4}`);
  $$props = exclude_internal_props($$props);
  return [
    settings,
    disabled,
    showPreviousNextButtons,
    showFirstLastButtons,
    showNumerals,
    amountText,
    buttonClasses,
    buttonTextPrevious,
    buttonTextNext,
    buttonTextFirst,
    buttonTextLast,
    labelFirst,
    labelPrevious,
    labelNext,
    labelLast,
    lastPage,
    controlPages,
    classesControls,
    classesSelect,
    classesLabel,
    classesBase,
    classesButtonActive,
    onChangeLength,
    gotoPage,
    maxNumerals,
    justify,
    select,
    regionControl,
    controlVariant,
    controlSeparator,
    active,
    select_1_change_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4
  ];
}
var Paginator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        settings: 0,
        disabled: 1,
        showPreviousNextButtons: 2,
        showFirstLastButtons: 3,
        showNumerals: 4,
        maxNumerals: 24,
        justify: 25,
        select: 26,
        amountText: 5,
        regionControl: 27,
        controlVariant: 28,
        controlSeparator: 29,
        active: 30,
        buttonClasses: 6,
        buttonTextPrevious: 7,
        buttonTextNext: 8,
        buttonTextFirst: 9,
        buttonTextLast: 10,
        labelFirst: 11,
        labelPrevious: 12,
        labelNext: 13,
        labelLast: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paginator",
      options,
      id: create_fragment16.name
    });
  }
  get settings() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showPreviousNextButtons() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showPreviousNextButtons(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showFirstLastButtons() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showFirstLastButtons(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showNumerals() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showNumerals(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxNumerals() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxNumerals(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get amountText() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set amountText(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionControl() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionControl(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlVariant() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlVariant(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlSeparator() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlSeparator(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClasses() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClasses(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextPrevious() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextPrevious(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextNext() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextNext(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextFirst() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextFirst(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextLast() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextLast(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFirst() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFirst(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPrevious() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPrevious(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelNext() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelNext(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelLast() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelLast(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paginator_default = Paginator;

// node_modules/@skeletonlabs/skeleton/dist/components/ProgressBar/ProgressBar.svelte
var file17 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\ProgressBar\\ProgressBar.svelte";
function add_css(target) {
  append_styles(target, "svelte-meqa4r", ".animIndeterminate.svelte-meqa4r{transform-origin:0% 50%;animation:svelte-meqa4r-animIndeterminate 2s infinite linear}@keyframes svelte-meqa4r-animIndeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NCYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFDQyxnQ0FBbUIsQ0FDbEIsZ0JBQWdCLENBQUUsRUFBRSxDQUFDLEdBQUcsQ0FDeEIsU0FBUyxDQUFFLCtCQUFpQixDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFDMUMsQ0FFQSxXQUFXLCtCQUFrQixDQUM1QixFQUFHLENBQUUsU0FBUyxDQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUcsQ0FDekMsR0FBSSxDQUFFLFNBQVMsQ0FBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFHLENBQzVDLElBQUssQ0FBRSxTQUFTLENBQUUsV0FBVyxJQUFJLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBRyxDQUNqRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQcm9ncmVzc0Jhci5zdmVsdGUiXX0= */");
}
function create_fragment17(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let style_width = `${/*indeterminate*/
  ctx[4] ? 100 : (
    /*fillPercent*/
    ctx[7]
  )}%`;
  let div1_class_value;
  let div1_aria_valuemax_value;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-labelledby": true,
        "aria-valuenow": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "progress-bar-meter " + /*classesMeter*/
      ctx[5] + " " + /*classesMeter*/
      ctx[5] + " svelte-meqa4r");
      set_style(div0, "width", style_width);
      add_location(div0, file17, 33, 1, 916);
      attr_dev(div1, "class", div1_class_value = "progress-bar " + /*classesTrack*/
      ctx[6] + " svelte-meqa4r");
      attr_dev(div1, "data-testid", "progress-bar");
      attr_dev(div1, "role", "progressbar");
      attr_dev(
        div1,
        "aria-labelledby",
        /*labelledby*/
        ctx[3]
      );
      attr_dev(
        div1,
        "aria-valuenow",
        /*value*/
        ctx[0]
      );
      attr_dev(
        div1,
        "aria-valuemin",
        /*min*/
        ctx[1]
      );
      attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value = /*max*/
      ctx[2] - /*min*/
      ctx[1]);
      add_location(div1, file17, 23, 0, 706);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*classesMeter*/
      32 && div0_class_value !== (div0_class_value = "progress-bar-meter " + /*classesMeter*/
      ctx2[5] + " " + /*classesMeter*/
      ctx2[5] + " svelte-meqa4r")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*indeterminate, fillPercent*/
      144 && style_width !== (style_width = `${/*indeterminate*/
      ctx2[4] ? 100 : (
        /*fillPercent*/
        ctx2[7]
      )}%`)) {
        set_style(div0, "width", style_width);
      }
      if (dirty & /*classesTrack*/
      64 && div1_class_value !== (div1_class_value = "progress-bar " + /*classesTrack*/
      ctx2[6] + " svelte-meqa4r")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*labelledby*/
      8) {
        attr_dev(
          div1,
          "aria-labelledby",
          /*labelledby*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1) {
        attr_dev(
          div1,
          "aria-valuenow",
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*min*/
      2) {
        attr_dev(
          div1,
          "aria-valuemin",
          /*min*/
          ctx2[1]
        );
      }
      if (dirty & /*max, min*/
      6 && div1_aria_valuemax_value !== (div1_aria_valuemax_value = /*max*/
      ctx2[2] - /*min*/
      ctx2[1])) {
        attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cTrack = "w-full overflow-hidden";
var cMeter = "h-full";
function instance17($$self, $$props, $$invalidate) {
  let fillPercent;
  let indeterminate;
  let classesIndeterminate;
  let classesTrack;
  let classesMeter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, []);
  let { value = void 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { height = "h-2" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { meter = "bg-surface-900-50-token" } = $$props;
  let { track = "bg-surface-200-700-token" } = $$props;
  let { labelledby = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("height" in $$new_props)
      $$invalidate(8, height = $$new_props.height);
    if ("rounded" in $$new_props)
      $$invalidate(9, rounded = $$new_props.rounded);
    if ("meter" in $$new_props)
      $$invalidate(10, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(11, track = $$new_props.track);
    if ("labelledby" in $$new_props)
      $$invalidate(3, labelledby = $$new_props.labelledby);
  };
  $$self.$capture_state = () => ({
    value,
    min,
    max,
    height,
    rounded,
    meter,
    track,
    labelledby,
    cTrack,
    cMeter,
    classesIndeterminate,
    classesMeter,
    classesTrack,
    indeterminate,
    fillPercent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("height" in $$props)
      $$invalidate(8, height = $$new_props.height);
    if ("rounded" in $$props)
      $$invalidate(9, rounded = $$new_props.rounded);
    if ("meter" in $$props)
      $$invalidate(10, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(11, track = $$new_props.track);
    if ("labelledby" in $$props)
      $$invalidate(3, labelledby = $$new_props.labelledby);
    if ("classesIndeterminate" in $$props)
      $$invalidate(12, classesIndeterminate = $$new_props.classesIndeterminate);
    if ("classesMeter" in $$props)
      $$invalidate(5, classesMeter = $$new_props.classesMeter);
    if ("classesTrack" in $$props)
      $$invalidate(6, classesTrack = $$new_props.classesTrack);
    if ("indeterminate" in $$props)
      $$invalidate(4, indeterminate = $$new_props.indeterminate);
    if ("fillPercent" in $$props)
      $$invalidate(7, fillPercent = $$new_props.fillPercent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, min, max*/
    7) {
      $:
        $$invalidate(7, fillPercent = value ? 100 * (value - min) / (max - min) : 0);
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        $$invalidate(4, indeterminate = value === void 0 || value < 0);
    }
    if ($$self.$$.dirty & /*indeterminate*/
    16) {
      $:
        $$invalidate(12, classesIndeterminate = indeterminate ? "animIndeterminate" : "");
    }
    $:
      $$invalidate(6, classesTrack = `${cTrack} ${height} ${rounded} ${track} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*rounded, classesIndeterminate, meter*/
    5632) {
      $:
        $$invalidate(5, classesMeter = `${cMeter} ${rounded} ${classesIndeterminate} ${meter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    min,
    max,
    labelledby,
    indeterminate,
    classesMeter,
    classesTrack,
    fillPercent,
    height,
    rounded,
    meter,
    track,
    classesIndeterminate
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        value: 0,
        min: 1,
        max: 2,
        height: 8,
        rounded: 9,
        meter: 10,
        track: 11,
        labelledby: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment17.name
    });
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/@skeletonlabs/skeleton/dist/components/ProgressRadial/ProgressRadial.svelte
var file18 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\ProgressRadial\\ProgressRadial.svelte";
function create_if_block13(ctx) {
  let text_1;
  let text_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        "dominant-baseline": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      if (default_slot)
        default_slot.l(text_1_nodes);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(
        text_1,
        "font-size",
        /*font*/
        ctx[2]
      );
      attr_dev(text_1, "class", text_1_class_value = "progress-radial-text " + /*fill*/
      ctx[5]);
      add_location(text_1, file18, 58, 3, 1852);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      if (default_slot) {
        default_slot.m(text_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*font*/
      4) {
        attr_dev(
          text_1,
          "font-size",
          /*font*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*fill*/
      32 && text_1_class_value !== (text_1_class_value = "progress-radial-text " + /*fill*/
      ctx2[5])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(58:2) {#if value != undefined && value >= 0 && $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let figure;
  let svg;
  let circle0;
  let circle0_class_value;
  let circle0_r_value;
  let circle1;
  let circle1_class_value;
  let circle1_r_value;
  let style_stroke_dasharray = `${/*circumference*/
  ctx[7]}
			${/*circumference*/
  ctx[7]}`;
  let svg_viewBox_value;
  let figure_class_value;
  let figure_aria_valuenow_value;
  let figure_aria_valuetext_value;
  let figure_aria_valuemin_value;
  let figure_aria_valuemax_value;
  let current;
  let if_block = (
    /*value*/
    ctx[0] != void 0 && /*value*/
    ctx[0] >= 0 && /*$$slots*/
    ctx[10].default && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-labelledby": true,
        "aria-valuenow": true,
        "aria-valuetext": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var figure_nodes = children(figure);
      svg = claim_svg_element(figure_nodes, "svg", { viewBox: true, class: true });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle1).forEach(detach_dev);
      if (if_block)
        if_block.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", circle0_class_value = "progress-radial-track " + cBaseTrack + " " + /*track*/
      ctx[4]);
      attr_dev(
        circle0,
        "stroke-width",
        /*stroke*/
        ctx[1]
      );
      attr_dev(circle0, "r", circle0_r_value = baseSize / 2);
      attr_dev(circle0, "cx", "50%");
      attr_dev(circle0, "cy", "50%");
      add_location(circle0, file18, 42, 2, 1387);
      attr_dev(circle1, "class", circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      ctx[3]);
      attr_dev(
        circle1,
        "stroke-width",
        /*stroke*/
        ctx[1]
      );
      attr_dev(circle1, "r", circle1_r_value = baseSize / 2);
      attr_dev(circle1, "cx", "50%");
      attr_dev(circle1, "cy", "50%");
      set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      set_style(
        circle1,
        "stroke-dashoffset",
        /*dashoffset*/
        ctx[8]
      );
      add_location(circle1, file18, 45, 2, 1526);
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + baseSize + " " + baseSize);
      attr_dev(svg, "class", "rounded-full");
      toggle_class(
        svg,
        "animate-spin",
        /*value*/
        ctx[0] === void 0
      );
      add_location(svg, file18, 40, 1, 1264);
      attr_dev(figure, "class", figure_class_value = "progress-radial " + /*classesBase*/
      ctx[9]);
      attr_dev(figure, "data-testid", "progress-radial");
      attr_dev(figure, "role", "meter");
      attr_dev(
        figure,
        "aria-labelledby",
        /*labelledby*/
        ctx[6]
      );
      attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value = /*value*/
      ctx[0] || 0);
      attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value = /*value*/
      ctx[0] ? `${/*value*/
      ctx[0]}%` : "Indeterminate Spinner");
      attr_dev(figure, "aria-valuemin", figure_aria_valuemin_value = 0);
      attr_dev(figure, "aria-valuemax", figure_aria_valuemax_value = 100);
      add_location(figure, file18, 29, 0, 988);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      append_hydration_dev(figure, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      if (if_block)
        if_block.m(svg, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*track*/
      16 && circle0_class_value !== (circle0_class_value = "progress-radial-track " + cBaseTrack + " " + /*track*/
      ctx2[4])) {
        attr_dev(circle0, "class", circle0_class_value);
      }
      if (!current || dirty & /*stroke*/
      2) {
        attr_dev(
          circle0,
          "stroke-width",
          /*stroke*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*meter*/
      8 && circle1_class_value !== (circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      ctx2[3])) {
        attr_dev(circle1, "class", circle1_class_value);
      }
      if (!current || dirty & /*stroke*/
      2) {
        attr_dev(
          circle1,
          "stroke-width",
          /*stroke*/
          ctx2[1]
        );
      }
      if (dirty & /*circumference*/
      128 && style_stroke_dasharray !== (style_stroke_dasharray = `${/*circumference*/
      ctx2[7]}
			${/*circumference*/
      ctx2[7]}`)) {
        set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      }
      if (dirty & /*dashoffset*/
      256) {
        set_style(
          circle1,
          "stroke-dashoffset",
          /*dashoffset*/
          ctx2[8]
        );
      }
      if (
        /*value*/
        ctx2[0] != void 0 && /*value*/
        ctx2[0] >= 0 && /*$$slots*/
        ctx2[10].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value, $$slots*/
          1025) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(svg, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*value, undefined*/
      1) {
        toggle_class(
          svg,
          "animate-spin",
          /*value*/
          ctx2[0] === void 0
        );
      }
      if (!current || dirty & /*classesBase*/
      512 && figure_class_value !== (figure_class_value = "progress-radial " + /*classesBase*/
      ctx2[9])) {
        attr_dev(figure, "class", figure_class_value);
      }
      if (!current || dirty & /*labelledby*/
      64) {
        attr_dev(
          figure,
          "aria-labelledby",
          /*labelledby*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*value*/
      1 && figure_aria_valuenow_value !== (figure_aria_valuenow_value = /*value*/
      ctx2[0] || 0)) {
        attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value);
      }
      if (!current || dirty & /*value*/
      1 && figure_aria_valuetext_value !== (figure_aria_valuetext_value = /*value*/
      ctx2[0] ? `${/*value*/
      ctx2[0]}%` : "Indeterminate Spinner")) {
        attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase12 = "progress-radial relative overflow-hidden";
var cBaseTrack = "fill-transparent";
var cBaseMeter = "fill-transparent transition-[stroke-dashoffset] duration-200 -rotate-90 origin-[50%_50%]";
var baseSize = 512;
function instance18($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressRadial", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { value = void 0 } = $$props;
  let { stroke = 40 } = $$props;
  let { font = 56 } = $$props;
  let { width = "w-36" } = $$props;
  let { meter = "stroke-surface-900 dark:stroke-surface-50" } = $$props;
  let { track = "stroke-surface-500/30" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { labelledby = "" } = $$props;
  const radius = baseSize / 2;
  let circumference = radius;
  let dashoffset;
  function setProgress(percent) {
    $$invalidate(7, circumference = radius * 2 * Math.PI);
    $$invalidate(8, dashoffset = circumference - percent / 100 * circumference);
  }
  setProgress(0);
  afterUpdate(() => {
    setProgress(value === void 0 ? 25 : value);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$new_props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("font" in $$new_props)
      $$invalidate(2, font = $$new_props.font);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("meter" in $$new_props)
      $$invalidate(3, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(4, track = $$new_props.track);
    if ("fill" in $$new_props)
      $$invalidate(5, fill = $$new_props.fill);
    if ("labelledby" in $$new_props)
      $$invalidate(6, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    value,
    stroke,
    font,
    width,
    meter,
    track,
    fill,
    labelledby,
    cBase: cBase12,
    cBaseTrack,
    cBaseMeter,
    baseSize,
    radius,
    circumference,
    dashoffset,
    setProgress,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("font" in $$props)
      $$invalidate(2, font = $$new_props.font);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("meter" in $$props)
      $$invalidate(3, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(4, track = $$new_props.track);
    if ("fill" in $$props)
      $$invalidate(5, fill = $$new_props.fill);
    if ("labelledby" in $$props)
      $$invalidate(6, labelledby = $$new_props.labelledby);
    if ("circumference" in $$props)
      $$invalidate(7, circumference = $$new_props.circumference);
    if ("dashoffset" in $$props)
      $$invalidate(8, dashoffset = $$new_props.dashoffset);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${cBase12} ${width} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    stroke,
    font,
    meter,
    track,
    fill,
    labelledby,
    circumference,
    dashoffset,
    classesBase,
    $$slots,
    width,
    $$scope,
    slots
  ];
}
var ProgressRadial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      value: 0,
      stroke: 1,
      font: 2,
      width: 11,
      meter: 3,
      track: 4,
      fill: 5,
      labelledby: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressRadial",
      options,
      id: create_fragment18.name
    });
  }
  get value() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressRadial_default = ProgressRadial;

// node_modules/@skeletonlabs/skeleton/dist/components/Ratings/Ratings.svelte
var file19 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Ratings\\Ratings.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
var get_empty_slot_changes_1 = (dirty) => ({});
var get_empty_slot_context_1 = (ctx) => ({});
var get_half_slot_changes_1 = (dirty) => ({});
var get_half_slot_context_1 = (ctx) => ({});
var get_full_slot_changes_1 = (dirty) => ({});
var get_full_slot_context_1 = (ctx) => ({});
var get_empty_slot_changes = (dirty) => ({});
var get_empty_slot_context = (ctx) => ({});
var get_half_slot_changes = (dirty) => ({});
var get_half_slot_context = (ctx) => ({});
var get_full_slot_changes = (dirty) => ({});
var get_full_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let span;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let t;
  let span_class_value;
  let current;
  const if_block_creators = [create_if_block_33, create_if_block_43, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty & /*value*/
    1)
      show_if = null;
    if (dirty & /*value*/
    1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isFull(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isHalf(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block.l(span_nodes);
      t = claim_space(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "rating-icon " + /*regionIcon*/
      ctx[3]);
      add_location(span, file19, 40, 3, 1145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      append_hydration_dev(span, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, t);
      }
      if (!current || dirty & /*regionIcon*/
      8 && span_class_value !== (span_class_value = "rating-icon " + /*regionIcon*/
      ctx2[3])) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(40:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let button;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let t;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_18, create_if_block_26, create_else_block5];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*value*/
    1)
      show_if = null;
    if (dirty & /*value*/
    1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isFull(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isHalf(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[12](
        /*i*/
        ctx[17]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, type: true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      t = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "rating-icon " + /*regionIcon*/
      ctx[3]);
      attr_dev(button, "type", "button");
      add_location(button, file19, 30, 3, 873);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(button, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, t);
      }
      if (!current || dirty & /*regionIcon*/
      8 && button_class_value !== (button_class_value = "rating-icon " + /*regionIcon*/
      ctx[3])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(30:2) {#if interactive}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[11].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_empty_slot_context_1
  );
  const block = {
    c: function create() {
      if (empty_slot)
        empty_slot.c();
    },
    l: function claim(nodes) {
      if (empty_slot)
        empty_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (empty_slot) {
        empty_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_empty_slot_changes_1
            ),
            get_empty_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(empty_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(empty_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (empty_slot)
        empty_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(46:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let current;
  const half_slot_template = (
    /*#slots*/
    ctx[11].half
  );
  const half_slot = create_slot(
    half_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_half_slot_context_1
  );
  const block = {
    c: function create() {
      if (half_slot)
        half_slot.c();
    },
    l: function claim(nodes) {
      if (half_slot)
        half_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (half_slot) {
        half_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (half_slot) {
        if (half_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            half_slot,
            half_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              half_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_half_slot_changes_1
            ),
            get_half_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(half_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(half_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (half_slot)
        half_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(44:31) ",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let current;
  const full_slot_template = (
    /*#slots*/
    ctx[11].full
  );
  const full_slot = create_slot(
    full_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_full_slot_context_1
  );
  const block = {
    c: function create() {
      if (full_slot)
        full_slot.c();
    },
    l: function claim(nodes) {
      if (full_slot)
        full_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (full_slot) {
        full_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (full_slot) {
        if (full_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            full_slot,
            full_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              full_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_full_slot_changes_1
            ),
            get_full_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(full_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(full_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (full_slot)
        full_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(42:4) {#if isFull(value, i)}",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[11].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_empty_slot_context
  );
  const block = {
    c: function create() {
      if (empty_slot)
        empty_slot.c();
    },
    l: function claim(nodes) {
      if (empty_slot)
        empty_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (empty_slot) {
        empty_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_empty_slot_changes
            ),
            get_empty_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(empty_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(empty_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (empty_slot)
        empty_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(36:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let current;
  const half_slot_template = (
    /*#slots*/
    ctx[11].half
  );
  const half_slot = create_slot(
    half_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_half_slot_context
  );
  const block = {
    c: function create() {
      if (half_slot)
        half_slot.c();
    },
    l: function claim(nodes) {
      if (half_slot)
        half_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (half_slot) {
        half_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (half_slot) {
        if (half_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            half_slot,
            half_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              half_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_half_slot_changes
            ),
            get_half_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(half_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(half_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (half_slot)
        half_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(34:31) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let current;
  const full_slot_template = (
    /*#slots*/
    ctx[11].full
  );
  const full_slot = create_slot(
    full_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_full_slot_context
  );
  const block = {
    c: function create() {
      if (full_slot)
        full_slot.c();
    },
    l: function claim(nodes) {
      if (full_slot)
        full_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (full_slot) {
        full_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (full_slot) {
        if (full_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            full_slot,
            full_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              full_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_full_slot_changes
            ),
            get_full_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(full_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(full_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (full_slot)
        full_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(32:4) {#if isFull(value, i)}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block14, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*interactive*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(29:1) {#each Array(max) as _, i}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div;
  let div_class_value;
  let current;
  let each_value = Array(
    /*max*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "ratings " + /*classesBase*/
      ctx[4]);
      attr_dev(div, "data-testid", "rating-bar");
      add_location(div, file19, 26, 0, 692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*regionIcon, iconClick, $$scope, isFull, value, isHalf, interactive, max*/
      1071) {
        each_value = Array(
          /*max*/
          ctx2[1]
        );
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      16 && div_class_value !== (div_class_value = "ratings " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase13 = "w-full flex";
function isFull(value2, index) {
  return Math.floor(value2) >= index + 1;
}
function isHalf(value2, index) {
  return value2 === index + 0.5;
}
function instance19($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ratings", slots, ["full", "half", "empty"]);
  let { value = 0 } = $$props;
  let { max = 5 } = $$props;
  let { interactive = false } = $$props;
  let { text: text2 = "text-token" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { justify = "justify-center" } = $$props;
  let { spacing = "space-x-2" } = $$props;
  let { regionIcon = "" } = $$props;
  const dispatch = createEventDispatcher();
  function iconClick(index) {
    dispatch("icon", { index: index + 1 });
  }
  const click_handler = (i) => iconClick(i);
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(1, max = $$new_props.max);
    if ("interactive" in $$new_props)
      $$invalidate(2, interactive = $$new_props.interactive);
    if ("text" in $$new_props)
      $$invalidate(6, text2 = $$new_props.text);
    if ("fill" in $$new_props)
      $$invalidate(7, fill = $$new_props.fill);
    if ("justify" in $$new_props)
      $$invalidate(8, justify = $$new_props.justify);
    if ("spacing" in $$new_props)
      $$invalidate(9, spacing = $$new_props.spacing);
    if ("regionIcon" in $$new_props)
      $$invalidate(3, regionIcon = $$new_props.regionIcon);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    value,
    max,
    interactive,
    text: text2,
    fill,
    justify,
    spacing,
    regionIcon,
    dispatch,
    iconClick,
    isFull,
    isHalf,
    cBase: cBase13,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(1, max = $$new_props.max);
    if ("interactive" in $$props)
      $$invalidate(2, interactive = $$new_props.interactive);
    if ("text" in $$props)
      $$invalidate(6, text2 = $$new_props.text);
    if ("fill" in $$props)
      $$invalidate(7, fill = $$new_props.fill);
    if ("justify" in $$props)
      $$invalidate(8, justify = $$new_props.justify);
    if ("spacing" in $$props)
      $$invalidate(9, spacing = $$new_props.spacing);
    if ("regionIcon" in $$props)
      $$invalidate(3, regionIcon = $$new_props.regionIcon);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${cBase13} ${text2} ${fill} ${justify} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    max,
    interactive,
    regionIcon,
    classesBase,
    iconClick,
    text2,
    fill,
    justify,
    spacing,
    $$scope,
    slots,
    click_handler
  ];
}
var Ratings = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      value: 0,
      max: 1,
      interactive: 2,
      text: 6,
      fill: 7,
      justify: 8,
      spacing: 9,
      regionIcon: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ratings",
      options,
      id: create_fragment19.name
    });
  }
  get value() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionIcon() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionIcon(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ratings_default = Ratings;

// node_modules/@skeletonlabs/skeleton/dist/components/Radio/RadioGroup.svelte
var file20 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Radio\\RadioGroup.svelte";
function create_fragment20(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-labelledby": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "radio-group " + /*classesBase*/
      ctx[1]);
      attr_dev(div, "data-testid", "radio-group");
      attr_dev(div, "role", "radiogroup");
      attr_dev(
        div,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      add_location(div, file20, 25, 0, 835);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      2 && div_class_value !== (div_class_value = "radio-group " + /*classesBase*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div,
          "aria-labelledby",
          /*labelledby*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase14 = "p-1";
function instance20($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { display = "inline-flex" } = $$props;
  let { background = "bg-surface-200-700-token" } = $$props;
  let { border = "border-token border-surface-400-500-token" } = $$props;
  let { spacing = "" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { padding = "px-4 py-1" } = $$props;
  let { active = "variant-filled" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { color = "" } = $$props;
  let { fill = "" } = $$props;
  let { labelledby = "" } = $$props;
  setContext("rounded", rounded);
  setContext("padding", padding);
  setContext("active", active);
  setContext("hover", hover);
  setContext("color", color);
  setContext("fill", fill);
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("display" in $$new_props)
      $$invalidate(3, display = $$new_props.display);
    if ("background" in $$new_props)
      $$invalidate(4, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(5, border = $$new_props.border);
    if ("spacing" in $$new_props)
      $$invalidate(2, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(6, rounded = $$new_props.rounded);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    display,
    background,
    border,
    spacing,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    labelledby,
    cBase: cBase14,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("display" in $$props)
      $$invalidate(3, display = $$new_props.display);
    if ("background" in $$props)
      $$invalidate(4, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(5, border = $$new_props.border);
    if ("spacing" in $$props)
      $$invalidate(2, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(6, rounded = $$new_props.rounded);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*display*/
    8) {
      $:
        $$invalidate(2, spacing = `${display.includes("flex-col") ? "" : "space-x-1"}`);
    }
    $:
      $$invalidate(1, classesBase = `${cBase14} ${display} ${background} ${border} ${spacing} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    classesBase,
    spacing,
    display,
    background,
    border,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    $$scope,
    slots
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      display: 3,
      background: 4,
      border: 5,
      spacing: 2,
      rounded: 6,
      padding: 7,
      active: 8,
      hover: 9,
      color: 10,
      fill: 11,
      labelledby: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment20.name
    });
  }
  get display() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// node_modules/@skeletonlabs/skeleton/dist/components/Radio/RadioItem.svelte
var file21 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Radio\\RadioItem.svelte";
function create_fragment21(ctx) {
  let label_1;
  let div1;
  let div0;
  let input;
  let t;
  let div1_class_value;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    { __value: (
      /*value*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[9](),
    { tabindex: "-1" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[27][0]
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", {});
      var label_1_nodes = children(label_1);
      div1 = claim_element(label_1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-checked": true,
        "aria-label": true,
        tabindex: true,
        title: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true, tabindex: true });
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file21, 52, 3, 1420);
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file21, 51, 2, 1379);
      attr_dev(div1, "class", div1_class_value = "radio-item " + /*classesBase*/
      ctx[7]);
      attr_dev(div1, "data-testid", "radio-item");
      attr_dev(div1, "role", "radio");
      attr_dev(
        div1,
        "aria-checked",
        /*checked*/
        ctx[5]
      );
      attr_dev(
        div1,
        "aria-label",
        /*label*/
        ctx[4]
      );
      attr_dev(div1, "tabindex", "0");
      attr_dev(
        div1,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(div1, file21, 37, 1, 1081);
      add_location(label_1, file21, 35, 0, 1019);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[25](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_hydration_dev(div1, t);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[26]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*onKeyDown*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty & /*value*/
        4) && { __value: (
          /*value*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[9](),
        { tabindex: "-1" }
      ]));
      if (dirty & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      128 && div1_class_value !== (div1_class_value = "radio-item " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*checked*/
      32) {
        attr_dev(
          div1,
          "aria-checked",
          /*checked*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*label*/
      16) {
        attr_dev(
          div1,
          "aria-label",
          /*label*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*title*/
      8) {
        attr_dev(
          div1,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      ctx[25](null);
      if (default_slot)
        default_slot.d(detaching);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase15 = "flex-auto text-base text-center cursor-pointer";
var cDisabled = "opacity-50 cursor-not-allowed";
function instance21($$self, $$props, $$invalidate) {
  let checked;
  let classesActive;
  let classesDisabled;
  let classesBase;
  const omit_props_names = [
    "group",
    "name",
    "value",
    "title",
    "label",
    "rounded",
    "padding",
    "active",
    "hover",
    "color",
    "fill"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioItem", slots, ["default"]);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { title = "" } = $$props;
  let { label = "" } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { color = getContext("color") } = $$props;
  let { fill = getContext("fill") } = $$props;
  let elemInput;
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemInput.click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<RadioItem> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<RadioItem> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<RadioItem> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("label" in $$new_props)
      $$invalidate(4, label = $$new_props.label);
    if ("rounded" in $$new_props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("active" in $$new_props)
      $$invalidate(12, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(15, fill = $$new_props.fill);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    title,
    label,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    cBase: cBase15,
    cDisabled,
    elemInput,
    onKeyDown: onKeyDown2,
    prunedRestProps,
    classesDisabled,
    classesActive,
    classesBase,
    checked
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("label" in $$props)
      $$invalidate(4, label = $$new_props.label);
    if ("rounded" in $$props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("active" in $$props)
      $$invalidate(12, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(15, fill = $$new_props.fill);
    if ("elemInput" in $$props)
      $$invalidate(6, elemInput = $$new_props.elemInput);
    if ("classesDisabled" in $$props)
      $$invalidate(16, classesDisabled = $$new_props.classesDisabled);
    if ("classesActive" in $$props)
      $$invalidate(17, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
    if ("checked" in $$props)
      $$invalidate(5, checked = $$new_props.checked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, group*/
    5) {
      $:
        $$invalidate(5, checked = value === group);
    }
    if ($$self.$$.dirty & /*checked, active, color, fill, hover*/
    61472) {
      $:
        $$invalidate(17, classesActive = checked ? `${active} ${color} ${fill}` : hover);
    }
    $:
      $$invalidate(16, classesDisabled = $$props.disabled ? cDisabled : "");
    $:
      $$invalidate(7, classesBase = `${cBase15} ${padding} ${rounded} ${classesActive} ${classesDisabled} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    title,
    label,
    checked,
    elemInput,
    classesBase,
    onKeyDown2,
    prunedRestProps,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    classesDisabled,
    classesActive,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    input_binding,
    input_change_handler,
    $$binding_groups
  ];
}
var RadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      group: 0,
      name: 1,
      value: 2,
      title: 3,
      label: 4,
      rounded: 10,
      padding: 11,
      active: 12,
      hover: 13,
      color: 14,
      fill: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioItem",
      options,
      id: create_fragment21.name
    });
  }
  get group() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioItem_default = RadioItem;

// node_modules/@skeletonlabs/skeleton/dist/components/RangeSlider/RangeSlider.svelte
var file22 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\RangeSlider\\RangeSlider.svelte";
var get_trail_slot_changes4 = (dirty) => ({});
var get_trail_slot_context4 = (ctx) => ({});
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_if_block_27(ctx) {
  let label_1;
  let label_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", label_1_class_value = "range-slider-label " + cBaseLabel);
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx[2]
      );
      add_location(label_1, file22, 37, 22, 951);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(38:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let datalist;
  let datalist_id_value;
  let each_value = (
    /*tickmarks*/
    ctx[8]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      datalist = claim_element(nodes, "DATALIST", { id: true, class: true });
      var datalist_nodes = children(datalist);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(datalist_nodes);
      }
      datalist_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(datalist, "id", datalist_id_value = "tickmarks-" + /*id*/
      ctx[2]);
      attr_dev(datalist, "class", "range-slider-ticks");
      add_location(datalist, file22, 61, 3, 1426);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, datalist, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(datalist, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tickmarks*/
      256) {
        each_value = /*tickmarks*/
        ctx2[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*id*/
      4 && datalist_id_value !== (datalist_id_value = "tickmarks-" + /*id*/
      ctx2[2])) {
        attr_dev(datalist, "id", datalist_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(datalist);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(61:2) {#if ticked && tickmarks && tickmarks.length}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let option;
  let option_value_value;
  let option_label_value;
  const block = {
    c: function create() {
      option = element("option");
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { label: true });
      children(option).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*tm*/
      ctx[23];
      option.value = option.__value;
      attr_dev(option, "label", option_label_value = /*tm*/
      ctx[23]);
      add_location(option, file22, 63, 5, 1517);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tickmarks*/
      256 && option_value_value !== (option_value_value = /*tm*/
      ctx2[23])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
      if (dirty & /*tickmarks*/
      256 && option_label_value !== (option_label_value = /*tm*/
      ctx2[23])) {
        attr_dev(option, "label", option_label_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(63:4) {#each tickmarks as tm}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let div;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[15].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_trail_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "range-slider-trail");
      add_location(div, file22, 70, 20, 1636);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_trail_slot_changes4
            ),
            get_trail_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(71:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div1;
  let t0;
  let div0;
  let input;
  let input_class_value;
  let input_list_value;
  let t1;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[12].default && create_if_block_27(ctx)
  );
  let input_levels = [
    { type: "range" },
    { id: (
      /*id*/
      ctx[2]
    ) },
    { name: (
      /*name*/
      ctx[1]
    ) },
    {
      class: input_class_value = "range-slider-input " + /*classesInput*/
      ctx[9]
    },
    {
      list: input_list_value = "tickmarks-" + /*id*/
      ctx[2]
    },
    { "aria-label": (
      /*label*/
      ctx[7]
    ) },
    { min: (
      /*min*/
      ctx[3]
    ) },
    { max: (
      /*max*/
      ctx[4]
    ) },
    { step: (
      /*step*/
      ctx[5]
    ) },
    /*prunedRestProps*/
    ctx[11]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = (
    /*ticked*/
    ctx[6] && /*tickmarks*/
    ctx[8] && /*tickmarks*/
    ctx[8].length && create_if_block_19(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[12].trail && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true,
        list: true,
        "aria-label": true,
        min: true,
        max: true,
        step: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file22, 42, 2, 1111);
      attr_dev(div0, "class", div0_class_value = "range-content " + cBaseContent);
      add_location(div0, file22, 40, 1, 1049);
      attr_dev(div1, "class", div1_class_value = "range-slider " + /*classesBase*/
      ctx[10]);
      attr_dev(div1, "data-testid", "range-slider");
      add_location(div1, file22, 35, 0, 837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[12].default
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_27(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "range" },
        (!current || dirty & /*id*/
        4) && { id: (
          /*id*/
          ctx2[2]
        ) },
        (!current || dirty & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty & /*classesInput*/
        512 && input_class_value !== (input_class_value = "range-slider-input " + /*classesInput*/
        ctx2[9])) && { class: input_class_value },
        (!current || dirty & /*id*/
        4 && input_list_value !== (input_list_value = "tickmarks-" + /*id*/
        ctx2[2])) && { list: input_list_value },
        (!current || dirty & /*label*/
        128) && { "aria-label": (
          /*label*/
          ctx2[7]
        ) },
        (!current || dirty & /*min*/
        8) && { min: (
          /*min*/
          ctx2[3]
        ) },
        (!current || dirty & /*max*/
        16) && { max: (
          /*max*/
          ctx2[4]
        ) },
        (!current || dirty & /*step*/
        32) && { step: (
          /*step*/
          ctx2[5]
        ) },
        /*prunedRestProps*/
        ctx2[11]()
      ]));
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (
        /*ticked*/
        ctx2[6] && /*tickmarks*/
        ctx2[8] && /*tickmarks*/
        ctx2[8].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_19(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$$slots*/
        ctx2[12].trail
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block15(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      1024 && div1_class_value !== (div1_class_value = "range-slider " + /*classesBase*/
      ctx2[10])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase16 = "space-y-2";
var cBaseLabel = "";
var cBaseContent = "flex justify-center py-2";
var cBaseInput = "w-full h-2";
function instance22($$self, $$props, $$invalidate) {
  let classesBase;
  let classesInput;
  const omit_props_names = ["name", "id", "value", "min", "max", "step", "ticked", "accent", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RangeSlider", slots, ["default", "trail"]);
  const $$slots = compute_slots(slots);
  let { name } = $$props;
  let { id = String(Math.random()) } = $$props;
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { ticked = false } = $$props;
  let { accent = "accent-surface-900 dark:accent-surface-50" } = $$props;
  let { label = "" } = $$props;
  let tickmarks;
  function setTicks() {
    if (ticked == false)
      return;
    $$invalidate(8, tickmarks = Array.from({ length: max - min + 1 }, (_, i) => i + min));
  }
  if (ticked)
    setTicks();
  afterUpdate(() => {
    setTicks();
  });
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<RangeSlider> was created without expected prop 'name'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(3, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(4, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(5, step = $$new_props.step);
    if ("ticked" in $$new_props)
      $$invalidate(6, ticked = $$new_props.ticked);
    if ("accent" in $$new_props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    name,
    id,
    value,
    min,
    max,
    step,
    ticked,
    accent,
    label,
    cBase: cBase16,
    cBaseLabel,
    cBaseContent,
    cBaseInput,
    tickmarks,
    setTicks,
    prunedRestProps,
    classesInput,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(3, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(4, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(5, step = $$new_props.step);
    if ("ticked" in $$props)
      $$invalidate(6, ticked = $$new_props.ticked);
    if ("accent" in $$props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("tickmarks" in $$props)
      $$invalidate(8, tickmarks = $$new_props.tickmarks);
    if ("classesInput" in $$props)
      $$invalidate(9, classesInput = $$new_props.classesInput);
    if ("classesBase" in $$props)
      $$invalidate(10, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, classesBase = `${cBase16} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*accent*/
    8192) {
      $:
        $$invalidate(9, classesInput = `${cBaseInput} ${accent}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    name,
    id,
    min,
    max,
    step,
    ticked,
    label,
    tickmarks,
    classesInput,
    classesBase,
    prunedRestProps,
    $$slots,
    accent,
    $$scope,
    slots,
    click_handler,
    change_handler,
    blur_handler,
    input_change_input_handler
  ];
}
var RangeSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      name: 1,
      id: 2,
      value: 0,
      min: 3,
      max: 4,
      step: 5,
      ticked: 6,
      accent: 13,
      label: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RangeSlider",
      options,
      id: create_fragment22.name
    });
  }
  get name() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticked() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticked(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RangeSlider_default = RangeSlider;

// node_modules/@skeletonlabs/skeleton/dist/components/SlideToggle/SlideToggle.svelte
var file23 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\SlideToggle\\SlideToggle.svelte";
function create_if_block16(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slide-toggle-text ml-3");
      add_location(div, file23, 88, 23, 2466);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(89:2) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div2;
  let label_1;
  let input;
  let input_disabled_value;
  let t0;
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let t1;
  let label_1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    /*prunedRestProps*/
    ctx[8](),
    {
      disabled: input_disabled_value = /*$$props*/
      ctx[9].disabled
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[10].default && create_if_block16(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      label_1 = element("label");
      input = element("input");
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        tabindex: true
      });
      var div2_nodes = children(div2);
      label_1 = claim_element(div2_nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { type: true, class: true, name: true });
      t0 = claim_space(label_1_nodes);
      div1 = claim_element(label_1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(label_1_nodes);
      if (if_block)
        if_block.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file23, 67, 2, 1940);
      attr_dev(div0, "class", div0_class_value = "slide-toggle-thumb " + /*classesThumb*/
      ctx[3]);
      toggle_class(
        div0,
        "cursor-not-allowed",
        /*$$props*/
        ctx[9].disabled
      );
      add_location(div0, file23, 85, 3, 2323);
      attr_dev(div1, "class", div1_class_value = "slide-toggle-track " + /*classesTrack*/
      ctx[4]);
      toggle_class(
        div1,
        "cursor-not-allowed",
        /*$$props*/
        ctx[9].disabled
      );
      add_location(div1, file23, 84, 2, 2228);
      attr_dev(label_1, "class", label_1_class_value = "slide-toggle-label " + /*classesLabel*/
      ctx[5]);
      add_location(label_1, file23, 65, 1, 1864);
      attr_dev(
        div2,
        "id",
        /*label*/
        ctx[2]
      );
      attr_dev(div2, "class", div2_class_value = "slide-toggle " + /*classesBase*/
      ctx[6]);
      attr_dev(div2, "data-testid", "slide-toggle");
      attr_dev(div2, "role", "switch");
      attr_dev(
        div2,
        "aria-label",
        /*label*/
        ctx[2]
      );
      attr_dev(
        div2,
        "aria-checked",
        /*checked*/
        ctx[0]
      );
      attr_dev(div2, "tabindex", "0");
      add_location(div2, file23, 55, 0, 1683);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label_1);
      append_hydration_dev(label_1, input);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      append_hydration_dev(label_1, t0);
      append_hydration_dev(label_1, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(label_1, t1);
      if (if_block)
        if_block.m(label_1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[31]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseover",
            /*mouseover_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "keydown",
            /*onKeyDown*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        /*prunedRestProps*/
        ctx2[8](),
        (!current || dirty[0] & /*$$props*/
        512 && input_disabled_value !== (input_disabled_value = /*$$props*/
        ctx2[9].disabled)) && { disabled: input_disabled_value }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (!current || dirty[0] & /*classesThumb*/
      8 && div0_class_value !== (div0_class_value = "slide-toggle-thumb " + /*classesThumb*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesThumb, $$props*/
      520) {
        toggle_class(
          div0,
          "cursor-not-allowed",
          /*$$props*/
          ctx2[9].disabled
        );
      }
      if (!current || dirty[0] & /*classesTrack*/
      16 && div1_class_value !== (div1_class_value = "slide-toggle-track " + /*classesTrack*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesTrack, $$props*/
      528) {
        toggle_class(
          div1,
          "cursor-not-allowed",
          /*$$props*/
          ctx2[9].disabled
        );
      }
      if (
        /*$$slots*/
        ctx2[10].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesLabel*/
      32 && label_1_class_value !== (label_1_class_value = "slide-toggle-label " + /*classesLabel*/
      ctx2[5])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty[0] & /*label*/
      4) {
        attr_dev(
          div2,
          "id",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*classesBase*/
      64 && div2_class_value !== (div2_class_value = "slide-toggle " + /*classesBase*/
      ctx2[6])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*label*/
      4) {
        attr_dev(
          div2,
          "aria-label",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        attr_dev(
          div2,
          "aria-checked",
          /*checked*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase17 = "inline-block";
var cLabel5 = "unstyled flex items-center";
var cTrack2 = "flex transition-all duration-[200ms] cursor-pointer";
var cThumb = "w-[50%] h-full scale-[0.8] transition-all duration-[200ms] shadow";
function instance23($$self, $$props, $$invalidate) {
  let cTrackActive;
  let cThumbBackground;
  let cThumbPos;
  let classesDisabled;
  let classesBase;
  let classesLabel;
  let classesTrack;
  let classesThumb;
  const omit_props_names = ["name", "checked", "size", "background", "active", "border", "rounded", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlideToggle", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { name } = $$props;
  let { checked = false } = $$props;
  let { size = "md" } = $$props;
  let { background = "bg-surface-400 dark:bg-surface-700" } = $$props;
  let { active = "bg-surface-900 dark:bg-surface-300" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { label = "" } = $$props;
  let trackSize;
  switch (size) {
    case "sm":
      trackSize = "w-12 h-6";
      break;
    case "lg":
      trackSize = "w-20 h-10";
      break;
    default:
      trackSize = "w-16 h-8";
  }
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      dispatch("keyup", event);
      const inputElem = event.currentTarget.firstChild;
      inputElem.click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<SlideToggle> was created without expected prop 'name'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$new_props)
      $$invalidate(11, size = $$new_props.size);
    if ("background" in $$new_props)
      $$invalidate(12, background = $$new_props.background);
    if ("active" in $$new_props)
      $$invalidate(13, active = $$new_props.active);
    if ("border" in $$new_props)
      $$invalidate(14, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    name,
    checked,
    size,
    background,
    active,
    border,
    rounded,
    label,
    cBase: cBase17,
    cLabel: cLabel5,
    cTrack: cTrack2,
    cThumb,
    trackSize,
    onKeyDown: onKeyDown2,
    prunedRestProps,
    cThumbPos,
    cThumbBackground,
    classesThumb,
    cTrackActive,
    classesTrack,
    classesLabel,
    classesDisabled,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$props)
      $$invalidate(11, size = $$new_props.size);
    if ("background" in $$props)
      $$invalidate(12, background = $$new_props.background);
    if ("active" in $$props)
      $$invalidate(13, active = $$new_props.active);
    if ("border" in $$props)
      $$invalidate(14, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("trackSize" in $$props)
      $$invalidate(16, trackSize = $$new_props.trackSize);
    if ("cThumbPos" in $$props)
      $$invalidate(17, cThumbPos = $$new_props.cThumbPos);
    if ("cThumbBackground" in $$props)
      $$invalidate(18, cThumbBackground = $$new_props.cThumbBackground);
    if ("classesThumb" in $$props)
      $$invalidate(3, classesThumb = $$new_props.classesThumb);
    if ("cTrackActive" in $$props)
      $$invalidate(19, cTrackActive = $$new_props.cTrackActive);
    if ("classesTrack" in $$props)
      $$invalidate(4, classesTrack = $$new_props.classesTrack);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("classesDisabled" in $$props)
      $$invalidate(20, classesDisabled = $$new_props.classesDisabled);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*checked, active, background*/
    12289) {
      $:
        $$invalidate(19, cTrackActive = checked ? active : `${background} cursor-pointer`);
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $:
        $$invalidate(18, cThumbBackground = checked ? "bg-white/75" : "bg-white");
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $:
        $$invalidate(17, cThumbPos = checked ? "translate-x-full" : "");
    }
    $:
      $$invalidate(20, classesDisabled = $$props.disabled === true ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer");
    $:
      $$invalidate(6, classesBase = `${cBase17} ${rounded} ${classesDisabled} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*border, rounded, trackSize, cTrackActive*/
    638976) {
      $:
        $$invalidate(4, classesTrack = `${cTrack2} ${border} ${rounded} ${trackSize} ${cTrackActive}`);
    }
    if ($$self.$$.dirty[0] & /*rounded, cThumbBackground, cThumbPos*/
    425984) {
      $:
        $$invalidate(3, classesThumb = `${cThumb} ${rounded} ${cThumbBackground} ${cThumbPos}`);
    }
  };
  $:
    $$invalidate(5, classesLabel = `${cLabel5}`);
  $$props = exclude_internal_props($$props);
  return [
    checked,
    name,
    label,
    classesThumb,
    classesTrack,
    classesLabel,
    classesBase,
    onKeyDown2,
    prunedRestProps,
    $$props,
    $$slots,
    size,
    background,
    active,
    border,
    rounded,
    trackSize,
    cThumbPos,
    cThumbBackground,
    cTrackActive,
    classesDisabled,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    change_handler,
    focus_handler,
    blur_handler,
    input_change_handler
  ];
}
var SlideToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance23,
      create_fragment23,
      safe_not_equal,
      {
        name: 1,
        checked: 0,
        size: 11,
        background: 12,
        active: 13,
        border: 14,
        rounded: 15,
        label: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlideToggle",
      options,
      id: create_fragment23.name
    });
  }
  get name() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlideToggle_default = SlideToggle;

// node_modules/@skeletonlabs/skeleton/dist/components/Stepper/Stepper.svelte
var file24 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Stepper\\Stepper.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function create_if_block17(ctx) {
  let header;
  let header_class_value;
  let header_transition;
  let current;
  let each_value = Array.from(Array(
    /*$state*/
    ctx[2].total
  ).keys());
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      header = element("header");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(header_nodes);
      }
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "stepper-header " + /*classesHeader*/
      ctx[6]);
      add_location(header, file24, 58, 2, 2132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(header, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*classesHeaderStep, isActive, $state, classesBadge, stepTerm*/
      55) {
        each_value = Array.from(Array(
          /*$state*/
          ctx2[2].total
        ).keys());
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(header, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*classesHeader*/
      64 && header_class_value !== (header_class_value = "stepper-header " + /*classesHeader*/
      ctx2[6])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!header_transition)
            header_transition = create_bidirectional_transition(header, fade, { duration: 100 }, true);
          header_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!header_transition)
          header_transition = create_bidirectional_transition(header, fade, { duration: 100 }, false);
        header_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      destroy_each(each_blocks, detaching);
      if (detaching && header_transition)
        header_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(58:1) {#if $state.total}",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let div;
  let span;
  let t0_value = (
    /*isActive*/
    (ctx[1](
      /*step*/
      ctx[30]
    ) ? `${/*stepTerm*/
    ctx[0]} ${/*step*/
    ctx[30] + 1}` : (
      /*step*/
      ctx[30] + 1
    )) + ""
  );
  let t0;
  let span_class_value;
  let t1;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "badge " + /*classesBadge*/
      ctx[4](
        /*step*/
        ctx[30]
      ));
      add_location(span, file24, 61, 5, 2373);
      attr_dev(div, "class", div_class_value = "stepper-header-step " + /*classesHeaderStep*/
      ctx[5]);
      toggle_class(
        div,
        "flex-1",
        /*isActive*/
        ctx[1](
          /*step*/
          ctx[30]
        )
      );
      add_location(div, file24, 60, 4, 2284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*isActive, $state, stepTerm*/
      7 && t0_value !== (t0_value = /*isActive*/
      (ctx2[1](
        /*step*/
        ctx2[30]
      ) ? `${/*stepTerm*/
      ctx2[0]} ${/*step*/
      ctx2[30] + 1}` : (
        /*step*/
        ctx2[30] + 1
      )) + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*classesBadge, $state*/
      20 && span_class_value !== (span_class_value = "badge " + /*classesBadge*/
      ctx2[4](
        /*step*/
        ctx2[30]
      ))) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty[0] & /*classesHeaderStep*/
      32 && div_class_value !== (div_class_value = "stepper-header-step " + /*classesHeaderStep*/
      ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty[0] & /*classesHeaderStep, isActive, $state*/
      38) {
        toggle_class(
          div,
          "flex-1",
          /*isActive*/
          ctx2[1](
            /*step*/
            ctx2[30]
          )
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(60:3) {#each Array.from(Array($state.total).keys()) as step}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div1;
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let current;
  let if_block = (
    /*$state*/
    ctx[2].total && create_if_block17(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "stepper-content " + /*classesContent*/
      ctx[3]);
      add_location(div0, file24, 67, 1, 2537);
      attr_dev(div1, "class", div1_class_value = "stepper " + /*classesBase*/
      ctx[7]);
      attr_dev(div1, "data-testid", "stepper");
      add_location(div1, file24, 55, 0, 2035);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$state*/
        ctx2[2].total
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$state*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesContent*/
      8 && div0_class_value !== (div0_class_value = "stepper-content " + /*classesContent*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      128 && div1_class_value !== (div1_class_value = "stepper " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase18 = "space-y-4";
var cHeader = "flex items-center border-t mt-[15px]";
var cHeaderStep = "-mt-[15px] transition-all duration-300";
var cContent = "";
function instance24($$self, $$props, $$invalidate) {
  let isActive;
  let classesBase;
  let classesHeader;
  let classesHeaderStep;
  let classesBadge;
  let classesContent;
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stepper", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { gap = "gap-4" } = $$props;
  let { stepTerm = "Step" } = $$props;
  let { badge = "variant-filled-surface" } = $$props;
  let { active = "variant-filled" } = $$props;
  let { border = "border-surface-400-500-token" } = $$props;
  let { start = 0 } = $$props;
  let { justify = "justify-between" } = $$props;
  let { buttonBack = "variant-ghost" } = $$props;
  let { buttonBackType = "button" } = $$props;
  let { buttonBackLabel = "&larr; Back" } = $$props;
  let { buttonNext = "variant-filled" } = $$props;
  let { buttonNextType = "button" } = $$props;
  let { buttonNextLabel = "Next &rarr;" } = $$props;
  let { buttonComplete = "variant-filled-primary" } = $$props;
  let { buttonCompleteType = "button" } = $$props;
  let { buttonCompleteLabel = "Complete" } = $$props;
  let { regionHeader = "" } = $$props;
  let { regionContent = "" } = $$props;
  let state = writable({ current: start, total: 0 });
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(2, $state = value));
  setContext("state", state);
  setContext("dispatchParent", dispatch);
  setContext("stepTerm", stepTerm);
  setContext("gap", gap);
  setContext("justify", justify);
  setContext("buttonBack", buttonBack);
  setContext("buttonBackType", buttonBackType);
  setContext("buttonBackLabel", buttonBackLabel);
  setContext("buttonNext", buttonNext);
  setContext("buttonNextType", buttonNextType);
  setContext("buttonNextLabel", buttonNextLabel);
  setContext("buttonComplete", buttonComplete);
  setContext("buttonCompleteType", buttonCompleteType);
  setContext("buttonCompleteLabel", buttonCompleteLabel);
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("gap" in $$new_props)
      $$invalidate(9, gap = $$new_props.gap);
    if ("stepTerm" in $$new_props)
      $$invalidate(0, stepTerm = $$new_props.stepTerm);
    if ("badge" in $$new_props)
      $$invalidate(10, badge = $$new_props.badge);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("border" in $$new_props)
      $$invalidate(12, border = $$new_props.border);
    if ("start" in $$new_props)
      $$invalidate(13, start = $$new_props.start);
    if ("justify" in $$new_props)
      $$invalidate(14, justify = $$new_props.justify);
    if ("buttonBack" in $$new_props)
      $$invalidate(15, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$new_props)
      $$invalidate(16, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$new_props)
      $$invalidate(17, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$new_props)
      $$invalidate(18, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$new_props)
      $$invalidate(19, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$new_props)
      $$invalidate(20, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$new_props)
      $$invalidate(21, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$new_props)
      $$invalidate(22, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$new_props)
      $$invalidate(23, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("regionHeader" in $$new_props)
      $$invalidate(24, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$new_props)
      $$invalidate(25, regionContent = $$new_props.regionContent);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    fade,
    dispatch,
    gap,
    stepTerm,
    badge,
    active,
    border,
    start,
    justify,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    regionHeader,
    regionContent,
    state,
    cBase: cBase18,
    cHeader,
    cHeaderStep,
    cContent,
    classesContent,
    isActive,
    classesBadge,
    classesHeaderStep,
    classesHeader,
    classesBase,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    if ("gap" in $$props)
      $$invalidate(9, gap = $$new_props.gap);
    if ("stepTerm" in $$props)
      $$invalidate(0, stepTerm = $$new_props.stepTerm);
    if ("badge" in $$props)
      $$invalidate(10, badge = $$new_props.badge);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("border" in $$props)
      $$invalidate(12, border = $$new_props.border);
    if ("start" in $$props)
      $$invalidate(13, start = $$new_props.start);
    if ("justify" in $$props)
      $$invalidate(14, justify = $$new_props.justify);
    if ("buttonBack" in $$props)
      $$invalidate(15, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$props)
      $$invalidate(16, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$props)
      $$invalidate(17, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$props)
      $$invalidate(18, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$props)
      $$invalidate(19, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$props)
      $$invalidate(20, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$props)
      $$invalidate(21, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$props)
      $$invalidate(22, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$props)
      $$invalidate(23, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("regionHeader" in $$props)
      $$invalidate(24, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$props)
      $$invalidate(25, regionContent = $$new_props.regionContent);
    if ("state" in $$props)
      $$invalidate(8, state = $$new_props.state);
    if ("classesContent" in $$props)
      $$invalidate(3, classesContent = $$new_props.classesContent);
    if ("isActive" in $$props)
      $$invalidate(1, isActive = $$new_props.isActive);
    if ("classesBadge" in $$props)
      $$invalidate(4, classesBadge = $$new_props.classesBadge);
    if ("classesHeaderStep" in $$props)
      $$invalidate(5, classesHeaderStep = $$new_props.classesHeaderStep);
    if ("classesHeader" in $$props)
      $$invalidate(6, classesHeader = $$new_props.classesHeader);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$state*/
    4) {
      $:
        $$invalidate(1, isActive = (step) => step === $state.current);
    }
    $:
      $$invalidate(7, classesBase = `${cBase18} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*border, gap, regionHeader*/
    16781824) {
      $:
        $$invalidate(6, classesHeader = `${cHeader} ${border} ${gap} ${regionHeader}`);
    }
    if ($$self.$$.dirty[0] & /*isActive, active, badge*/
    3074) {
      $:
        $$invalidate(4, classesBadge = (step) => isActive(step) ? active : badge);
    }
    if ($$self.$$.dirty[0] & /*regionContent*/
    33554432) {
      $:
        $$invalidate(3, classesContent = `${cContent} ${regionContent}`);
    }
  };
  $:
    $$invalidate(5, classesHeaderStep = `${cHeaderStep}`);
  $$props = exclude_internal_props($$props);
  return [
    stepTerm,
    isActive,
    $state,
    classesContent,
    classesBadge,
    classesHeaderStep,
    classesHeader,
    classesBase,
    state,
    gap,
    badge,
    active,
    border,
    start,
    justify,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    regionHeader,
    regionContent,
    $$scope,
    slots
  ];
}
var Stepper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance24,
      create_fragment24,
      safe_not_equal,
      {
        gap: 9,
        stepTerm: 0,
        badge: 10,
        active: 11,
        border: 12,
        start: 13,
        justify: 14,
        buttonBack: 15,
        buttonBackType: 16,
        buttonBackLabel: 17,
        buttonNext: 18,
        buttonNextType: 19,
        buttonNextLabel: 20,
        buttonComplete: 21,
        buttonCompleteType: 22,
        buttonCompleteLabel: 23,
        regionHeader: 24,
        regionContent: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stepper",
      options,
      id: create_fragment24.name
    });
  }
  get gap() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepTerm() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepTerm(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badge() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badge(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBack() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBack(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackLabel() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackLabel(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNext() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNext(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextLabel() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextLabel(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonComplete() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonComplete(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteLabel() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteLabel(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionContent() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionContent(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stepper_default = Stepper;

// node_modules/@skeletonlabs/skeleton/dist/components/Stepper/Step.svelte
var file25 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Stepper\\Step.svelte";
var get_navigation_slot_changes = (dirty) => ({});
var get_navigation_slot_context = (ctx) => ({});
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
function create_if_block18(ctx) {
  let div1;
  let header;
  let header_class_value;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[29].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_header_slot_context2
  );
  const header_slot_or_fallback = header_slot || fallback_block_13(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block5(ctx);
  let if_block = (
    /*$state*/
    ctx[16].total > 1 && create_if_block_110(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      header = element("header");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t0 = space();
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      header = claim_element(div1_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (header_slot_or_fallback)
        header_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "step-header " + /*classesHeader*/
      ctx[14]);
      add_location(header, file25, 59, 2, 2165);
      attr_dev(div0, "class", div0_class_value = "step-content " + /*classesContent*/
      ctx[13]);
      add_location(div0, file25, 63, 2, 2306);
      attr_dev(div1, "class", div1_class_value = "step " + /*classesBase*/
      ctx[15]);
      attr_dev(div1, "data-testid", "step");
      add_location(div1, file25, 57, 1, 2087);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, header);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(header, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & /*stepTerm*/
        4)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*classesHeader*/
      16384 && header_class_value !== (header_class_value = "step-header " + /*classesHeader*/
      ctx2[14])) {
        attr_dev(header, "class", header_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*stepTerm*/
        4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*classesContent*/
      8192 && div0_class_value !== (div0_class_value = "step-content " + /*classesContent*/
      ctx2[13])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$state*/
        ctx2[16].total > 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$state*/
          65536) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_110(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      32768 && div1_class_value !== (div1_class_value = "step " + /*classesBase*/
      ctx2[15])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(57:0) {#if stepIndex === $state.current}",
    ctx
  });
  return block;
}
function fallback_block_13(ctx) {
  let t0;
  let t1;
  let t2_value = (
    /*stepIndex*/
    ctx[17] + 1 + ""
  );
  let t2;
  const block = {
    c: function create() {
      t0 = text(
        /*stepTerm*/
        ctx[2]
      );
      t1 = space();
      t2 = text(t2_value);
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*stepTerm*/
        ctx[2]
      );
      t1 = claim_space(nodes);
      t2 = claim_text(nodes, t2_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*stepTerm*/
      4)
        set_data_dev(
          t0,
          /*stepTerm*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_13.name,
    type: "fallback",
    source: "(61:23) {stepTerm}",
    ctx
  });
  return block;
}
function fallback_block5(ctx) {
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*stepIndex*/
    ctx[17] + 1 + ""
  );
  let t3;
  let t4;
  const block = {
    c: function create() {
      t0 = text("(");
      t1 = text(
        /*stepTerm*/
        ctx[2]
      );
      t2 = space();
      t3 = text(t3_value);
      t4 = text(" Content)");
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "(");
      t1 = claim_text(
        nodes,
        /*stepTerm*/
        ctx[2]
      );
      t2 = claim_space(nodes);
      t3 = claim_text(nodes, t3_value);
      t4 = claim_text(nodes, " Content)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, t4, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*stepTerm*/
      4)
        set_data_dev(
          t1,
          /*stepTerm*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
      if (detaching)
        detach_dev(t3);
      if (detaching)
        detach_dev(t4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(65:9) (",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let div_class_value;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_44, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*stepIndex*/
      ctx2[17] === 0 && /*$$slots*/
      ctx2[21].navigation
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_1(ctx2, dirty) {
    if (
      /*stepIndex*/
      ctx2[17] < /*$state*/
      ctx2[16].total - 1
    )
      return create_if_block_28;
    return create_else_block6;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "step-navigation " + /*classesNavigation*/
      ctx[12]);
      add_location(div, file25, 68, 3, 2462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
      if (!current || dirty & /*classesNavigation*/
      4096 && div_class_value !== (div_class_value = "step-navigation " + /*classesNavigation*/
      ctx2[12])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, { duration: 100 }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: 100 }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if_block1.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(68:2) {#if $state.total > 1}",
    ctx
  });
  return block;
}
function create_else_block_12(ctx) {
  let button;
  let button_class_value;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "type",
        /*buttonBackType*/
        ctx[4]
      );
      attr_dev(button, "class", button_class_value = "btn " + /*buttonBack*/
      ctx[3]);
      button.disabled = button_disabled_value = /*$state*/
      ctx[16].current === 0;
      add_location(button, file25, 76, 5, 2762);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonBackLabel*/
      ctx[5];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onBack*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*buttonBackLabel*/
      32)
        button.innerHTML = /*buttonBackLabel*/
        ctx2[5];
      ;
      if (dirty & /*buttonBackType*/
      16) {
        attr_dev(
          button,
          "type",
          /*buttonBackType*/
          ctx2[4]
        );
      }
      if (dirty & /*buttonBack*/
      8 && button_class_value !== (button_class_value = "btn " + /*buttonBack*/
      ctx2[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*$state*/
      65536 && button_disabled_value !== (button_disabled_value = /*$state*/
      ctx2[16].current === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(75:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let div;
  let current;
  const navigation_slot_template = (
    /*#slots*/
    ctx[29].navigation
  );
  const navigation_slot = create_slot(
    navigation_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_navigation_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (navigation_slot)
        navigation_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (navigation_slot)
        navigation_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "step-navigation-slot");
      add_location(div, file25, 71, 5, 2638);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (navigation_slot) {
        navigation_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (navigation_slot) {
        if (navigation_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            navigation_slot,
            navigation_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              navigation_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_navigation_slot_changes
            ),
            get_navigation_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navigation_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navigation_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (navigation_slot)
        navigation_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(70:4) {#if stepIndex === 0 && $$slots.navigation}",
    ctx
  });
  return block;
}
function create_else_block6(ctx) {
  let button;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "type",
        /*buttonCompleteType*/
        ctx[10]
      );
      attr_dev(button, "class", button_class_value = "btn " + /*buttonComplete*/
      ctx[9]);
      button.disabled = /*locked*/
      ctx[0];
      add_location(button, file25, 94, 5, 3584);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonCompleteLabel*/
      ctx[11];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onComplete*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*buttonCompleteLabel*/
      2048)
        button.innerHTML = /*buttonCompleteLabel*/
        ctx2[11];
      ;
      if (dirty & /*buttonCompleteType*/
      1024) {
        attr_dev(
          button,
          "type",
          /*buttonCompleteType*/
          ctx2[10]
        );
      }
      if (dirty & /*buttonComplete*/
      512 && button_class_value !== (button_class_value = "btn " + /*buttonComplete*/
      ctx2[9])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*locked*/
      1) {
        prop_dev(
          button,
          "disabled",
          /*locked*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(93:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let button;
  let t;
  let span;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*locked*/
    ctx[0] && create_if_block_34(ctx)
  );
  const block = {
    c: function create() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file25, 90, 6, 3484);
      attr_dev(
        button,
        "type",
        /*buttonNextType*/
        ctx[7]
      );
      attr_dev(button, "class", button_class_value = "btn " + /*buttonNext*/
      ctx[6]);
      button.disabled = /*locked*/
      ctx[0];
      add_location(button, file25, 82, 5, 2994);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration_dev(button, t);
      append_hydration_dev(button, span);
      span.innerHTML = /*buttonNextLabel*/
      ctx[8];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onNext*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*locked*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_34(ctx2);
          if_block.c();
          if_block.m(button, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*buttonNextLabel*/
      256)
        span.innerHTML = /*buttonNextLabel*/
        ctx2[8];
      ;
      if (dirty & /*buttonNextType*/
      128) {
        attr_dev(
          button,
          "type",
          /*buttonNextType*/
          ctx2[7]
        );
      }
      if (dirty & /*buttonNext*/
      64 && button_class_value !== (button_class_value = "btn " + /*buttonNext*/
      ctx2[6])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*locked*/
      1) {
        prop_dev(
          button,
          "disabled",
          /*locked*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(81:4) {#if stepIndex < $state.total - 1}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z");
      add_location(path, file25, 85, 8, 3209);
      attr_dev(svg, "class", "w-3 aspect-square");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      add_location(svg, file25, 84, 7, 3112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(84:6) {#if locked}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*stepIndex*/
    ctx[17] === /*$state*/
    ctx[16].current && create_if_block18(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*stepIndex*/
        ctx2[17] === /*$state*/
        ctx2[16].current
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$state*/
          65536) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase19 = "space-y-4";
var cHeader2 = "text-2xl font-bold";
var cContent2 = "space-y-4";
var cNavigation = "flex";
function instance25($$self, $$props, $$invalidate) {
  let classesBase;
  let classesHeader;
  let classesContent;
  let classesNavigation;
  let $state, $$unsubscribe_state = noop, $$subscribe_state = () => ($$unsubscribe_state(), $$unsubscribe_state = subscribe(state, ($$value) => $$invalidate(16, $state = $$value)), state);
  $$self.$$.on_destroy.push(() => $$unsubscribe_state());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Step", slots, ["header", "default", "navigation"]);
  const $$slots = compute_slots(slots);
  let { locked = false } = $$props;
  let { regionHeader = "" } = $$props;
  let { regionContent = "" } = $$props;
  let { regionNavigation = "" } = $$props;
  let { state = getContext("state") } = $$props;
  validate_store(state, "state");
  $$subscribe_state();
  let { dispatchParent = getContext("dispatchParent") } = $$props;
  let { stepTerm = getContext("stepTerm") } = $$props;
  let { gap = getContext("gap") } = $$props;
  let { justify = getContext("justify") } = $$props;
  let { buttonBack = getContext("buttonBack") } = $$props;
  let { buttonBackType = getContext("buttonBackType") } = $$props;
  let { buttonBackLabel = getContext("buttonBackLabel") } = $$props;
  let { buttonNext = getContext("buttonNext") } = $$props;
  let { buttonNextType = getContext("buttonNextType") } = $$props;
  let { buttonNextLabel = getContext("buttonNextLabel") } = $$props;
  let { buttonComplete = getContext("buttonComplete") } = $$props;
  let { buttonCompleteType = getContext("buttonCompleteType") } = $$props;
  let { buttonCompleteLabel = getContext("buttonCompleteLabel") } = $$props;
  const stepIndex = $state.total;
  set_store_value(state, $state.total++, $state);
  async function onNext() {
    await new Promise((resolve) => setTimeout(resolve));
    if (locked)
      return;
    set_store_value(state, $state.current++, $state);
    dispatchParent("next", { step: stepIndex, state: $state });
    dispatchParent("step", { step: stepIndex, state: $state });
  }
  function onBack() {
    set_store_value(state, $state.current--, $state);
    dispatchParent("back", { step: stepIndex, state: $state });
    dispatchParent("step", { step: stepIndex, state: $state });
  }
  function onComplete() {
    dispatchParent("complete", { step: stepIndex, state: $state });
  }
  onDestroy(() => {
    set_store_value(state, $state.total--, $state);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("locked" in $$new_props)
      $$invalidate(0, locked = $$new_props.locked);
    if ("regionHeader" in $$new_props)
      $$invalidate(22, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$new_props)
      $$invalidate(23, regionContent = $$new_props.regionContent);
    if ("regionNavigation" in $$new_props)
      $$invalidate(24, regionNavigation = $$new_props.regionNavigation);
    if ("state" in $$new_props)
      $$subscribe_state($$invalidate(1, state = $$new_props.state));
    if ("dispatchParent" in $$new_props)
      $$invalidate(25, dispatchParent = $$new_props.dispatchParent);
    if ("stepTerm" in $$new_props)
      $$invalidate(2, stepTerm = $$new_props.stepTerm);
    if ("gap" in $$new_props)
      $$invalidate(26, gap = $$new_props.gap);
    if ("justify" in $$new_props)
      $$invalidate(27, justify = $$new_props.justify);
    if ("buttonBack" in $$new_props)
      $$invalidate(3, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$new_props)
      $$invalidate(4, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$new_props)
      $$invalidate(5, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$new_props)
      $$invalidate(6, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$new_props)
      $$invalidate(7, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$new_props)
      $$invalidate(8, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$new_props)
      $$invalidate(9, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$new_props)
      $$invalidate(10, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$new_props)
      $$invalidate(11, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    fade,
    locked,
    regionHeader,
    regionContent,
    regionNavigation,
    state,
    dispatchParent,
    stepTerm,
    gap,
    justify,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    stepIndex,
    cBase: cBase19,
    cHeader: cHeader2,
    cContent: cContent2,
    cNavigation,
    onNext,
    onBack,
    onComplete,
    classesNavigation,
    classesContent,
    classesHeader,
    classesBase,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
    if ("locked" in $$props)
      $$invalidate(0, locked = $$new_props.locked);
    if ("regionHeader" in $$props)
      $$invalidate(22, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$props)
      $$invalidate(23, regionContent = $$new_props.regionContent);
    if ("regionNavigation" in $$props)
      $$invalidate(24, regionNavigation = $$new_props.regionNavigation);
    if ("state" in $$props)
      $$subscribe_state($$invalidate(1, state = $$new_props.state));
    if ("dispatchParent" in $$props)
      $$invalidate(25, dispatchParent = $$new_props.dispatchParent);
    if ("stepTerm" in $$props)
      $$invalidate(2, stepTerm = $$new_props.stepTerm);
    if ("gap" in $$props)
      $$invalidate(26, gap = $$new_props.gap);
    if ("justify" in $$props)
      $$invalidate(27, justify = $$new_props.justify);
    if ("buttonBack" in $$props)
      $$invalidate(3, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$props)
      $$invalidate(4, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$props)
      $$invalidate(5, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$props)
      $$invalidate(6, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$props)
      $$invalidate(7, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$props)
      $$invalidate(8, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$props)
      $$invalidate(9, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$props)
      $$invalidate(10, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$props)
      $$invalidate(11, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("classesNavigation" in $$props)
      $$invalidate(12, classesNavigation = $$new_props.classesNavigation);
    if ("classesContent" in $$props)
      $$invalidate(13, classesContent = $$new_props.classesContent);
    if ("classesHeader" in $$props)
      $$invalidate(14, classesHeader = $$new_props.classesHeader);
    if ("classesBase" in $$props)
      $$invalidate(15, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(15, classesBase = `${cBase19} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*regionHeader*/
    4194304) {
      $:
        $$invalidate(14, classesHeader = `${cHeader2} ${regionHeader}`);
    }
    if ($$self.$$.dirty & /*regionContent*/
    8388608) {
      $:
        $$invalidate(13, classesContent = `${cContent2} ${regionContent}`);
    }
    if ($$self.$$.dirty & /*justify, gap, regionNavigation*/
    218103808) {
      $:
        $$invalidate(12, classesNavigation = `${cNavigation} ${justify} ${gap} ${regionNavigation}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    locked,
    state,
    stepTerm,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    classesNavigation,
    classesContent,
    classesHeader,
    classesBase,
    $state,
    stepIndex,
    onNext,
    onBack,
    onComplete,
    $$slots,
    regionHeader,
    regionContent,
    regionNavigation,
    dispatchParent,
    gap,
    justify,
    $$scope,
    slots
  ];
}
var Step = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      locked: 0,
      regionHeader: 22,
      regionContent: 23,
      regionNavigation: 24,
      state: 1,
      dispatchParent: 25,
      stepTerm: 2,
      gap: 26,
      justify: 27,
      buttonBack: 3,
      buttonBackType: 4,
      buttonBackLabel: 5,
      buttonNext: 6,
      buttonNextType: 7,
      buttonNextLabel: 8,
      buttonComplete: 9,
      buttonCompleteType: 10,
      buttonCompleteLabel: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Step",
      options,
      id: create_fragment25.name
    });
  }
  get locked() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locked(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionContent() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionContent(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionNavigation() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionNavigation(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispatchParent() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispatchParent(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepTerm() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepTerm(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBack() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBack(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackType() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackType(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackLabel() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackLabel(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNext() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNext(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextType() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextType(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextLabel() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextLabel(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonComplete() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonComplete(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteType() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteType(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteLabel() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteLabel(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Step_default = Step;

// node_modules/@skeletonlabs/skeleton/dist/components/Table/Table.svelte
var file26 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Table\\Table.svelte";
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[24] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[26] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let th;
  let raw_value = (
    /*heading*/
    ctx[27] + ""
  );
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        th,
        "class",
        /*regionHeadCell*/
        ctx[3]
      );
      add_location(th, file26, 46, 5, 1301);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      th.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*heading*/
      ctx2[27] + ""))
        th.innerHTML = raw_value;
      ;
      if (dirty & /*regionHeadCell*/
      8) {
        attr_dev(
          th,
          "class",
          /*regionHeadCell*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(46:4) {#each source.head as heading }",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let td;
  let raw_value = (
    /*cell*/
    (ctx[19] ? (
      /*cell*/
      ctx[19]
    ) : "-") + ""
  );
  let td_aria_colindex_value;
  let td_tabindex_value;
  const block = {
    c: function create() {
      td = element("td");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {
        class: true,
        role: true,
        "aria-colindex": true,
        tabindex: true
      });
      var td_nodes = children(td);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        td,
        "class",
        /*regionCell*/
        ctx[5]
      );
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "aria-colindex", td_aria_colindex_value = /*cellIndex*/
      ctx[26] + 1);
      attr_dev(td, "tabindex", td_tabindex_value = /*cellIndex*/
      ctx[26] === 0 ? 0 : -1);
      add_location(td, file26, 63, 6, 1776);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      td.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*cell*/
      (ctx2[19] ? (
        /*cell*/
        ctx2[19]
      ) : "-") + ""))
        td.innerHTML = raw_value;
      ;
      if (dirty & /*regionCell*/
      32) {
        attr_dev(
          td,
          "class",
          /*regionCell*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(61:5) {#each row as cell, cellIndex}",
    ctx
  });
  return block;
}
function create_each_block_13(ctx) {
  let tr;
  let t;
  let tr_aria_rowindex_value;
  let mounted;
  let dispose;
  let each_value_2 = (
    /*row*/
    ctx[22]
  );
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[15](
        /*rowIndex*/
        ctx[24],
        ...args
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[16](
        /*rowIndex*/
        ctx[24],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { "aria-rowindex": true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "aria-rowindex", tr_aria_rowindex_value = /*rowIndex*/
      ctx[24] + 1);
      add_location(tr, file26, 55, 4, 1531);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
      if (!mounted) {
        dispose = [
          listen_dev(tr, "click", click_handler, false, false, false, false),
          listen_dev(tr, "keydown", keydown_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*regionCell, source*/
      33) {
        each_value_2 = /*row*/
        ctx[22];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(53:3) {#each source.body as row, rowIndex}",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let tfoot;
  let tr;
  let tfoot_class_value;
  let each_value = (
    /*source*/
    ctx[0].foot
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      tfoot = claim_element(nodes, "TFOOT", { class: true });
      var tfoot_nodes = children(tfoot);
      tr = claim_element(tfoot_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      tfoot_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file26, 78, 4, 2092);
      attr_dev(tfoot, "class", tfoot_class_value = "table-foot " + /*regionFoot*/
      ctx[6]);
      add_location(tfoot, file26, 77, 3, 2048);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tfoot, anchor);
      append_hydration_dev(tfoot, tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*regionFootCell, source*/
      129) {
        each_value = /*source*/
        ctx2[0].foot;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*regionFoot*/
      64 && tfoot_class_value !== (tfoot_class_value = "table-foot " + /*regionFoot*/
      ctx2[6])) {
        attr_dev(tfoot, "class", tfoot_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tfoot);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(77:2) {#if source.foot}",
    ctx
  });
  return block;
}
function create_each_block8(ctx) {
  let td;
  let raw_value = (
    /*cell*/
    ctx[19] + ""
  );
  const block = {
    c: function create() {
      td = element("td");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        td,
        "class",
        /*regionFootCell*/
        ctx[7]
      );
      add_location(td, file26, 80, 6, 2137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      td.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*cell*/
      ctx2[19] + ""))
        td.innerHTML = raw_value;
      ;
      if (dirty & /*regionFootCell*/
      128) {
        attr_dev(
          td,
          "class",
          /*regionFootCell*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(80:5) {#each source.foot as cell }",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div;
  let table;
  let thead;
  let tr;
  let thead_class_value;
  let t0;
  let tbody;
  let tbody_class_value;
  let t1;
  let tableA11y_action;
  let div_class_value;
  let mounted;
  let dispose;
  let each_value_3 = (
    /*source*/
    ctx[0].head
  );
  validate_each_argument(each_value_3);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_1 = (
    /*source*/
    ctx[0].body
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  let if_block = (
    /*source*/
    ctx[0].foot && create_if_block19(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true, role: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t0 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      t1 = claim_space(table_nodes);
      if (if_block)
        if_block.l(table_nodes);
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file26, 44, 3, 1255);
      attr_dev(thead, "class", thead_class_value = "table-head " + /*regionHead*/
      ctx[2]);
      add_location(thead, file26, 43, 2, 1212);
      attr_dev(tbody, "class", tbody_class_value = "table-body " + /*regionBody*/
      ctx[4]);
      add_location(tbody, file26, 51, 2, 1401);
      attr_dev(
        table,
        "class",
        /*classesTable*/
        ctx[8]
      );
      attr_dev(table, "role", "grid");
      toggle_class(
        table,
        "table-interactive",
        /*interactive*/
        ctx[1]
      );
      add_location(table, file26, 35, 1, 1029);
      attr_dev(div, "class", div_class_value = "table-container " + /*classesBase*/
      ctx[9]);
      add_location(div, file26, 32, 0, 942);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append_hydration_dev(table, t0);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      append_hydration_dev(table, t1);
      if (if_block)
        if_block.m(table, null);
      if (!mounted) {
        dispose = action_destroyer(tableA11y_action = tableA11y.call(null, table));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*regionHeadCell, source*/
      9) {
        each_value_3 = /*source*/
        ctx2[0].head;
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_3.length;
      }
      if (dirty & /*regionHead*/
      4 && thead_class_value !== (thead_class_value = "table-head " + /*regionHead*/
      ctx2[2])) {
        attr_dev(thead, "class", thead_class_value);
      }
      if (dirty & /*onRowClick, onRowKeydown, source, regionCell*/
      3105) {
        each_value_1 = /*source*/
        ctx2[0].body;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*regionBody*/
      16 && tbody_class_value !== (tbody_class_value = "table-body " + /*regionBody*/
      ctx2[4])) {
        attr_dev(tbody, "class", tbody_class_value);
      }
      if (
        /*source*/
        ctx2[0].foot
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          if_block.m(table, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*classesTable*/
      256) {
        attr_dev(
          table,
          "class",
          /*classesTable*/
          ctx2[8]
        );
      }
      if (dirty & /*classesTable, interactive*/
      258) {
        toggle_class(
          table,
          "table-interactive",
          /*interactive*/
          ctx2[1]
        );
      }
      if (dirty & /*classesBase*/
      512 && div_class_value !== (div_class_value = "table-container " + /*classesBase*/
      ctx2[9])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let classesBase;
  let classesTable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  const dispatch = createEventDispatcher();
  let { source } = $$props;
  let { interactive = false } = $$props;
  let { element: element2 = "table" } = $$props;
  let { text: text2 = "" } = $$props;
  let { color = "" } = $$props;
  let { regionHead = "" } = $$props;
  let { regionHeadCell = "" } = $$props;
  let { regionBody = "" } = $$props;
  let { regionCell = "" } = $$props;
  let { regionFoot = "" } = $$props;
  let { regionFootCell = "" } = $$props;
  function onRowClick(event, rowIndex) {
    if (!interactive)
      return;
    event.preventDefault();
    event.stopPropagation();
    const rowMetaData = source.meta ? source.meta[rowIndex] : source.body[rowIndex];
    dispatch("selected", rowMetaData);
  }
  function onRowKeydown(event, rowIndex) {
    if (["Enter", "Space"].includes(event.code))
      onRowClick(event, rowIndex);
  }
  $$self.$$.on_mount.push(function() {
    if (source === void 0 && !("source" in $$props || $$self.$$.bound[$$self.$$.props["source"]])) {
      console.warn("<Table> was created without expected prop 'source'");
    }
  });
  const click_handler = (rowIndex, e) => {
    onRowClick(e, rowIndex);
  };
  const keydown_handler = (rowIndex, e) => {
    onRowKeydown(e, rowIndex);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("source" in $$new_props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$new_props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$new_props)
      $$invalidate(12, element2 = $$new_props.element);
    if ("text" in $$new_props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("regionHead" in $$new_props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionHeadCell" in $$new_props)
      $$invalidate(3, regionHeadCell = $$new_props.regionHeadCell);
    if ("regionBody" in $$new_props)
      $$invalidate(4, regionBody = $$new_props.regionBody);
    if ("regionCell" in $$new_props)
      $$invalidate(5, regionCell = $$new_props.regionCell);
    if ("regionFoot" in $$new_props)
      $$invalidate(6, regionFoot = $$new_props.regionFoot);
    if ("regionFootCell" in $$new_props)
      $$invalidate(7, regionFootCell = $$new_props.regionFootCell);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tableA11y,
    dispatch,
    source,
    interactive,
    element: element2,
    text: text2,
    color,
    regionHead,
    regionHeadCell,
    regionBody,
    regionCell,
    regionFoot,
    regionFootCell,
    onRowClick,
    onRowKeydown,
    classesTable,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("source" in $$props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$props)
      $$invalidate(12, element2 = $$new_props.element);
    if ("text" in $$props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("regionHead" in $$props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionHeadCell" in $$props)
      $$invalidate(3, regionHeadCell = $$new_props.regionHeadCell);
    if ("regionBody" in $$props)
      $$invalidate(4, regionBody = $$new_props.regionBody);
    if ("regionCell" in $$props)
      $$invalidate(5, regionCell = $$new_props.regionCell);
    if ("regionFoot" in $$props)
      $$invalidate(6, regionFoot = $$new_props.regionFoot);
    if ("regionFootCell" in $$props)
      $$invalidate(7, regionFootCell = $$new_props.regionFootCell);
    if ("classesTable" in $$props)
      $$invalidate(8, classesTable = $$new_props.classesTable);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${$$props.class || ""}`);
    if ($$self.$$.dirty & /*element, text, color*/
    28672) {
      $:
        $$invalidate(8, classesTable = `${element2} ${text2} ${color}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    source,
    interactive,
    regionHead,
    regionHeadCell,
    regionBody,
    regionCell,
    regionFoot,
    regionFootCell,
    classesTable,
    classesBase,
    onRowClick,
    onRowKeydown,
    element2,
    text2,
    color,
    click_handler,
    keydown_handler
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 12,
      text: 13,
      color: 14,
      regionHead: 2,
      regionHeadCell: 3,
      regionBody: 4,
      regionCell: 5,
      regionFoot: 6,
      regionFootCell: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment26.name
    });
  }
  get source() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHead() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHead(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeadCell() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeadCell(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCell() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCell(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFoot() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFoot(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFootCell() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFootCell(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/@skeletonlabs/skeleton/dist/components/Tab/TabGroup.svelte
var file27 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Tab\\TabGroup.svelte";
var get_panel_slot_changes = (dirty) => ({});
var get_panel_slot_context = (ctx) => ({});
function create_if_block20(ctx) {
  let div;
  let div_class_value;
  let current;
  const panel_slot_template = (
    /*#slots*/
    ctx[17].panel
  );
  const panel_slot = create_slot(
    panel_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_panel_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (panel_slot)
        panel_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-labelledby": true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (panel_slot)
        panel_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tab-panel " + /*classesPanel*/
      ctx[2]);
      attr_dev(div, "role", "tabpanel");
      attr_dev(
        div,
        "aria-labelledby",
        /*panel*/
        ctx[1]
      );
      attr_dev(div, "tabindex", "0");
      add_location(div, file27, 39, 2, 1344);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (panel_slot) {
        panel_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (panel_slot) {
        if (panel_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            panel_slot,
            panel_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              panel_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_panel_slot_changes
            ),
            get_panel_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPanel*/
      4 && div_class_value !== (div_class_value = "tab-panel " + /*classesPanel*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*panel*/
      2) {
        attr_dev(
          div,
          "aria-labelledby",
          /*panel*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(panel_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (panel_slot)
        panel_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(39:1) {#if $$slots.panel}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block = (
    /*$$slots*/
    ctx[5].panel && create_if_block20(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "tab-list " + /*classesList*/
      ctx[3]);
      attr_dev(div0, "role", "tablist");
      attr_dev(
        div0,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      add_location(div0, file27, 34, 1, 1201);
      attr_dev(div1, "class", div1_class_value = "tab-group " + /*classesBase*/
      ctx[4]);
      attr_dev(div1, "data-testid", "tab-group");
      add_location(div1, file27, 32, 0, 1078);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesList*/
      8 && div0_class_value !== (div0_class_value = "tab-list " + /*classesList*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div0,
          "aria-labelledby",
          /*labelledby*/
          ctx2[0]
        );
      }
      if (
        /*$$slots*/
        ctx2[5].panel
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      16 && div1_class_value !== (div1_class_value = "tab-group " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase20 = "space-y-4";
var cList = "flex overflow-x-auto hide-scrollbar";
var cPanel2 = "";
function instance27($$self, $$props, $$invalidate) {
  let classesBase;
  let classesList;
  let classesPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabGroup", slots, ["default", "panel"]);
  const $$slots = compute_slots(slots);
  let { justify = "justify-start" } = $$props;
  let { border = "border-b border-surface-400-500-token" } = $$props;
  let { active = "border-b-2 border-surface-900-50-token" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { flex = "flex-none" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { rounded = "rounded-tl-container-token rounded-tr-container-token" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { regionList = "" } = $$props;
  let { regionPanel = "" } = $$props;
  let { labelledby = "" } = $$props;
  let { panel = "" } = $$props;
  setContext("active", active);
  setContext("hover", hover);
  setContext("flex", flex);
  setContext("padding", padding);
  setContext("rounded", rounded);
  setContext("spacing", spacing);
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("justify" in $$new_props)
      $$invalidate(6, justify = $$new_props.justify);
    if ("border" in $$new_props)
      $$invalidate(7, border = $$new_props.border);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("flex" in $$new_props)
      $$invalidate(10, flex = $$new_props.flex);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("spacing" in $$new_props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("regionList" in $$new_props)
      $$invalidate(14, regionList = $$new_props.regionList);
    if ("regionPanel" in $$new_props)
      $$invalidate(15, regionPanel = $$new_props.regionPanel);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("panel" in $$new_props)
      $$invalidate(1, panel = $$new_props.panel);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    justify,
    border,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    regionList,
    regionPanel,
    labelledby,
    panel,
    cBase: cBase20,
    cList,
    cPanel: cPanel2,
    classesPanel,
    classesList,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("justify" in $$props)
      $$invalidate(6, justify = $$new_props.justify);
    if ("border" in $$props)
      $$invalidate(7, border = $$new_props.border);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("flex" in $$props)
      $$invalidate(10, flex = $$new_props.flex);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("spacing" in $$props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("regionList" in $$props)
      $$invalidate(14, regionList = $$new_props.regionList);
    if ("regionPanel" in $$props)
      $$invalidate(15, regionPanel = $$new_props.regionPanel);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("panel" in $$props)
      $$invalidate(1, panel = $$new_props.panel);
    if ("classesPanel" in $$props)
      $$invalidate(2, classesPanel = $$new_props.classesPanel);
    if ("classesList" in $$props)
      $$invalidate(3, classesList = $$new_props.classesList);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${cBase20} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*justify, border, regionList*/
    16576) {
      $:
        $$invalidate(3, classesList = `${cList} ${justify} ${border} ${regionList}`);
    }
    if ($$self.$$.dirty & /*regionPanel*/
    32768) {
      $:
        $$invalidate(2, classesPanel = `${cPanel2} ${regionPanel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    panel,
    classesPanel,
    classesList,
    classesBase,
    $$slots,
    justify,
    border,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    regionList,
    regionPanel,
    $$scope,
    slots,
    click_handler,
    keypress_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TabGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      justify: 6,
      border: 7,
      active: 8,
      hover: 9,
      flex: 10,
      padding: 11,
      rounded: 12,
      spacing: 13,
      regionList: 14,
      regionPanel: 15,
      labelledby: 0,
      panel: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabGroup",
      options,
      id: create_fragment27.name
    });
  }
  get justify() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flex() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flex(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPanel() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPanel(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panel() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panel(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabGroup_default = TabGroup;

// node_modules/@skeletonlabs/skeleton/dist/components/Tab/Tab.svelte
var file28 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Tab\\Tab.svelte";
var get_lead_slot_changes8 = (dirty) => ({});
var get_lead_slot_context8 = (ctx) => ({});
function create_if_block21(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[22].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_lead_slot_context8
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tab-lead");
      add_location(div, file28, 90, 21, 2836);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_lead_slot_changes8
            ),
            get_lead_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(91:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let label;
  let div3;
  let div0;
  let input;
  let t0;
  let div2;
  let t1;
  let div1;
  let div2_class_value;
  let div3_class_value;
  let div3_tabindex_value;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    { __value: (
      /*value*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[11](),
    { tabindex: "-1" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[12].lead && create_if_block21(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[30][0]
  );
  const block = {
    c: function create() {
      label = element("label");
      div3 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, title: true });
      var label_nodes = children(label);
      div3 = claim_element(label_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-controls": true,
        "aria-selected": true,
        tabindex: true
      });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true, tabindex: true });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file28, 86, 3, 2609);
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file28, 85, 2, 2568);
      attr_dev(div1, "class", "tab-label");
      add_location(div1, file28, 91, 3, 2893);
      attr_dev(div2, "class", div2_class_value = "tab-interface " + /*classesInterface*/
      ctx[8]);
      add_location(div2, file28, 89, 2, 2768);
      attr_dev(div3, "class", div3_class_value = "tab " + /*classesTab*/
      ctx[7]);
      attr_dev(div3, "data-testid", "tab");
      attr_dev(div3, "role", "tab");
      attr_dev(
        div3,
        "aria-controls",
        /*controls*/
        ctx[4]
      );
      attr_dev(
        div3,
        "aria-selected",
        /*selected*/
        ctx[5]
      );
      attr_dev(div3, "tabindex", div3_tabindex_value = /*selected*/
      ctx[5] ? 0 : -1);
      add_location(div3, file28, 72, 1, 2273);
      attr_dev(
        label,
        "class",
        /*classesBase*/
        ctx[9]
      );
      attr_dev(
        label,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(label, file28, 70, 0, 2183);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[28](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[29]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*onKeyDown*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keyup",
            /*keyup_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keypress",
            /*keypress_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty[0] & /*value*/
        4) && { __value: (
          /*value*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[11](),
        { tabindex: "-1" }
      ]));
      if (dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (
        /*$$slots*/
        ctx2[12].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesInterface*/
      256 && div2_class_value !== (div2_class_value = "tab-interface " + /*classesInterface*/
      ctx2[8])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesTab*/
      128 && div3_class_value !== (div3_class_value = "tab " + /*classesTab*/
      ctx2[7])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*controls*/
      16) {
        attr_dev(
          div3,
          "aria-controls",
          /*controls*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*selected*/
      32) {
        attr_dev(
          div3,
          "aria-selected",
          /*selected*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*selected*/
      32 && div3_tabindex_value !== (div3_tabindex_value = /*selected*/
      ctx2[5] ? 0 : -1)) {
        attr_dev(div3, "tabindex", div3_tabindex_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      512) {
        attr_dev(
          label,
          "class",
          /*classesBase*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*title*/
      8) {
        attr_dev(
          label,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[28](null);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase21 = "text-center cursor-pointer transition-colors duration-100";
var cInterface4 = "";
function instance28($$self, $$props, $$invalidate) {
  let selected;
  let classesActive;
  let classesBase;
  let classesInterface;
  let classesTab;
  const omit_props_names = [
    "group",
    "name",
    "value",
    "title",
    "controls",
    "regionTab",
    "active",
    "hover",
    "flex",
    "padding",
    "rounded",
    "spacing"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { title = "" } = $$props;
  let { controls = "" } = $$props;
  let { regionTab = "" } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { flex = getContext("flex") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let elemInput;
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemInput.click();
    } else if (event.code === "ArrowRight") {
      const tabList = elemInput.closest(".tab-list");
      if (!tabList)
        return;
      const tabs = Array.from(tabList.querySelectorAll(".tab"));
      const currTab = elemInput.closest(".tab");
      if (!currTab)
        return;
      const currIndex = tabs.indexOf(currTab);
      const nextIndex = currIndex + 1 >= tabs.length ? 0 : currIndex + 1;
      const nextTab = tabs[nextIndex];
      const nextTabInput = nextTab == null ? void 0 : nextTab.querySelector("input");
      if (nextTab && nextTabInput) {
        nextTabInput.click();
        nextTab.focus();
      }
    } else if (event.code === "ArrowLeft") {
      const tabList = elemInput.closest(".tab-list");
      if (!tabList)
        return;
      const tabs = Array.from(tabList.querySelectorAll(".tab"));
      const currTab = elemInput.closest(".tab");
      if (!currTab)
        return;
      const currIndex = tabs.indexOf(currTab);
      const nextIndex = currIndex - 1 < 0 ? tabs.length - 1 : currIndex - 1;
      const nextTab = tabs[nextIndex];
      const nextTabInput = nextTab == null ? void 0 : nextTab.querySelector("input");
      if (nextTab && nextTabInput) {
        nextTabInput.click();
        nextTab.focus();
      }
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<Tab> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Tab> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Tab> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(31, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("controls" in $$new_props)
      $$invalidate(4, controls = $$new_props.controls);
    if ("regionTab" in $$new_props)
      $$invalidate(13, regionTab = $$new_props.regionTab);
    if ("active" in $$new_props)
      $$invalidate(14, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(15, hover = $$new_props.hover);
    if ("flex" in $$new_props)
      $$invalidate(16, flex = $$new_props.flex);
    if ("padding" in $$new_props)
      $$invalidate(17, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(18, rounded = $$new_props.rounded);
    if ("spacing" in $$new_props)
      $$invalidate(19, spacing = $$new_props.spacing);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    title,
    controls,
    regionTab,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    cBase: cBase21,
    cInterface: cInterface4,
    elemInput,
    onKeyDown: onKeyDown2,
    prunedRestProps,
    classesTab,
    classesInterface,
    classesActive,
    classesBase,
    selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("controls" in $$props)
      $$invalidate(4, controls = $$new_props.controls);
    if ("regionTab" in $$props)
      $$invalidate(13, regionTab = $$new_props.regionTab);
    if ("active" in $$props)
      $$invalidate(14, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(15, hover = $$new_props.hover);
    if ("flex" in $$props)
      $$invalidate(16, flex = $$new_props.flex);
    if ("padding" in $$props)
      $$invalidate(17, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(18, rounded = $$new_props.rounded);
    if ("spacing" in $$props)
      $$invalidate(19, spacing = $$new_props.spacing);
    if ("elemInput" in $$props)
      $$invalidate(6, elemInput = $$new_props.elemInput);
    if ("classesTab" in $$props)
      $$invalidate(7, classesTab = $$new_props.classesTab);
    if ("classesInterface" in $$props)
      $$invalidate(8, classesInterface = $$new_props.classesInterface);
    if ("classesActive" in $$props)
      $$invalidate(20, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, group*/
    5) {
      $:
        $$invalidate(5, selected = value === group);
    }
    if ($$self.$$.dirty[0] & /*selected, active, hover*/
    49184) {
      $:
        $$invalidate(20, classesActive = selected ? active : hover);
    }
    $:
      $$invalidate(9, classesBase = `${cBase21} ${flex} ${padding} ${rounded} ${classesActive} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*spacing*/
    524288) {
      $:
        $$invalidate(8, classesInterface = `${cInterface4} ${spacing}`);
    }
    if ($$self.$$.dirty[0] & /*regionTab*/
    8192) {
      $:
        $$invalidate(7, classesTab = `${regionTab}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    title,
    controls,
    selected,
    elemInput,
    classesTab,
    classesInterface,
    classesBase,
    onKeyDown2,
    prunedRestProps,
    $$slots,
    regionTab,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    classesActive,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    input_binding,
    input_change_handler,
    $$binding_groups
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance28,
      create_fragment28,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        controls: 4,
        regionTab: 13,
        active: 14,
        hover: 15,
        flex: 16,
        padding: 17,
        rounded: 18,
        spacing: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment28.name
    });
  }
  get group() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controls(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTab() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTab(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flex() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flex(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@skeletonlabs/skeleton/dist/components/Tab/TabAnchor.svelte
var file29 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\Tab\\TabAnchor.svelte";
var get_lead_slot_changes9 = (dirty) => ({});
var get_lead_slot_context9 = (ctx) => ({});
function create_if_block22(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[15].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_lead_slot_context9
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tab-lead");
      add_location(div, file29, 40, 20, 1060);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_lead_slot_changes9
            ),
            get_lead_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(41:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let a;
  let div1;
  let t;
  let div0;
  let div1_class_value;
  let a_class_value;
  let a_href_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[5].lead && create_if_block22(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let a_levels = [
    {
      class: a_class_value = "tab-anchor " + /*classesBase*/
      ctx[2]
    },
    {
      href: a_href_value = /*$$props*/
      ctx[4].href
    },
    /*prunedRestProps*/
    ctx[3](),
    { "aria-controls": (
      /*controls*/
      ctx[0]
    ) },
    { "data-testid": "tab-anchor" }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        class: true,
        href: true,
        "aria-controls": true,
        "data-testid": true
      });
      var a_nodes = children(a);
      div1 = claim_element(a_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "tab-label");
      add_location(div0, file29, 41, 2, 1116);
      attr_dev(div1, "class", div1_class_value = "tab-interface " + /*classesInterface*/
      ctx[1]);
      add_location(div1, file29, 39, 1, 993);
      set_attributes(a, a_data);
      add_location(a, file29, 23, 0, 743);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[5].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesInterface*/
      2 && div1_class_value !== (div1_class_value = "tab-interface " + /*classesInterface*/
      ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classesBase*/
        4 && a_class_value !== (a_class_value = "tab-anchor " + /*classesBase*/
        ctx2[2])) && { class: a_class_value },
        (!current || dirty & /*$$props*/
        16 && a_href_value !== (a_href_value = /*$$props*/
        ctx2[4].href)) && { href: a_href_value },
        /*prunedRestProps*/
        ctx2[3](),
        (!current || dirty & /*controls*/
        1) && { "aria-controls": (
          /*controls*/
          ctx2[0]
        ) },
        { "data-testid": "tab-anchor" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase22 = "text-center cursor-pointer transition-colors duration-100";
var cInterface5 = "";
function instance29($$self, $$props, $$invalidate) {
  let classesActive;
  let classesBase;
  let classesInterface;
  const omit_props_names = ["selected", "controls", "active", "hover", "flex", "padding", "rounded", "spacing"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabAnchor", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { controls = "" } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { flex = getContext("flex") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(6, selected = $$new_props.selected);
    if ("controls" in $$new_props)
      $$invalidate(0, controls = $$new_props.controls);
    if ("active" in $$new_props)
      $$invalidate(7, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("flex" in $$new_props)
      $$invalidate(9, flex = $$new_props.flex);
    if ("padding" in $$new_props)
      $$invalidate(10, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    selected,
    controls,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    cBase: cBase22,
    cInterface: cInterface5,
    prunedRestProps,
    classesInterface,
    classesActive,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(6, selected = $$new_props.selected);
    if ("controls" in $$props)
      $$invalidate(0, controls = $$new_props.controls);
    if ("active" in $$props)
      $$invalidate(7, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("flex" in $$props)
      $$invalidate(9, flex = $$new_props.flex);
    if ("padding" in $$props)
      $$invalidate(10, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("classesInterface" in $$props)
      $$invalidate(1, classesInterface = $$new_props.classesInterface);
    if ("classesActive" in $$props)
      $$invalidate(13, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(2, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected, active, hover*/
    448) {
      $:
        $$invalidate(13, classesActive = selected ? active : hover);
    }
    $:
      $$invalidate(2, classesBase = `${cBase22} ${flex} ${padding} ${rounded} ${classesActive} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*spacing*/
    4096) {
      $:
        $$invalidate(1, classesInterface = `${cInterface5} ${spacing}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    controls,
    classesInterface,
    classesBase,
    prunedRestProps,
    $$props,
    $$slots,
    selected,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    classesActive,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler
  ];
}
var TabAnchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      selected: 6,
      controls: 0,
      active: 7,
      hover: 8,
      flex: 9,
      padding: 10,
      rounded: 11,
      spacing: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabAnchor",
      options,
      id: create_fragment29.name
    });
  }
  get selected() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controls(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flex() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flex(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabAnchor_default = TabAnchor;

// node_modules/@skeletonlabs/skeleton/dist/components/TableOfContents/TableOfContents.svelte
var file30 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\TableOfContents\\TableOfContents.svelte";
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_if_block23(ctx) {
  let div1;
  let nav;
  let div0;
  let t0;
  let div0_class_value;
  let t1;
  let nav_class_value;
  let div1_class_value;
  let div1_transition;
  let current;
  let each_value = (
    /*filteredHeadingsList*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      nav = element("nav");
      div0 = element("div");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      nav = claim_element(div1_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div0 = claim_element(nav_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*label*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nav_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      nav_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "toc-label " + /*classesLabel*/
      ctx[6]);
      add_location(div0, file30, 93, 3, 3200);
      attr_dev(nav, "class", nav_class_value = "toc-list " + /*classesList*/
      ctx[5]);
      add_location(nav, file30, 92, 2, 3160);
      attr_dev(div1, "class", div1_class_value = "toc " + /*classesBase*/
      ctx[7]);
      add_location(div1, file30, 91, 1, 3084);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, nav);
      append_hydration_dev(nav, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(nav, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(nav, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (!current || dirty & /*classesLabel*/
      64 && div0_class_value !== (div0_class_value = "toc-label " + /*classesLabel*/
      ctx2[6])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*classesListItem, setHeadingClasses, filteredHeadingsList, activeHeaderId, active, scrollToHeading*/
      30) {
        each_value = /*filteredHeadingsList*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(nav, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*classesList*/
      32 && nav_class_value !== (nav_class_value = "toc-list " + /*classesList*/
      ctx2[5])) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (!current || dirty & /*classesBase*/
      128 && div1_class_value !== (div1_class_value = "toc " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, { duration: 100 }, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: 100 }, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      if (detaching && div1_transition)
        div1_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(91:0) {#if filteredHeadingsList.length > 0}",
    ctx
  });
  return block;
}
function create_each_block9(ctx) {
  var _a;
  let li;
  let t0_value = (
    /*headingElem*/
    ((_a = ctx[27].firstChild) == null ? void 0 : _a.nodeValue) + ""
  );
  let t0;
  let t1;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[20](
        /*headingElem*/
        ctx[27]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t0 = claim_text(li_nodes, t0_value);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", li_class_value = "toc-list-item " + /*classesListItem*/
      ctx[4] + " " + setHeadingClasses(
        /*headingElem*/
        ctx[27]
      ) + " " + /*headingElem*/
      (ctx[27].id === /*activeHeaderId*/
      ctx[3] ? (
        /*active*/
        ctx[1]
      ) : ""));
      add_location(li, file30, 98, 4, 3436);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, t1);
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", click_handler_1, false, false, false, false),
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (dirty & /*filteredHeadingsList*/
      4 && t0_value !== (t0_value = /*headingElem*/
      ((_a2 = ctx[27].firstChild) == null ? void 0 : _a2.nodeValue) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*classesListItem, filteredHeadingsList, activeHeaderId, active*/
      30 && li_class_value !== (li_class_value = "toc-list-item " + /*classesListItem*/
      ctx[4] + " " + setHeadingClasses(
        /*headingElem*/
        ctx[27]
      ) + " " + /*headingElem*/
      (ctx[27].id === /*activeHeaderId*/
      ctx[3] ? (
        /*active*/
        ctx[1]
      ) : ""))) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(95:3) {#each filteredHeadingsList as headingElem}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let if_block_anchor;
  let if_block = (
    /*filteredHeadingsList*/
    ctx[2].length > 0 && create_if_block23(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*filteredHeadingsList*/
        ctx2[2].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*filteredHeadingsList*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      transition_in(if_block);
    },
    o: function outro(local) {
      transition_out(if_block);
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cLabel6 = "p-4 pt-0";
var cList2 = "list-none space-y-1";
var cListItem = "px-4 py-2 cursor-pointer";
function setHeadingClasses(headingElem) {
  if (headingElem.tagName === "H3")
    return "ml-3";
  if (headingElem.tagName === "H4")
    return "ml-6";
  if (headingElem.tagName === "H5")
    return "ml-9";
  if (headingElem.tagName === "H6")
    return "ml-12";
  return "";
}
function scrollToHeading(headingElem) {
  const elemTarget = document.querySelector(`#${headingElem.id}`);
  if (elemTarget)
    elemTarget.scrollIntoView({ behavior: "smooth" });
}
function instance30($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLabel;
  let classesList;
  let classesListItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableOfContents", slots, []);
  let { scrollParent = "#page" } = $$props;
  let { target = "#page" } = $$props;
  let { allowedHeadings = "h2, h3" } = $$props;
  let { label = "On This Page" } = $$props;
  let { width = "w-[240px]" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { text: text2 = "text-surface-600-300-token" } = $$props;
  let { hover = "hover:bg-primary-hover-token" } = $$props;
  let { active = "bg-primary-active-token !text-on-primary-token" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { regionLabel = "font-bold" } = $$props;
  let { regionList = "" } = $$props;
  let elemScrollParent;
  let allowedHeadingsList;
  let filteredHeadingsList = [];
  let activeHeaderId;
  function queryAllowedHeadingsList() {
    const elemTarget = document.querySelector(target);
    allowedHeadingsList = elemTarget == null ? void 0 : elemTarget.querySelectorAll(allowedHeadings);
  }
  function generateHeadingList() {
    allowedHeadingsList == null ? void 0 : allowedHeadingsList.forEach((elem) => {
      if (elem.hasAttribute("data-toc-ignore"))
        return;
      if (!elem.id) {
        let newId = elem.innerText.replaceAll(/[^a-zA-Z0-9 ]/g, "").replaceAll(" ", "-").toLowerCase();
        elem.id = `${newId}`;
      }
      if (!elem.querySelector(".permalink")) {
        elem.innerHTML += `<a href="#${elem.id}" class="permalink">🔗</a>`;
      }
      filteredHeadingsList.push(elem);
    });
    $$invalidate(2, filteredHeadingsList = [...filteredHeadingsList]);
  }
  function pageScrollHandler() {
    var _a;
    const headingSizeThreshold = 40;
    let visibleHeadings = [];
    allowedHeadingsList == null ? void 0 : allowedHeadingsList.forEach((header) => {
      const scrollableTop = (elemScrollParent == null ? void 0 : elemScrollParent.getBoundingClientRect().top) || 0;
      const headerBoundTop = header.getBoundingClientRect().top;
      const offsetTop = headerBoundTop - scrollableTop + headingSizeThreshold;
      if (offsetTop >= 0)
        visibleHeadings.push(header);
    });
    $$invalidate(3, activeHeaderId = (_a = visibleHeadings[0]) == null ? void 0 : _a.id);
  }
  onMount(() => {
    queryAllowedHeadingsList();
    generateHeadingList();
    elemScrollParent = document.querySelector(scrollParent);
    elemScrollParent == null ? void 0 : elemScrollParent.addEventListener("scroll", pageScrollHandler);
    pageScrollHandler();
  });
  onDestroy(() => {
    elemScrollParent == null ? void 0 : elemScrollParent.removeEventListener("scroll", pageScrollHandler);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = (headingElem) => {
    scrollToHeading(headingElem);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("scrollParent" in $$new_props)
      $$invalidate(8, scrollParent = $$new_props.scrollParent);
    if ("target" in $$new_props)
      $$invalidate(9, target = $$new_props.target);
    if ("allowedHeadings" in $$new_props)
      $$invalidate(10, allowedHeadings = $$new_props.allowedHeadings);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("text" in $$new_props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("hover" in $$new_props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("regionLabel" in $$new_props)
      $$invalidate(16, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$new_props)
      $$invalidate(17, regionList = $$new_props.regionList);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    fade,
    scrollParent,
    target,
    allowedHeadings,
    label,
    width,
    spacing,
    text: text2,
    hover,
    active,
    rounded,
    regionLabel,
    regionList,
    cLabel: cLabel6,
    cList: cList2,
    cListItem,
    elemScrollParent,
    allowedHeadingsList,
    filteredHeadingsList,
    activeHeaderId,
    queryAllowedHeadingsList,
    generateHeadingList,
    setHeadingClasses,
    scrollToHeading,
    pageScrollHandler,
    classesListItem,
    classesList,
    classesLabel,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
    if ("scrollParent" in $$props)
      $$invalidate(8, scrollParent = $$new_props.scrollParent);
    if ("target" in $$props)
      $$invalidate(9, target = $$new_props.target);
    if ("allowedHeadings" in $$props)
      $$invalidate(10, allowedHeadings = $$new_props.allowedHeadings);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("text" in $$props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("hover" in $$props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(1, active = $$new_props.active);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("regionLabel" in $$props)
      $$invalidate(16, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$props)
      $$invalidate(17, regionList = $$new_props.regionList);
    if ("elemScrollParent" in $$props)
      elemScrollParent = $$new_props.elemScrollParent;
    if ("allowedHeadingsList" in $$props)
      allowedHeadingsList = $$new_props.allowedHeadingsList;
    if ("filteredHeadingsList" in $$props)
      $$invalidate(2, filteredHeadingsList = $$new_props.filteredHeadingsList);
    if ("activeHeaderId" in $$props)
      $$invalidate(3, activeHeaderId = $$new_props.activeHeaderId);
    if ("classesListItem" in $$props)
      $$invalidate(4, classesListItem = $$new_props.classesListItem);
    if ("classesList" in $$props)
      $$invalidate(5, classesList = $$new_props.classesList);
    if ("classesLabel" in $$props)
      $$invalidate(6, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*regionLabel*/
    65536) {
      $:
        $$invalidate(6, classesLabel = `${cLabel6} ${regionLabel}`);
    }
    if ($$self.$$.dirty & /*regionList*/
    131072) {
      $:
        $$invalidate(5, classesList = `${cList2} ${regionList}`);
    }
    if ($$self.$$.dirty & /*text, hover, rounded*/
    57344) {
      $:
        $$invalidate(4, classesListItem = `${cListItem} ${text2} ${hover} ${rounded}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    active,
    filteredHeadingsList,
    activeHeaderId,
    classesListItem,
    classesList,
    classesLabel,
    classesBase,
    scrollParent,
    target,
    allowedHeadings,
    width,
    spacing,
    text2,
    hover,
    rounded,
    regionLabel,
    regionList,
    click_handler,
    keypress_handler,
    click_handler_1
  ];
}
var TableOfContents = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      scrollParent: 8,
      target: 9,
      allowedHeadings: 10,
      label: 0,
      width: 11,
      spacing: 12,
      text: 13,
      hover: 14,
      active: 1,
      rounded: 15,
      regionLabel: 16,
      regionList: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableOfContents",
      options,
      id: create_fragment30.name
    });
  }
  get scrollParent() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollParent(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowedHeadings() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowedHeadings(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableOfContents_default = TableOfContents;

// node_modules/@skeletonlabs/skeleton/dist/components/TreeView/TreeView.svelte
var file31 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\TreeView\\TreeView.svelte";
function create_fragment31(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-multiselectable": true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tree " + /*classesBase*/
      ctx[1]);
      attr_dev(div, "data-testid", "tree");
      attr_dev(div, "role", "tree");
      attr_dev(div, "aria-multiselectable", "true");
      attr_dev(
        div,
        "aria-label",
        /*labelledby*/
        ctx[0]
      );
      add_location(div, file31, 28, 0, 937);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      2 && div_class_value !== (div_class_value = "tree " + /*classesBase*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div,
          "aria-label",
          /*labelledby*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeView", slots, ["default"]);
  let { width = "w-full" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { padding = "py-4 px-4" } = $$props;
  let { indent = "ml-4" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { caretOpen = "rotate-180" } = $$props;
  let { caretClosed = "" } = $$props;
  let { hyphenOpacity = "opacity-10" } = $$props;
  let { regionSummary = "" } = $$props;
  let { regionSymbol = "" } = $$props;
  let { regionChildren = "" } = $$props;
  let { labelledby = "" } = $$props;
  setContext("padding", padding);
  setContext("indent", indent);
  setContext("hover", hover);
  setContext("rounded", rounded);
  setContext("caretOpen", caretOpen);
  setContext("caretClosed", caretClosed);
  setContext("hyphenOpacity", hyphenOpacity);
  setContext("regionSummary", regionSummary);
  setContext("regionSymbol", regionSymbol);
  setContext("regionChildren", regionChildren);
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("width" in $$new_props)
      $$invalidate(2, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(4, padding = $$new_props.padding);
    if ("indent" in $$new_props)
      $$invalidate(5, indent = $$new_props.indent);
    if ("hover" in $$new_props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(8, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(9, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$new_props)
      $$invalidate(10, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$new_props)
      $$invalidate(11, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$new_props)
      $$invalidate(12, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$new_props)
      $$invalidate(13, regionChildren = $$new_props.regionChildren);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    width,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    labelledby,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("width" in $$props)
      $$invalidate(2, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(4, padding = $$new_props.padding);
    if ("indent" in $$props)
      $$invalidate(5, indent = $$new_props.indent);
    if ("hover" in $$props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(8, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(9, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$props)
      $$invalidate(10, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$props)
      $$invalidate(11, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$props)
      $$invalidate(12, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$props)
      $$invalidate(13, regionChildren = $$new_props.regionChildren);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    classesBase,
    width,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    $$scope,
    slots
  ];
}
var TreeView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      width: 2,
      spacing: 3,
      padding: 4,
      indent: 5,
      hover: 6,
      rounded: 7,
      caretOpen: 8,
      caretClosed: 9,
      hyphenOpacity: 10,
      regionSummary: 11,
      regionSymbol: 12,
      regionChildren: 13,
      labelledby: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeView",
      options,
      id: create_fragment31.name
    });
  }
  get width() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indent() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indent(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hyphenOpacity() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hyphenOpacity(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSummary() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSummary(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSymbol() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSymbol(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionChildren() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionChildren(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeView_default = TreeView;

// node_modules/@skeletonlabs/skeleton/dist/components/TreeView/TreeViewItem.svelte
var file32 = "node_modules\\@skeletonlabs\\skeleton\\dist\\components\\TreeView\\TreeViewItem.svelte";
var get_children_slot_changes = (dirty) => ({});
var get_children_slot_context = (ctx) => ({});
var get_lead_slot_changes10 = (dirty) => ({});
var get_lead_slot_context10 = (ctx) => ({});
function create_else_block7(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z");
      add_location(path, file32, 57, 5, 2070);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      attr_dev(svg, "class", svg_class_value = "w-3 " + /*classesHyphen*/
      ctx[2]);
      add_location(svg, file32, 56, 4, 1974);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*classesHyphen*/
      4 && svg_class_value !== (svg_class_value = "w-3 " + /*classesHyphen*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(56:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z");
      add_location(path, file32, 51, 5, 1755);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      add_location(svg, file32, 50, 4, 1687);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(49:3) {#if $$slots.children}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[21].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_lead_slot_context10
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tree-item-lead");
      add_location(div, file32, 63, 3, 2259);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_lead_slot_changes10
            ),
            get_lead_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(63:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let details;
  let summary;
  let div0;
  let div0_class_value;
  let t0;
  let t1;
  let div1;
  let summary_class_value;
  let summary_aria_expanded_value;
  let t2;
  let div2;
  let div2_class_value;
  let details_class_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[6].children
    )
      return create_if_block_111;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[6].lead && create_if_block24(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const children_slot_template = (
    /*#slots*/
    ctx[21].children
  );
  const children_slot = create_slot(
    children_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_children_slot_context
  );
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      div2 = element("div");
      if (children_slot)
        children_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", { class: true, "data-testid": true });
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {
        class: true,
        role: true,
        "aria-selected": true,
        "aria-expanded": true
      });
      var summary_nodes = children(summary);
      div0 = claim_element(summary_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(summary_nodes);
      if (if_block1)
        if_block1.l(summary_nodes);
      t1 = claim_space(summary_nodes);
      div1 = claim_element(summary_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      summary_nodes.forEach(detach_dev);
      t2 = claim_space(details_nodes);
      div2 = claim_element(details_nodes, "DIV", { class: true, role: true });
      var div2_nodes = children(div2);
      if (children_slot)
        children_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "tree-summary-symbol " + /*classesSymbol*/
      ctx[3]);
      add_location(div0, file32, 47, 2, 1584);
      attr_dev(div1, "class", "tree-item-content");
      add_location(div1, file32, 68, 2, 2358);
      attr_dev(summary, "class", summary_class_value = "tree-item-summary " + /*classesSummary*/
      ctx[4]);
      attr_dev(summary, "role", "treeitem");
      attr_dev(summary, "aria-selected", "false");
      attr_dev(summary, "aria-expanded", summary_aria_expanded_value = /*$$slots*/
      ctx[6].children ? (
        /*open*/
        ctx[0]
      ) : void 0);
      add_location(summary, file32, 37, 1, 1376);
      attr_dev(div2, "class", div2_class_value = "tree-item-children " + /*classesChildren*/
      ctx[1]);
      attr_dev(div2, "role", "group");
      add_location(div2, file32, 72, 1, 2424);
      attr_dev(details, "class", details_class_value = "tree-item " + /*classesBase*/
      ctx[5]);
      attr_dev(details, "data-testid", "tree-item");
      add_location(details, file32, 36, 0, 1299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      append_hydration_dev(summary, div0);
      if_block0.m(div0, null);
      append_hydration_dev(summary, t0);
      if (if_block1)
        if_block1.m(summary, null);
      append_hydration_dev(summary, t1);
      append_hydration_dev(summary, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(details, t2);
      append_hydration_dev(details, div2);
      if (children_slot) {
        children_slot.m(div2, null);
      }
      details.open = /*open*/
      ctx[0];
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            summary,
            "click",
            /*click_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            summary,
            "keydown",
            /*keydown_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            summary,
            "keyup",
            /*keyup_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "toggle",
            /*details_toggle_handler*/
            ctx[25]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (!current || dirty & /*classesSymbol*/
      8 && div0_class_value !== (div0_class_value = "tree-summary-symbol " + /*classesSymbol*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[6].lead
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(summary, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesSummary*/
      16 && summary_class_value !== (summary_class_value = "tree-item-summary " + /*classesSummary*/
      ctx2[4])) {
        attr_dev(summary, "class", summary_class_value);
      }
      if (!current || dirty & /*$$slots, open*/
      65 && summary_aria_expanded_value !== (summary_aria_expanded_value = /*$$slots*/
      ctx2[6].children ? (
        /*open*/
        ctx2[0]
      ) : void 0)) {
        attr_dev(summary, "aria-expanded", summary_aria_expanded_value);
      }
      if (children_slot) {
        if (children_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            children_slot,
            children_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              children_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_children_slot_changes
            ),
            get_children_slot_context
          );
        }
      }
      if (!current || dirty & /*classesChildren*/
      2 && div2_class_value !== (div2_class_value = "tree-item-children " + /*classesChildren*/
      ctx2[1])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*classesBase*/
      32 && details_class_value !== (details_class_value = "tree-item " + /*classesBase*/
      ctx2[5])) {
        attr_dev(details, "class", details_class_value);
      }
      if (dirty & /*open*/
      1) {
        details.open = /*open*/
        ctx2[0];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(children_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(children_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(details);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      if (children_slot)
        children_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase23 = "";
var cSummary = "list-none flex items-center cursor-pointer";
var cSymbol = "fill-current w-3 text-center transition-transform duration-[200ms]";
var cChildren = "";
function instance32($$self, $$props, $$invalidate) {
  let classesCaretState;
  let classesBase;
  let classesSummary;
  let classesSymbol;
  let classesCaret;
  let classesHyphen;
  let classesChildren;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeViewItem", slots, ["lead", "default", "children"]);
  const $$slots = compute_slots(slots);
  let { open = false } = $$props;
  let { spacing = "space-x-4" } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { indent = getContext("indent") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { caretOpen = getContext("caretOpen") } = $$props;
  let { caretClosed = getContext("caretClosed") } = $$props;
  let { hyphenOpacity = getContext("hyphenOpacity") } = $$props;
  let { regionSummary = "" } = $$props;
  let { regionSymbol = getContext("regionSymbol") } = $$props;
  let { regionChildren = getContext("regionChildren") } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function details_toggle_handler() {
    open = this.open;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("spacing" in $$new_props)
      $$invalidate(7, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("indent" in $$new_props)
      $$invalidate(9, indent = $$new_props.indent);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(12, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(13, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$new_props)
      $$invalidate(14, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$new_props)
      $$invalidate(15, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$new_props)
      $$invalidate(16, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$new_props)
      $$invalidate(17, regionChildren = $$new_props.regionChildren);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    createEventDispatcher,
    open,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    dispatch,
    cBase: cBase23,
    cSummary,
    cSymbol,
    cChildren,
    classesChildren,
    classesHyphen,
    classesCaretState,
    classesCaret,
    classesSymbol,
    classesSummary,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("spacing" in $$props)
      $$invalidate(7, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("indent" in $$props)
      $$invalidate(9, indent = $$new_props.indent);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(12, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(13, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$props)
      $$invalidate(14, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$props)
      $$invalidate(15, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$props)
      $$invalidate(16, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$props)
      $$invalidate(17, regionChildren = $$new_props.regionChildren);
    if ("classesChildren" in $$props)
      $$invalidate(1, classesChildren = $$new_props.classesChildren);
    if ("classesHyphen" in $$props)
      $$invalidate(2, classesHyphen = $$new_props.classesHyphen);
    if ("classesCaretState" in $$props)
      $$invalidate(18, classesCaretState = $$new_props.classesCaretState);
    if ("classesCaret" in $$props)
      $$invalidate(19, classesCaret = $$new_props.classesCaret);
    if ("classesSymbol" in $$props)
      $$invalidate(3, classesSymbol = $$new_props.classesSymbol);
    if ("classesSummary" in $$props)
      $$invalidate(4, classesSummary = $$new_props.classesSummary);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        dispatch("toggle", { open });
    }
    if ($$self.$$.dirty & /*open, caretOpen, caretClosed*/
    12289) {
      $:
        $$invalidate(18, classesCaretState = open ? caretOpen : caretClosed);
    }
    $:
      $$invalidate(5, classesBase = `${cBase23} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*spacing, rounded, padding, hover, regionSummary*/
    36224) {
      $:
        $$invalidate(4, classesSummary = `${cSummary} ${spacing} ${rounded} ${padding} ${hover} ${regionSummary}`);
    }
    if ($$self.$$.dirty & /*classesCaretState*/
    262144) {
      $:
        $$invalidate(19, classesCaret = `${classesCaretState}`);
    }
    if ($$self.$$.dirty & /*classesCaret, regionSymbol*/
    589824) {
      $:
        $$invalidate(3, classesSymbol = `${cSymbol} ${classesCaret} ${regionSymbol}`);
    }
    if ($$self.$$.dirty & /*hyphenOpacity*/
    16384) {
      $:
        $$invalidate(2, classesHyphen = `${hyphenOpacity}`);
    }
    if ($$self.$$.dirty & /*indent, regionChildren*/
    131584) {
      $:
        $$invalidate(1, classesChildren = `${cChildren} ${indent} ${regionChildren}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    classesChildren,
    classesHyphen,
    classesSymbol,
    classesSummary,
    classesBase,
    $$slots,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    classesCaretState,
    classesCaret,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    details_toggle_handler
  ];
}
var TreeViewItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      open: 0,
      spacing: 7,
      padding: 8,
      indent: 9,
      hover: 10,
      rounded: 11,
      caretOpen: 12,
      caretClosed: 13,
      hyphenOpacity: 14,
      regionSummary: 15,
      regionSymbol: 16,
      regionChildren: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeViewItem",
      options,
      id: create_fragment32.name
    });
  }
  get open() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indent() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indent(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hyphenOpacity() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hyphenOpacity(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSummary() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSummary(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSymbol() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSymbol(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionChildren() {
    throw new Error("<TreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionChildren(value) {
    throw new Error("<TreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeViewItem_default = TreeViewItem;

// node_modules/@skeletonlabs/skeleton/dist/utilities/CodeBlock/CodeBlock.svelte
var file33 = "node_modules\\@skeletonlabs\\skeleton\\dist\\utilities\\CodeBlock\\CodeBlock.svelte";
function create_if_block25(ctx) {
  let div;
  let header;
  let span;
  let t0_value = languageFormatter(
    /*language*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let button_1;
  let t2_value = (!/*copyState*/
  ctx[7] ? (
    /*buttonLabel*/
    ctx[3]
  ) : (
    /*buttonCopied*/
    ctx[4]
  )) + "";
  let t2;
  let button_1_class_value;
  let clipboard_action;
  let header_class_value;
  let t3;
  let pre;
  let code_1;
  let code_1_class_value;
  let pre_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*formatted*/
      ctx2[6]
    )
      return create_if_block_112;
    return create_else_block8;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      header = element("header");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button_1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      pre = element("pre");
      code_1 = element("code");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      header = claim_element(div_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      span = claim_element(header_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(header_nodes);
      button_1 = claim_element(header_nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      t2 = claim_text(button_1_nodes, t2_value);
      button_1_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      pre = claim_element(div_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      if_block.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "codeblock-language");
      add_location(span, file33, 58, 2, 1785);
      attr_dev(button_1, "class", button_1_class_value = "codeblock-btn " + /*button*/
      ctx[2]);
      add_location(button_1, file33, 60, 2, 1880);
      attr_dev(header, "class", header_class_value = "codeblock-header " + cHeader3);
      add_location(header, file33, 56, 1, 1719);
      attr_dev(code_1, "class", code_1_class_value = "codeblock-code language-" + /*language*/
      ctx[0] + " lineNumbers");
      add_location(code_1, file33, 65, 35, 2086);
      attr_dev(pre, "class", pre_class_value = "codeblock-pre " + cPre);
      add_location(pre, file33, 65, 1, 2052);
      attr_dev(div, "class", div_class_value = "codeblock " + /*classesBase*/
      ctx[8]);
      attr_dev(div, "data-testid", "codeblock");
      add_location(div, file33, 54, 0, 1639);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, header);
      append_hydration_dev(header, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, button_1);
      append_hydration_dev(button_1, t2);
      append_hydration_dev(div, t3);
      append_hydration_dev(div, pre);
      append_hydration_dev(pre, code_1);
      if_block.m(code_1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            button_1,
            "click",
            /*onCopyClick*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          action_destroyer(clipboard_action = clipboard.call(
            null,
            button_1,
            /*code*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*language*/
      1 && t0_value !== (t0_value = languageFormatter(
        /*language*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*copyState, buttonLabel, buttonCopied*/
      152 && t2_value !== (t2_value = (!/*copyState*/
      ctx2[7] ? (
        /*buttonLabel*/
        ctx2[3]
      ) : (
        /*buttonCopied*/
        ctx2[4]
      )) + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*button*/
      4 && button_1_class_value !== (button_1_class_value = "codeblock-btn " + /*button*/
      ctx2[2])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (clipboard_action && is_function(clipboard_action.update) && dirty & /*code*/
      2)
        clipboard_action.update.call(
          null,
          /*code*/
          ctx2[1]
        );
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(code_1, null);
        }
      }
      if (dirty & /*language*/
      1 && code_1_class_value !== (code_1_class_value = "codeblock-code language-" + /*language*/
      ctx2[0] + " lineNumbers")) {
        attr_dev(code_1, "class", code_1_class_value);
      }
      if (dirty & /*classesBase*/
      256 && div_class_value !== (div_class_value = "codeblock " + /*classesBase*/
      ctx2[8])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(54:0) {#if language && code}",
    ctx
  });
  return block;
}
function create_else_block8(ctx) {
  let t_value = (
    /*code*/
    ctx[1].trim() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*code*/
      2 && t_value !== (t_value = /*code*/
      ctx2[1].trim() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(66:130) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*displayCode*/
        ctx[5],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*displayCode*/
      32)
        html_tag.p(
          /*displayCode*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(66:96) {#if formatted}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let if_block_anchor;
  let if_block = (
    /*language*/
    ctx[0] && /*code*/
    ctx[1] && create_if_block25(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*language*/
        ctx2[0] && /*code*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase24 = "overflow-hidden shadow";
var cHeader3 = "text-xs text-white/50 uppercase flex justify-between items-center p-2 pl-4";
var cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(lang) {
  if (lang === "js")
    return "javascript";
  if (lang === "ts")
    return "typescript";
  return lang;
}
function instance33($$self, $$props, $$invalidate) {
  let classesBase;
  let $storeHighlightJs;
  validate_store(storeHighlightJs, "storeHighlightJs");
  component_subscribe($$self, storeHighlightJs, ($$value) => $$invalidate(17, $storeHighlightJs = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeBlock", slots, []);
  const dispatch = createEventDispatcher();
  let { language = "plaintext" } = $$props;
  let { code = "" } = $$props;
  let { lineNumbers = false } = $$props;
  let { background = "bg-neutral-900/90" } = $$props;
  let { blur = "" } = $$props;
  let { text: text2 = "text-sm" } = $$props;
  let { color = "text-white" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow" } = $$props;
  let { button = "btn btn-sm variant-soft !text-white" } = $$props;
  let { buttonLabel = "Copy" } = $$props;
  let { buttonCopied = "👍" } = $$props;
  let formatted = false;
  let displayCode = code;
  let copyState = false;
  function onCopyClick() {
    $$invalidate(7, copyState = true);
    setTimeout(
      () => {
        $$invalidate(7, copyState = false);
      },
      2e3
    );
    dispatch("copy");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("language" in $$new_props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$new_props)
      $$invalidate(1, code = $$new_props.code);
    if ("lineNumbers" in $$new_props)
      $$invalidate(10, lineNumbers = $$new_props.lineNumbers);
    if ("background" in $$new_props)
      $$invalidate(11, background = $$new_props.background);
    if ("blur" in $$new_props)
      $$invalidate(12, blur = $$new_props.blur);
    if ("text" in $$new_props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(16, shadow = $$new_props.shadow);
    if ("button" in $$new_props)
      $$invalidate(2, button = $$new_props.button);
    if ("buttonLabel" in $$new_props)
      $$invalidate(3, buttonLabel = $$new_props.buttonLabel);
    if ("buttonCopied" in $$new_props)
      $$invalidate(4, buttonCopied = $$new_props.buttonCopied);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    storeHighlightJs,
    clipboard,
    language,
    code,
    lineNumbers,
    background,
    blur,
    text: text2,
    color,
    rounded,
    shadow,
    button,
    buttonLabel,
    buttonCopied,
    cBase: cBase24,
    cHeader: cHeader3,
    cPre,
    formatted,
    displayCode,
    copyState,
    languageFormatter,
    onCopyClick,
    classesBase,
    $storeHighlightJs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
    if ("language" in $$props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$props)
      $$invalidate(1, code = $$new_props.code);
    if ("lineNumbers" in $$props)
      $$invalidate(10, lineNumbers = $$new_props.lineNumbers);
    if ("background" in $$props)
      $$invalidate(11, background = $$new_props.background);
    if ("blur" in $$props)
      $$invalidate(12, blur = $$new_props.blur);
    if ("text" in $$props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(16, shadow = $$new_props.shadow);
    if ("button" in $$props)
      $$invalidate(2, button = $$new_props.button);
    if ("buttonLabel" in $$props)
      $$invalidate(3, buttonLabel = $$new_props.buttonLabel);
    if ("buttonCopied" in $$props)
      $$invalidate(4, buttonCopied = $$new_props.buttonCopied);
    if ("formatted" in $$props)
      $$invalidate(6, formatted = $$new_props.formatted);
    if ("displayCode" in $$props)
      $$invalidate(5, displayCode = $$new_props.displayCode);
    if ("copyState" in $$props)
      $$invalidate(7, copyState = $$new_props.copyState);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$storeHighlightJs, code, language*/
    131075) {
      $:
        if ($storeHighlightJs !== void 0) {
          $$invalidate(5, displayCode = $storeHighlightJs.highlight(code, { language }).value.trim());
          $$invalidate(6, formatted = true);
        }
    }
    if ($$self.$$.dirty & /*lineNumbers, displayCode*/
    1056) {
      $:
        if (lineNumbers) {
          $$invalidate(5, displayCode = displayCode.replace(/^/gm, () => {
            return '<span class="line"></span>	';
          }));
          $$invalidate(6, formatted = true);
        }
    }
    $:
      $$invalidate(8, classesBase = `${cBase24} ${background} ${blur} ${text2} ${color} ${rounded} ${shadow} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    language,
    code,
    button,
    buttonLabel,
    buttonCopied,
    displayCode,
    formatted,
    copyState,
    classesBase,
    onCopyClick,
    lineNumbers,
    background,
    blur,
    text2,
    color,
    rounded,
    shadow,
    $storeHighlightJs
  ];
}
var CodeBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      language: 0,
      code: 1,
      lineNumbers: 10,
      background: 11,
      blur: 12,
      text: 13,
      color: 14,
      rounded: 15,
      shadow: 16,
      button: 2,
      buttonLabel: 3,
      buttonCopied: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBlock",
      options,
      id: create_fragment33.name
    });
  }
  get language() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineNumbers() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineNumbers(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonLabel() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonLabel(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCopied() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCopied(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBlock_default = CodeBlock;

// node_modules/@skeletonlabs/skeleton/dist/utilities/Modal/Modal.svelte
var file34 = "node_modules\\@skeletonlabs\\skeleton\\dist\\utilities\\Modal\\Modal.svelte";
function create_if_block26(ctx) {
  let previous_key = (
    /*$modalStore*/
    ctx[12]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      4096 && safe_not_equal(previous_key, previous_key = /*$modalStore*/
      ctx2[12])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(135:0) {#if $modalStore.length > 0}",
    ctx
  });
  return block;
}
function create_else_block9(ctx) {
  var _a, _b;
  let div;
  let switch_instance;
  let div_class_value;
  let div_aria_label_value;
  let current;
  const switch_instance_spread_levels = [
    /*currentComponent*/
    (_a = ctx[14]) == null ? void 0 : _a.props,
    { parent: (
      /*parent*/
      ctx[15]
    ) }
  ];
  var switch_value = (
    /*currentComponent*/
    (_b = ctx[14]) == null ? void 0 : _b.ref
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a2;
      attr_dev(div, "class", div_class_value = "modal contents " + /*$modalStore*/
      (((_a2 = ctx[12][0]) == null ? void 0 : _a2.modalClasses) ?? ""));
      attr_dev(div, "data-testid", "modal-component");
      attr_dev(div, "role", "dialog");
      attr_dev(div, "aria-modal", "true");
      attr_dev(div, "aria-label", div_aria_label_value = /*$modalStore*/
      ctx[12][0].title ?? "");
      add_location(div, file34, 199, 5, 6899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c;
      const switch_instance_changes = dirty[0] & /*currentComponent, parent*/
      49152 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*currentComponent*/
        16384 && get_spread_object(
          /*currentComponent*/
          (_a2 = ctx2[14]) == null ? void 0 : _a2.props
        ),
        dirty[0] & /*parent*/
        32768 && { parent: (
          /*parent*/
          ctx2[15]
        ) }
      ]) : {};
      if (dirty[0] & /*currentComponent*/
      16384 | dirty[1] & /*$$scope*/
      8192) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty[0] & /*currentComponent*/
      16384 && switch_value !== (switch_value = /*currentComponent*/
      (_b2 = ctx2[14]) == null ? void 0 : _b2.ref)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*$modalStore*/
      4096 && div_class_value !== (div_class_value = "modal contents " + /*$modalStore*/
      (((_c = ctx2[12][0]) == null ? void 0 : _c.modalClasses) ?? ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$modalStore*/
      4096 && div_aria_label_value !== (div_aria_label_value = /*$modalStore*/
      ctx2[12][0].title ?? "")) {
        attr_dev(div, "aria-label", div_aria_label_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(197:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  var _a, _b, _c, _d;
  let div;
  let t0;
  let t1;
  let t2;
  let div_class_value;
  let div_aria_label_value;
  let div_transition;
  let current;
  let if_block0 = (
    /*$modalStore*/
    ((_a = ctx[12][0]) == null ? void 0 : _a.title) && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*$modalStore*/
    ((_b = ctx[12][0]) == null ? void 0 : _b.body) && create_if_block_6(ctx)
  );
  let if_block2 = (
    /*$modalStore*/
    ((_c = ctx[12][0]) == null ? void 0 : _c.image) && typeof /*$modalStore*/
    ((_d = ctx[12][0]) == null ? void 0 : _d.image) === "string" && create_if_block_53(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$modalStore*/
      ctx2[12][0].type === "alert"
    )
      return create_if_block_29;
    if (
      /*$modalStore*/
      ctx2[12][0].type === "confirm"
    )
      return create_if_block_35;
    if (
      /*$modalStore*/
      ctx2[12][0].type === "prompt"
    )
      return create_if_block_45;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block3 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "modal " + /*classesModal*/
      ctx[16]);
      attr_dev(div, "data-testid", "modal");
      attr_dev(div, "role", "dialog");
      attr_dev(div, "aria-modal", "true");
      attr_dev(div, "aria-label", div_aria_label_value = /*$modalStore*/
      ctx[12][0].title ?? "");
      add_location(div, file34, 153, 5, 4827);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2;
      ctx = new_ctx;
      if (
        /*$modalStore*/
        (_a2 = ctx[12][0]) == null ? void 0 : _a2.title
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_7(ctx);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$modalStore*/
        (_b2 = ctx[12][0]) == null ? void 0 : _b2.body
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_6(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$modalStore*/
        ((_c2 = ctx[12][0]) == null ? void 0 : _c2.image) && typeof /*$modalStore*/
        ((_d2 = ctx[12][0]) == null ? void 0 : _d2.image) === "string"
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_53(ctx);
          if_block2.c();
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block3) {
        if_block3.p(ctx, dirty);
      } else {
        if (if_block3)
          if_block3.d(1);
        if_block3 = current_block_type && current_block_type(ctx);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div, null);
        }
      }
      if (!current || dirty[0] & /*classesModal*/
      65536 && div_class_value !== (div_class_value = "modal " + /*classesModal*/
      ctx[16])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$modalStore*/
      4096 && div_aria_label_value !== (div_aria_label_value = /*$modalStore*/
      ctx[12][0].title ?? "")) {
        attr_dev(div, "aria-label", div_aria_label_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fly,
            {
              duration: (
                /*duration*/
                ctx[3]
              ),
              opacity: 0,
              y: 100
            },
            true
          );
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(
          div,
          fly,
          {
            duration: (
              /*duration*/
              ctx[3]
            ),
            opacity: 0,
            y: 100
          },
          false
        );
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3) {
        if_block3.d();
      }
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(152:4) {#if $modalStore[0].type !== 'component'}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  var _a;
  let html_tag;
  let raw_value = (
    /*currentComponent*/
    ((_a = ctx[14]) == null ? void 0 : _a.slot) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*currentComponent*/
      16384 && raw_value !== (raw_value = /*currentComponent*/
      ((_a2 = ctx2[14]) == null ? void 0 : _a2.slot) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(208:7) {#if currentComponent?.slot}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  var _a;
  let if_block_anchor;
  let if_block = (
    /*currentComponent*/
    ((_a = ctx[14]) == null ? void 0 : _a.slot) && create_if_block_8(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (
        /*currentComponent*/
        (_a2 = ctx2[14]) == null ? void 0 : _a2.slot
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(207:6) <svelte:component this={currentComponent?.ref} {...currentComponent?.props} {parent}>",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let header;
  let raw_value = (
    /*$modalStore*/
    ctx[12][0].title + ""
  );
  let header_class_value;
  const block = {
    c: function create() {
      header = element("header");
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "modal-header " + /*regionHeader*/
      ctx[9]);
      add_location(header, file34, 163, 7, 5116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      header.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      4096 && raw_value !== (raw_value = /*$modalStore*/
      ctx2[12][0].title + ""))
        header.innerHTML = raw_value;
      ;
      if (dirty[0] & /*regionHeader*/
      512 && header_class_value !== (header_class_value = "modal-header " + /*regionHeader*/
      ctx2[9])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(163:6) {#if $modalStore[0]?.title}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let article;
  let raw_value = (
    /*$modalStore*/
    ctx[12][0].body + ""
  );
  let article_class_value;
  const block = {
    c: function create() {
      article = element("article");
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", { class: true });
      var article_nodes = children(article);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(article, "class", article_class_value = "modal-body " + /*regionBody*/
      ctx[10]);
      add_location(article, file34, 167, 7, 5270);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      article.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      4096 && raw_value !== (raw_value = /*$modalStore*/
      ctx2[12][0].body + ""))
        article.innerHTML = raw_value;
      ;
      if (dirty[0] & /*regionBody*/
      1024 && article_class_value !== (article_class_value = "modal-body " + /*regionBody*/
      ctx2[10])) {
        attr_dev(article, "class", article_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(article);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(167:6) {#if $modalStore[0]?.body}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(img, "class", img_class_value = "modal-image " + cModalImage);
      if (!src_url_equal(img.src, img_src_value = /*$modalStore*/
      (_a = ctx[12][0]) == null ? void 0 : _a.image))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Modal");
      add_location(img, file34, 171, 7, 5468);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (dirty[0] & /*$modalStore*/
      4096 && !src_url_equal(img.src, img_src_value = /*$modalStore*/
      (_a = ctx2[12][0]) == null ? void 0 : _a.image)) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(171:6) {#if $modalStore[0]?.image && typeof $modalStore[0]?.image === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let form;
  let input;
  let t0;
  let footer;
  let button0;
  let t1;
  let button0_class_value;
  let t2;
  let button1;
  let t3;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { class: "modal-prompt-input input" },
    { name: "prompt" },
    { type: "text" },
    /*$modalStore*/
    ctx[12][0].valueAttr
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      input = element("input");
      t0 = space();
      footer = element("footer");
      button0 = element("button");
      t1 = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      t2 = space();
      button1 = element("button");
      t3 = text(
        /*buttonTextSubmit*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { class: true });
      var form_nodes = children(form);
      input = claim_element(form_nodes, "INPUT", { class: true, name: true, type: true });
      t0 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(
        button0_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      t3 = claim_text(
        button1_nodes,
        /*buttonTextSubmit*/
        ctx[2]
      );
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file34, 188, 8, 6350);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", button0_class_value = "btn " + /*buttonNeutral*/
      ctx[7]);
      add_location(button0, file34, 190, 9, 6536);
      attr_dev(button1, "type", "submit");
      attr_dev(button1, "class", button1_class_value = "btn " + /*buttonPositive*/
      ctx[8]);
      add_location(button1, file34, 191, 9, 6642);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[11]);
      add_location(footer, file34, 189, 8, 6482);
      attr_dev(form, "class", "space-y-4");
      add_location(form, file34, 187, 7, 6290);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, input);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*promptValue*/
        ctx[13]
      );
      append_hydration_dev(form, t0);
      append_hydration_dev(form, footer);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(footer, t2);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[39]
          ),
          listen_dev(
            button0,
            "click",
            /*onClose*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "submit",
            /*onPromptSubmit*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { class: "modal-prompt-input input" },
        { name: "prompt" },
        { type: "text" },
        dirty[0] & /*$modalStore*/
        4096 && /*$modalStore*/
        ctx2[12][0].valueAttr
      ]));
      if (dirty[0] & /*promptValue*/
      8192 && input.value !== /*promptValue*/
      ctx2[13]) {
        set_input_value(
          input,
          /*promptValue*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t1,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      128 && button0_class_value !== (button0_class_value = "btn " + /*buttonNeutral*/
      ctx2[7])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*buttonTextSubmit*/
      4)
        set_data_dev(
          t3,
          /*buttonTextSubmit*/
          ctx2[2]
        );
      if (dirty[0] & /*buttonPositive*/
      256 && button1_class_value !== (button1_class_value = "btn " + /*buttonPositive*/
      ctx2[8])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      2048 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[11])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(186:49) ",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let footer;
  let button0;
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button0 = element("button");
      t0 = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      t1 = space();
      button1 = element("button");
      t2 = text(
        /*buttonTextConfirm*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(
        button0_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(
        button1_nodes,
        /*buttonTextConfirm*/
        ctx[1]
      );
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", button0_class_value = "btn " + /*buttonNeutral*/
      ctx[7]);
      add_location(button0, file34, 182, 8, 5977);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", button1_class_value = "btn " + /*buttonPositive*/
      ctx[8]);
      add_location(button1, file34, 183, 8, 6082);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[11]);
      add_location(footer, file34, 181, 7, 5924);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t0);
      append_hydration_dev(footer, t1);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t2);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*onClose*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*onConfirm*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t0,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      128 && button0_class_value !== (button0_class_value = "btn " + /*buttonNeutral*/
      ctx2[7])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*buttonTextConfirm*/
      2)
        set_data_dev(
          t2,
          /*buttonTextConfirm*/
          ctx2[1]
        );
      if (dirty[0] & /*buttonPositive*/
      256 && button1_class_value !== (button1_class_value = "btn " + /*buttonPositive*/
      ctx2[8])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      2048 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[11])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(180:50) ",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let footer;
  let button;
  let t;
  let button_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button = element("button");
      t = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t = claim_text(
        button_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "btn " + /*buttonNeutral*/
      ctx[7]);
      add_location(button, file34, 177, 8, 5718);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[11]);
      add_location(footer, file34, 176, 7, 5665);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onClose*/
          ctx[21],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      128 && button_class_value !== (button_class_value = "btn " + /*buttonNeutral*/
      ctx2[7])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      2048 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[11])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(175:6) {#if $modalStore[0].type === 'alert'}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let div0_class_value;
  let div0_transition;
  let div1_class_value;
  let focusTrap_action;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_113, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$modalStore*/
      ctx2[12][0].type !== "component"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "modal-transition " + /*classesTransitionLayer*/
      ctx[17]);
      add_location(div0, file34, 150, 3, 4615);
      attr_dev(div1, "class", div1_class_value = "modal-backdrop " + /*classesBackdrop*/
      ctx[18]);
      attr_dev(div1, "data-testid", "modal-backdrop");
      add_location(div1, file34, 139, 2, 4315);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onBackdropInteractionBegin*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseup",
            /*onBackdropInteractionEnd*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*touchstart_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchend",
            /*touchend_handler*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          action_destroyer(focusTrap_action = focusTrap.call(null, div1, true))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty[0] & /*classesTransitionLayer*/
      131072 && div0_class_value !== (div0_class_value = "modal-transition " + /*classesTransitionLayer*/
      ctx[17])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesBackdrop*/
      262144 && div1_class_value !== (div1_class_value = "modal-backdrop " + /*classesBackdrop*/
      ctx[18])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              duration: (
                /*duration*/
                ctx[3]
              ),
              opacity: (
                /*flyOpacity*/
                ctx[4]
              ),
              x: (
                /*flyX*/
                ctx[5]
              ),
              y: (
                /*flyY*/
                ctx[6]
              )
            },
            true
          );
        div0_transition.run(1);
      });
      add_render_callback(() => {
        if (!current)
          return;
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: (
            /*duration*/
            ctx[3]
          ) }, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(
          div0,
          fly,
          {
            duration: (
              /*duration*/
              ctx[3]
            ),
            opacity: (
              /*flyOpacity*/
              ctx[4]
            ),
            x: (
              /*flyX*/
              ctx[5]
            ),
            y: (
              /*flyY*/
              ctx[6]
            )
          },
          false
        );
      div0_transition.run(0);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, fade, { duration: (
          /*duration*/
          ctx[3]
        ) }, false);
      div1_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if_blocks[current_block_type_index].d();
      if (detaching && div0_transition)
        div0_transition.end();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(136:1) {#key $modalStore}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$modalStore*/
    ctx[12].length > 0 && create_if_block26(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          /*onKeyDown*/
          ctx[24],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$modalStore*/
        ctx2[12].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$modalStore*/
          4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBackdrop = "fixed top-0 left-0 right-0 bottom-0";
var cTransitionLayer = "w-full h-full p-4 overflow-y-auto flex justify-center";
var cModal = "block";
var cModalImage = "w-full h-auto";
function instance34($$self, $$props, $$invalidate) {
  let cPosition;
  let classesBackdrop;
  let classesTransitionLayer;
  let classesModal;
  let parent;
  let $modalStore;
  validate_store(modalStore, "modalStore");
  component_subscribe($$self, modalStore, ($$value) => $$invalidate(12, $modalStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, []);
  const dispatch = createEventDispatcher();
  let { position = "items-center" } = $$props;
  let { components = {} } = $$props;
  let { duration = 150 } = $$props;
  let { flyOpacity = 0 } = $$props;
  let { flyX = 0 } = $$props;
  let { flyY = 100 } = $$props;
  let { background = "bg-surface-100-800-token" } = $$props;
  let { width = "w-modal" } = $$props;
  let { height = "h-auto" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-xl" } = $$props;
  let { zIndex = "z-[999]" } = $$props;
  let { buttonNeutral = "variant-ghost-surface" } = $$props;
  let { buttonPositive = "variant-filled" } = $$props;
  let { buttonTextCancel = "Cancel" } = $$props;
  let { buttonTextConfirm = "Confirm" } = $$props;
  let { buttonTextSubmit = "Submit" } = $$props;
  let { regionBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { regionHeader = "text-2xl font-bold" } = $$props;
  let { regionBody = "max-h-[200px] overflow-hidden" } = $$props;
  let { regionFooter = "flex justify-end space-x-2" } = $$props;
  let promptValue;
  const buttonTextDefaults = {
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit
  };
  let currentComponent;
  let registeredInteractionWithBackdrop = false;
  modalStore.subscribe((modals) => {
    if (!modals.length)
      return;
    if (modals[0].type === "prompt")
      $$invalidate(13, promptValue = modals[0].value);
    $$invalidate(0, buttonTextCancel = modals[0].buttonTextCancel || buttonTextDefaults.buttonTextCancel);
    $$invalidate(1, buttonTextConfirm = modals[0].buttonTextConfirm || buttonTextDefaults.buttonTextConfirm);
    $$invalidate(2, buttonTextSubmit = modals[0].buttonTextSubmit || buttonTextDefaults.buttonTextSubmit);
    $$invalidate(14, currentComponent = typeof modals[0].component === "string" ? components[modals[0].component] : modals[0].component);
  });
  function onBackdropInteractionBegin(event) {
    if (!(event.target instanceof Element))
      return;
    const classList = event.target.classList;
    if (classList.contains("modal-backdrop") || classList.contains("modal-transition")) {
      registeredInteractionWithBackdrop = true;
    }
  }
  function onBackdropInteractionEnd(event) {
    if (!(event.target instanceof Element))
      return;
    const classList = event.target.classList;
    if ((classList.contains("modal-backdrop") || classList.contains("modal-transition")) && registeredInteractionWithBackdrop) {
      if ($modalStore[0].response)
        $modalStore[0].response(void 0);
      modalStore.close();
      dispatch("backdrop", event);
    }
    registeredInteractionWithBackdrop = false;
  }
  function onClose() {
    if ($modalStore[0].response)
      $modalStore[0].response(false);
    modalStore.close();
  }
  function onConfirm() {
    if ($modalStore[0].response)
      $modalStore[0].response(true);
    modalStore.close();
  }
  function onPromptSubmit(event) {
    event.preventDefault();
    if ($modalStore[0].response)
      $modalStore[0].response(promptValue);
    modalStore.close();
  }
  function onKeyDown2(event) {
    if (!$modalStore.length)
      return;
    if (event.code === "Escape")
      onClose();
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    promptValue = this.value;
    $$invalidate(13, promptValue);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(43, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(25, position = $$new_props.position);
    if ("components" in $$new_props)
      $$invalidate(26, components = $$new_props.components);
    if ("duration" in $$new_props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("flyOpacity" in $$new_props)
      $$invalidate(4, flyOpacity = $$new_props.flyOpacity);
    if ("flyX" in $$new_props)
      $$invalidate(5, flyX = $$new_props.flyX);
    if ("flyY" in $$new_props)
      $$invalidate(6, flyY = $$new_props.flyY);
    if ("background" in $$new_props)
      $$invalidate(27, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(28, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(29, height = $$new_props.height);
    if ("padding" in $$new_props)
      $$invalidate(30, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(31, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(32, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(33, shadow = $$new_props.shadow);
    if ("zIndex" in $$new_props)
      $$invalidate(34, zIndex = $$new_props.zIndex);
    if ("buttonNeutral" in $$new_props)
      $$invalidate(7, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$new_props)
      $$invalidate(8, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$new_props)
      $$invalidate(0, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$new_props)
      $$invalidate(1, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$new_props)
      $$invalidate(2, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$new_props)
      $$invalidate(35, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$new_props)
      $$invalidate(9, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$new_props)
      $$invalidate(10, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$new_props)
      $$invalidate(11, regionFooter = $$new_props.regionFooter);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    fade,
    fly,
    dispatch,
    modalStore,
    focusTrap,
    position,
    components,
    duration,
    flyOpacity,
    flyX,
    flyY,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    buttonNeutral,
    buttonPositive,
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    regionBackdrop,
    regionHeader,
    regionBody,
    regionFooter,
    cBackdrop,
    cTransitionLayer,
    cModal,
    cModalImage,
    promptValue,
    buttonTextDefaults,
    currentComponent,
    registeredInteractionWithBackdrop,
    onBackdropInteractionBegin,
    onBackdropInteractionEnd,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown: onKeyDown2,
    parent,
    classesModal,
    cPosition,
    classesTransitionLayer,
    classesBackdrop,
    $modalStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(43, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(25, position = $$new_props.position);
    if ("components" in $$props)
      $$invalidate(26, components = $$new_props.components);
    if ("duration" in $$props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("flyOpacity" in $$props)
      $$invalidate(4, flyOpacity = $$new_props.flyOpacity);
    if ("flyX" in $$props)
      $$invalidate(5, flyX = $$new_props.flyX);
    if ("flyY" in $$props)
      $$invalidate(6, flyY = $$new_props.flyY);
    if ("background" in $$props)
      $$invalidate(27, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(28, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(29, height = $$new_props.height);
    if ("padding" in $$props)
      $$invalidate(30, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(31, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(32, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(33, shadow = $$new_props.shadow);
    if ("zIndex" in $$props)
      $$invalidate(34, zIndex = $$new_props.zIndex);
    if ("buttonNeutral" in $$props)
      $$invalidate(7, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$props)
      $$invalidate(8, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$props)
      $$invalidate(0, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$props)
      $$invalidate(1, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$props)
      $$invalidate(2, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$props)
      $$invalidate(35, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$props)
      $$invalidate(9, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$props)
      $$invalidate(10, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$props)
      $$invalidate(11, regionFooter = $$new_props.regionFooter);
    if ("promptValue" in $$props)
      $$invalidate(13, promptValue = $$new_props.promptValue);
    if ("currentComponent" in $$props)
      $$invalidate(14, currentComponent = $$new_props.currentComponent);
    if ("registeredInteractionWithBackdrop" in $$props)
      registeredInteractionWithBackdrop = $$new_props.registeredInteractionWithBackdrop;
    if ("parent" in $$props)
      $$invalidate(15, parent = $$new_props.parent);
    if ("classesModal" in $$props)
      $$invalidate(16, classesModal = $$new_props.classesModal);
    if ("cPosition" in $$props)
      $$invalidate(36, cPosition = $$new_props.cPosition);
    if ("classesTransitionLayer" in $$props)
      $$invalidate(17, classesTransitionLayer = $$new_props.classesTransitionLayer);
    if ("classesBackdrop" in $$props)
      $$invalidate(18, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c;
    if ($$self.$$.dirty[0] & /*$modalStore, position*/
    33558528) {
      $:
        $$invalidate(36, cPosition = ((_a = $modalStore[0]) == null ? void 0 : _a.position) ?? position);
    }
    $:
      $$invalidate(18, classesBackdrop = `${cBackdrop} ${regionBackdrop} ${zIndex} ${$$props.class ?? ""} ${((_b = $modalStore[0]) == null ? void 0 : _b.backdropClasses) ?? ""}`);
    if ($$self.$$.dirty[1] & /*cPosition*/
    32) {
      $:
        $$invalidate(17, classesTransitionLayer = `${cTransitionLayer} ${cPosition ?? ""}`);
    }
    if ($$self.$$.dirty[0] & /*background, width, height, padding, $modalStore*/
    2013270016 | $$self.$$.dirty[1] & /*spacing, rounded, shadow*/
    7) {
      $:
        $$invalidate(16, classesModal = `${cModal} ${background} ${width} ${height} ${padding} ${spacing} ${rounded} ${shadow} ${((_c = $modalStore[0]) == null ? void 0 : _c.modalClasses) ?? ""}`);
    }
    if ($$self.$$.dirty[0] & /*position, duration, flyOpacity, flyX, flyY, background, width, height, padding, buttonNeutral, buttonPositive, buttonTextCancel, buttonTextConfirm, buttonTextSubmit, regionHeader, regionBody, regionFooter*/
    2046824447 | $$self.$$.dirty[1] & /*spacing, rounded, shadow, regionBackdrop*/
    23) {
      $:
        $$invalidate(15, parent = {
          position,
          // ---
          duration,
          flyOpacity,
          flyX,
          flyY,
          // ---
          background,
          width,
          height,
          padding,
          spacing,
          rounded,
          shadow,
          // ---
          buttonNeutral,
          buttonPositive,
          buttonTextCancel,
          buttonTextConfirm,
          buttonTextSubmit,
          // ---
          regionBackdrop,
          regionHeader,
          regionBody,
          regionFooter,
          // ---
          onClose
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    duration,
    flyOpacity,
    flyX,
    flyY,
    buttonNeutral,
    buttonPositive,
    regionHeader,
    regionBody,
    regionFooter,
    $modalStore,
    promptValue,
    currentComponent,
    parent,
    classesModal,
    classesTransitionLayer,
    classesBackdrop,
    onBackdropInteractionBegin,
    onBackdropInteractionEnd,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown2,
    position,
    components,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    regionBackdrop,
    cPosition,
    touchstart_handler,
    touchend_handler,
    input_input_handler
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance34,
      create_fragment34,
      safe_not_equal,
      {
        position: 25,
        components: 26,
        duration: 3,
        flyOpacity: 4,
        flyX: 5,
        flyY: 6,
        background: 27,
        width: 28,
        height: 29,
        padding: 30,
        spacing: 31,
        rounded: 32,
        shadow: 33,
        zIndex: 34,
        buttonNeutral: 7,
        buttonPositive: 8,
        buttonTextCancel: 0,
        buttonTextConfirm: 1,
        buttonTextSubmit: 2,
        regionBackdrop: 35,
        regionHeader: 9,
        regionBody: 10,
        regionFooter: 11
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment34.name
    });
  }
  get position() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get components() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flyOpacity() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flyOpacity(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flyX() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flyX(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flyY() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flyY(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNeutral() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNeutral(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonPositive() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonPositive(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextCancel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextCancel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextConfirm() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextConfirm(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextSubmit() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextSubmit(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBackdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBackdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFooter() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFooter(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@skeletonlabs/skeleton/dist/utilities/Drawer/Drawer.svelte
var { window: window_1 } = globals;
var file35 = "node_modules\\@skeletonlabs\\skeleton\\dist\\utilities\\Drawer\\Drawer.svelte";
function create_if_block27(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_intro;
  let div0_outro;
  let div1_class_value;
  let focusTrap_action;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-labelledby": true,
        "aria-describedby": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "drawer " + /*classesDrawer*/
      ctx[6]);
      attr_dev(div0, "data-testid", "drawer");
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(
        div0,
        "aria-labelledby",
        /*labelledby*/
        ctx[1]
      );
      attr_dev(
        div0,
        "aria-describedby",
        /*describedby*/
        ctx[2]
      );
      add_location(div0, file35, 141, 2, 4641);
      attr_dev(div1, "class", div1_class_value = "drawer-backdrop " + /*classesBackdrop*/
      ctx[7]);
      attr_dev(div1, "data-testid", "drawer-backdrop");
      add_location(div1, file35, 128, 1, 4318);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[33](div0);
      ctx[34](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onDrawerInteraction*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*touchstart_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchend",
            /*touchend_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          action_destroyer(focusTrap_action = focusTrap.call(null, div1, true))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesDrawer*/
      64 && div0_class_value !== (div0_class_value = "drawer " + /*classesDrawer*/
      ctx[6])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*labelledby*/
      2) {
        attr_dev(
          div0,
          "aria-labelledby",
          /*labelledby*/
          ctx[1]
        );
      }
      if (!current || dirty[0] & /*describedby*/
      4) {
        attr_dev(
          div0,
          "aria-describedby",
          /*describedby*/
          ctx[2]
        );
      }
      if (!current || dirty[0] & /*classesBackdrop*/
      128 && div1_class_value !== (div1_class_value = "drawer-backdrop " + /*classesBackdrop*/
      ctx[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div0_outro)
            div0_outro.end(1);
          div0_intro = create_in_transition(div0, fly, {
            x: (
              /*anim*/
              ctx[5].x
            ),
            y: (
              /*anim*/
              ctx[5].y
            ),
            duration: (
              /*duration*/
              ctx[0]
            )
          });
          div0_intro.start();
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, { duration: (
              /*duration*/
              ctx[0]
            ) }, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div0_intro)
        div0_intro.invalidate();
      if (local) {
        div0_outro = create_out_transition(div0, fly, {
          x: (
            /*anim*/
            ctx[5].x
          ),
          y: (
            /*anim*/
            ctx[5].y
          ),
          duration: (
            /*duration*/
            ctx[0]
          )
        });
      }
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: (
            /*duration*/
            ctx[0]
          ) }, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[33](null);
      if (detaching && div0_outro)
        div0_outro.end();
      ctx[34](null);
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(125:0) {#if $drawerStore.open === true}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$drawerStore*/
    ctx[8].open === true && create_if_block27(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_1,
          "keydown",
          /*onKeydownWindow*/
          ctx[10],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$drawerStore*/
        ctx2[8].open === true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$drawerStore*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBackdrop2 = "fixed top-0 left-0 right-0 bottom-0 flex";
var cDrawer = "overflow-y-auto transition-transform";
function instance35($$self, $$props, $$invalidate) {
  let classesPosition;
  let classesWidth;
  let classesHeight;
  let classesRounded;
  let classesBackdrop;
  let classesDrawer;
  let $drawerStore;
  validate_store(drawerStore, "drawerStore");
  component_subscribe($$self, drawerStore, ($$value) => $$invalidate(8, $drawerStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Drawer", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { position = "left" } = $$props;
  let { duration = 150 } = $$props;
  let { bgBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { blur = "" } = $$props;
  let { padding = "" } = $$props;
  let { bgDrawer = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "" } = $$props;
  let { shadow = "shadow-xl" } = $$props;
  let { width = "" } = $$props;
  let { height = "" } = $$props;
  let { zIndex = "z-40" } = $$props;
  let { regionBackdrop = "" } = $$props;
  let { regionDrawer = "" } = $$props;
  let { labelledby = "" } = $$props;
  let { describedby = "" } = $$props;
  const presets = {
    top: {
      alignment: "items-start",
      width: "w-full",
      height: "h-[50%]",
      rounded: "rounded-bl-container-token rounded-br-container-token"
    },
    bottom: {
      alignment: "items-end",
      width: "w-full",
      height: " h-[50%]",
      rounded: "rounded-tl-container-token rounded-tr-container-token"
    },
    left: {
      alignment: "justify-start",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tr-container-token rounded-br-container-token"
    },
    right: {
      alignment: "justify-end",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tl-container-token rounded-bl-container-token"
    }
  };
  let elemBackdrop;
  let elemDrawer;
  let anim = { x: 0, y: 0 };
  const propDefaults = {
    position,
    duration,
    bgBackdrop,
    blur,
    padding,
    bgDrawer,
    border,
    rounded,
    shadow,
    width,
    height,
    labelledby,
    describedby,
    regionBackdrop,
    regionDrawer
  };
  function applyPropSettings(settings) {
    $$invalidate(11, position = settings.position || propDefaults.position);
    $$invalidate(0, duration = settings.duration || propDefaults.duration);
    $$invalidate(12, bgBackdrop = settings.bgBackdrop || propDefaults.bgBackdrop);
    $$invalidate(13, blur = settings.blur || propDefaults.blur);
    $$invalidate(14, padding = settings.padding || propDefaults.padding);
    $$invalidate(15, bgDrawer = settings.bgDrawer || propDefaults.bgDrawer);
    $$invalidate(16, border = settings.border || propDefaults.border);
    $$invalidate(17, rounded = settings.rounded || propDefaults.rounded);
    $$invalidate(18, shadow = settings.shadow || propDefaults.shadow);
    $$invalidate(19, width = settings.width || propDefaults.width);
    $$invalidate(20, height = settings.height || propDefaults.height);
    $$invalidate(21, regionBackdrop = settings.regionBackdrop || propDefaults.regionBackdrop);
    $$invalidate(22, regionDrawer = settings.regionDrawer || propDefaults.regionDrawer);
    $$invalidate(1, labelledby = settings.labelledby || propDefaults.labelledby);
    $$invalidate(2, describedby = settings.describedby || propDefaults.describedby);
  }
  function applyAnimationSettings() {
    if (!BROWSER)
      return;
    switch (position) {
      case "top":
        $$invalidate(5, anim = { x: 0, y: -window.innerWidth });
        break;
      case "bottom":
        $$invalidate(5, anim = { x: 0, y: window.innerWidth });
        break;
      case "left":
        $$invalidate(5, anim = { x: -window.innerHeight, y: 0 });
        break;
      case "right":
        $$invalidate(5, anim = { x: window.innerHeight, y: 0 });
        break;
      default:
        console.error("Error: unknown position property value.");
        break;
    }
  }
  function onDrawerInteraction(event) {
    if (event.target === elemBackdrop) {
      drawerStore.close();
      dispatch("backdrop", event);
    } else {
      dispatch("drawer", event);
    }
  }
  function onKeydownWindow(event) {
    if (!$drawerStore)
      return;
    if (event.code === "Escape")
      drawerStore.close();
  }
  drawerStore.subscribe((settings) => {
    if (settings.open !== true)
      return;
    applyPropSettings(settings);
    applyAnimationSettings();
  });
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemDrawer = $$value;
      $$invalidate(4, elemDrawer);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemBackdrop = $$value;
      $$invalidate(3, elemBackdrop);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(11, position = $$new_props.position);
    if ("duration" in $$new_props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("bgBackdrop" in $$new_props)
      $$invalidate(12, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$new_props)
      $$invalidate(13, blur = $$new_props.blur);
    if ("padding" in $$new_props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("bgDrawer" in $$new_props)
      $$invalidate(15, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$new_props)
      $$invalidate(16, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(18, shadow = $$new_props.shadow);
    if ("width" in $$new_props)
      $$invalidate(19, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(20, height = $$new_props.height);
    if ("zIndex" in $$new_props)
      $$invalidate(23, zIndex = $$new_props.zIndex);
    if ("regionBackdrop" in $$new_props)
      $$invalidate(21, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionDrawer" in $$new_props)
      $$invalidate(22, regionDrawer = $$new_props.regionDrawer);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("describedby" in $$new_props)
      $$invalidate(2, describedby = $$new_props.describedby);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    fly,
    createEventDispatcher,
    BROWSER,
    dispatch,
    focusTrap,
    drawerStore,
    position,
    duration,
    bgBackdrop,
    blur,
    padding,
    bgDrawer,
    border,
    rounded,
    shadow,
    width,
    height,
    zIndex,
    regionBackdrop,
    regionDrawer,
    labelledby,
    describedby,
    presets,
    cBackdrop: cBackdrop2,
    cDrawer,
    elemBackdrop,
    elemDrawer,
    anim,
    propDefaults,
    applyPropSettings,
    applyAnimationSettings,
    onDrawerInteraction,
    onKeydownWindow,
    classesRounded,
    classesHeight,
    classesWidth,
    classesDrawer,
    classesPosition,
    classesBackdrop,
    $drawerStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(11, position = $$new_props.position);
    if ("duration" in $$props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("bgBackdrop" in $$props)
      $$invalidate(12, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$props)
      $$invalidate(13, blur = $$new_props.blur);
    if ("padding" in $$props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("bgDrawer" in $$props)
      $$invalidate(15, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$props)
      $$invalidate(16, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(18, shadow = $$new_props.shadow);
    if ("width" in $$props)
      $$invalidate(19, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(20, height = $$new_props.height);
    if ("zIndex" in $$props)
      $$invalidate(23, zIndex = $$new_props.zIndex);
    if ("regionBackdrop" in $$props)
      $$invalidate(21, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionDrawer" in $$props)
      $$invalidate(22, regionDrawer = $$new_props.regionDrawer);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("describedby" in $$props)
      $$invalidate(2, describedby = $$new_props.describedby);
    if ("elemBackdrop" in $$props)
      $$invalidate(3, elemBackdrop = $$new_props.elemBackdrop);
    if ("elemDrawer" in $$props)
      $$invalidate(4, elemDrawer = $$new_props.elemDrawer);
    if ("anim" in $$props)
      $$invalidate(5, anim = $$new_props.anim);
    if ("classesRounded" in $$props)
      $$invalidate(24, classesRounded = $$new_props.classesRounded);
    if ("classesHeight" in $$props)
      $$invalidate(25, classesHeight = $$new_props.classesHeight);
    if ("classesWidth" in $$props)
      $$invalidate(26, classesWidth = $$new_props.classesWidth);
    if ("classesDrawer" in $$props)
      $$invalidate(6, classesDrawer = $$new_props.classesDrawer);
    if ("classesPosition" in $$props)
      $$invalidate(27, classesPosition = $$new_props.classesPosition);
    if ("classesBackdrop" in $$props)
      $$invalidate(7, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*position*/
    2048) {
      $:
        $$invalidate(27, classesPosition = presets[position].alignment);
    }
    if ($$self.$$.dirty[0] & /*width, position*/
    526336) {
      $:
        $$invalidate(26, classesWidth = width ? width : presets[position].width);
    }
    if ($$self.$$.dirty[0] & /*height, position*/
    1050624) {
      $:
        $$invalidate(25, classesHeight = height ? height : presets[position].height);
    }
    if ($$self.$$.dirty[0] & /*rounded, position*/
    133120) {
      $:
        $$invalidate(24, classesRounded = rounded ? rounded : presets[position].rounded);
    }
    $:
      $$invalidate(7, classesBackdrop = `${cBackdrop2} ${bgBackdrop} ${padding} ${blur} ${classesPosition} ${regionBackdrop} ${zIndex} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*bgDrawer, border, rounded, shadow, classesWidth, classesHeight, classesRounded, regionDrawer*/
    122126336) {
      $:
        $$invalidate(6, classesDrawer = `${cDrawer} ${bgDrawer} ${border} ${rounded} ${shadow} ${classesWidth} ${classesHeight} ${classesRounded} ${regionDrawer}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    duration,
    labelledby,
    describedby,
    elemBackdrop,
    elemDrawer,
    anim,
    classesDrawer,
    classesBackdrop,
    $drawerStore,
    onDrawerInteraction,
    onKeydownWindow,
    position,
    bgBackdrop,
    blur,
    padding,
    bgDrawer,
    border,
    rounded,
    shadow,
    width,
    height,
    regionBackdrop,
    regionDrawer,
    zIndex,
    classesRounded,
    classesHeight,
    classesWidth,
    classesPosition,
    $$scope,
    slots,
    touchstart_handler,
    touchend_handler,
    keypress_handler,
    div0_binding,
    div1_binding
  ];
}
var Drawer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance35,
      create_fragment35,
      safe_not_equal,
      {
        position: 11,
        duration: 0,
        bgBackdrop: 12,
        blur: 13,
        padding: 14,
        bgDrawer: 15,
        border: 16,
        rounded: 17,
        shadow: 18,
        width: 19,
        height: 20,
        zIndex: 23,
        regionBackdrop: 21,
        regionDrawer: 22,
        labelledby: 1,
        describedby: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Drawer",
      options,
      id: create_fragment35.name
    });
  }
  get position() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgBackdrop() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgBackdrop(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgDrawer() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgDrawer(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBackdrop() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBackdrop(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDrawer() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDrawer(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Drawer_default = Drawer;

// node_modules/@skeletonlabs/skeleton/dist/utilities/LightSwitch/LightSwitch.svelte
var file36 = "node_modules\\@skeletonlabs\\skeleton\\dist\\utilities\\LightSwitch\\LightSwitch.svelte";
function create_fragment36(ctx) {
  let html_tag;
  let raw_value = `<script nonce="%sveltekit.nonce%">(${setInitialClassState.toString()})();<\/script>`;
  let html_anchor;
  let t;
  let div1;
  let div0;
  let svg;
  let path;
  let path_d_value;
  let svg_class_value;
  let div0_class_value;
  let div1_class_value;
  let div1_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      t = space();
      div1 = element("div");
      div0 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-gewkj4", document.head);
      html_tag = claim_html_tag(head_nodes, false);
      html_anchor = empty();
      head_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        title: true,
        tabindex: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      svg = claim_svg_element(div0_nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
      attr_dev(path, "d", path_d_value = /*$modeCurrent*/
      ctx[0] ? (
        /*svgPath*/
        ctx[4].sun
      ) : (
        /*svgPath*/
        ctx[4].moon
      ));
      add_location(path, file36, 73, 3, 3268);
      attr_dev(svg, "class", svg_class_value = "lightswitch-icon " + /*classesIcon*/
      ctx[1]);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file36, 72, 2, 3163);
      attr_dev(div0, "class", div0_class_value = "lightswitch-thumb " + /*classesThumb*/
      ctx[2]);
      add_location(div0, file36, 70, 1, 3099);
      attr_dev(div1, "class", div1_class_value = "lightswitch-track " + /*classesTrack*/
      ctx[3]);
      attr_dev(div1, "role", "switch");
      attr_dev(div1, "aria-label", "Light Switch");
      attr_dev(
        div1,
        "aria-checked",
        /*$modeCurrent*/
        ctx[0]
      );
      attr_dev(div1, "title", div1_title_value = "Toggle " + /*$modeCurrent*/
      (ctx[0] === true ? "Dark" : "Light") + " Mode");
      attr_dev(div1, "tabindex", "0");
      add_location(div1, file36, 55, 0, 2787);
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, document.head);
      append_hydration_dev(document.head, html_anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*onToggleHandler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(div1, "keydown", onKeyDown, false, false, false, false),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$modeCurrent*/
      1 && path_d_value !== (path_d_value = /*$modeCurrent*/
      ctx2[0] ? (
        /*svgPath*/
        ctx2[4].sun
      ) : (
        /*svgPath*/
        ctx2[4].moon
      ))) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*classesIcon*/
      2 && svg_class_value !== (svg_class_value = "lightswitch-icon " + /*classesIcon*/
      ctx2[1])) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*classesThumb*/
      4 && div0_class_value !== (div0_class_value = "lightswitch-thumb " + /*classesThumb*/
      ctx2[2])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*classesTrack*/
      8 && div1_class_value !== (div1_class_value = "lightswitch-track " + /*classesTrack*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*$modeCurrent*/
      1) {
        attr_dev(
          div1,
          "aria-checked",
          /*$modeCurrent*/
          ctx2[0]
        );
      }
      if (dirty & /*$modeCurrent*/
      1 && div1_title_value !== (div1_title_value = "Toggle " + /*$modeCurrent*/
      (ctx2[0] === true ? "Dark" : "Light") + " Mode")) {
        attr_dev(div1, "title", div1_title_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cTrack3 = "cursor-pointer";
var cThumb2 = "aspect-square scale-[0.8] flex justify-center items-center";
var cIcon = "w-[70%] aspect-square";
function onKeyDown(event) {
  if (["Enter", "Space"].includes(event.code)) {
    event.preventDefault();
    event.currentTarget.click();
  }
}
function instance36($$self, $$props, $$invalidate) {
  let trackBg;
  let thumbBg;
  let thumbPosition;
  let iconFill;
  let classesTrack;
  let classesThumb;
  let classesIcon;
  let $modeCurrent;
  validate_store(modeCurrent, "modeCurrent");
  component_subscribe($$self, modeCurrent, ($$value) => $$invalidate(0, $modeCurrent = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightSwitch", slots, []);
  let { bgLight = "bg-surface-50" } = $$props;
  let { bgDark = "bg-surface-900" } = $$props;
  let { fillLight = "fill-surface-50" } = $$props;
  let { fillDark = "fill-surface-900" } = $$props;
  let { width = "w-12" } = $$props;
  let { height = "h-6" } = $$props;
  let { ring = "ring-[1px] ring-surface-500/30" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  const cTransition = `transition-all duration-[200ms]`;
  const svgPath = {
    sun: "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z",
    moon: "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
  };
  function onToggleHandler() {
    set_store_value(modeCurrent, $modeCurrent = !$modeCurrent, $modeCurrent);
    setModeUserPrefers($modeCurrent);
    setModeCurrent($modeCurrent);
  }
  onMount(() => {
    if (!("modeCurrent" in localStorage)) {
      setModeCurrent(getModeOsPrefers());
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("bgLight" in $$new_props)
      $$invalidate(6, bgLight = $$new_props.bgLight);
    if ("bgDark" in $$new_props)
      $$invalidate(7, bgDark = $$new_props.bgDark);
    if ("fillLight" in $$new_props)
      $$invalidate(8, fillLight = $$new_props.fillLight);
    if ("fillDark" in $$new_props)
      $$invalidate(9, fillDark = $$new_props.fillDark);
    if ("width" in $$new_props)
      $$invalidate(10, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(11, height = $$new_props.height);
    if ("ring" in $$new_props)
      $$invalidate(12, ring = $$new_props.ring);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
  };
  $$self.$capture_state = () => ({
    onMount,
    modeCurrent,
    setModeUserPrefers,
    setModeCurrent,
    setInitialClassState,
    getModeOsPrefers,
    bgLight,
    bgDark,
    fillLight,
    fillDark,
    width,
    height,
    ring,
    rounded,
    cTransition,
    cTrack: cTrack3,
    cThumb: cThumb2,
    cIcon,
    svgPath,
    onToggleHandler,
    onKeyDown,
    iconFill,
    classesIcon,
    thumbPosition,
    thumbBg,
    classesThumb,
    trackBg,
    classesTrack,
    $modeCurrent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("bgLight" in $$props)
      $$invalidate(6, bgLight = $$new_props.bgLight);
    if ("bgDark" in $$props)
      $$invalidate(7, bgDark = $$new_props.bgDark);
    if ("fillLight" in $$props)
      $$invalidate(8, fillLight = $$new_props.fillLight);
    if ("fillDark" in $$props)
      $$invalidate(9, fillDark = $$new_props.fillDark);
    if ("width" in $$props)
      $$invalidate(10, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(11, height = $$new_props.height);
    if ("ring" in $$props)
      $$invalidate(12, ring = $$new_props.ring);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("iconFill" in $$props)
      $$invalidate(14, iconFill = $$new_props.iconFill);
    if ("classesIcon" in $$props)
      $$invalidate(1, classesIcon = $$new_props.classesIcon);
    if ("thumbPosition" in $$props)
      $$invalidate(15, thumbPosition = $$new_props.thumbPosition);
    if ("thumbBg" in $$props)
      $$invalidate(16, thumbBg = $$new_props.thumbBg);
    if ("classesThumb" in $$props)
      $$invalidate(2, classesThumb = $$new_props.classesThumb);
    if ("trackBg" in $$props)
      $$invalidate(17, trackBg = $$new_props.trackBg);
    if ("classesTrack" in $$props)
      $$invalidate(3, classesTrack = $$new_props.classesTrack);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$modeCurrent, bgLight, bgDark*/
    193) {
      $:
        $$invalidate(17, trackBg = $modeCurrent === true ? bgLight : bgDark);
    }
    if ($$self.$$.dirty & /*$modeCurrent, bgDark, bgLight*/
    193) {
      $:
        $$invalidate(16, thumbBg = $modeCurrent === true ? bgDark : bgLight);
    }
    if ($$self.$$.dirty & /*$modeCurrent*/
    1) {
      $:
        $$invalidate(15, thumbPosition = $modeCurrent === true ? "translate-x-[100%]" : "");
    }
    if ($$self.$$.dirty & /*$modeCurrent, fillLight, fillDark*/
    769) {
      $:
        $$invalidate(14, iconFill = $modeCurrent === true ? fillLight : fillDark);
    }
    $:
      $$invalidate(3, classesTrack = `${cTrack3} ${cTransition} ${width} ${height} ${ring} ${rounded} ${trackBg} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*height, rounded, thumbBg, thumbPosition*/
    108544) {
      $:
        $$invalidate(2, classesThumb = `${cThumb2} ${cTransition} ${height} ${rounded} ${thumbBg} ${thumbPosition}`);
    }
    if ($$self.$$.dirty & /*iconFill*/
    16384) {
      $:
        $$invalidate(1, classesIcon = `${cIcon} ${iconFill}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    $modeCurrent,
    classesIcon,
    classesThumb,
    classesTrack,
    svgPath,
    onToggleHandler,
    bgLight,
    bgDark,
    fillLight,
    fillDark,
    width,
    height,
    ring,
    rounded,
    iconFill,
    thumbPosition,
    thumbBg,
    trackBg,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var LightSwitch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {
      bgLight: 6,
      bgDark: 7,
      fillLight: 8,
      fillDark: 9,
      width: 10,
      height: 11,
      ring: 12,
      rounded: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightSwitch",
      options,
      id: create_fragment36.name
    });
  }
  get bgLight() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgLight(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgDark() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgDark(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillLight() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillLight(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillDark() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillDark(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ring() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ring(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightSwitch_default = LightSwitch;

// node_modules/@skeletonlabs/skeleton/dist/utilities/Toast/Toast.svelte
var file37 = "node_modules\\@skeletonlabs\\skeleton\\dist\\utilities\\Toast\\Toast.svelte";
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  child_ctx[34] = i;
  return child_ctx;
}
function create_if_block28(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div0_class_value;
  let div1_class_value;
  let current;
  let each_value = (
    /*filteredToasts*/
    ctx[6]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*t*/
    ctx2[32]
  );
  validate_each_keys(ctx, each_value, get_each_context10, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block10(key, child_ctx));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "snackbar " + /*classesSnackbar*/
      ctx[8]);
      add_location(div0, file37, 112, 2, 3362);
      attr_dev(div1, "class", div1_class_value = "snackbar-wrapper " + /*classesWrapper*/
      ctx[9]);
      attr_dev(div1, "data-testid", "snackbar-wrapper");
      add_location(div1, file37, 110, 1, 3265);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filteredToasts, onMouseEnter, onMouseLeave, classesToast, background, buttonDismiss, buttonDismissLabel, buttonAction, onAction*/
      7390) {
        each_value = /*filteredToasts*/
        ctx2[6];
        validate_each_argument(each_value);
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value, get_each_context10, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, fix_and_outro_and_destroy_block, create_each_block10, null, get_each_context10);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty[0] & /*classesSnackbar*/
      256 && div0_class_value !== (div0_class_value = "snackbar " + /*classesSnackbar*/
      ctx2[8])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesWrapper*/
      512 && div1_class_value !== (div1_class_value = "snackbar-wrapper " + /*classesWrapper*/
      ctx2[9])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(109:0) {#if $toastStore.length}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let div;
  let t;
  let div_class_value;
  let if_block0 = (
    /*t*/
    ctx[32].action && create_if_block_36(ctx)
  );
  let if_block1 = !/*t*/
  ctx[32].hideDismiss && create_if_block_210(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "toast-actions " + cToastActions);
      add_location(div, file37, 127, 7, 3953);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*t*/
        ctx2[32].action
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_36(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*t*/
      ctx2[32].hideDismiss) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_210(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(127:6) {#if t.action || !t.hideDismiss}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let button;
  let raw_value = (
    /*t*/
    ctx[32].action.label + ""
  );
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[26](
        /*i*/
        ctx[34]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*buttonAction*/
        ctx[2]
      );
      add_location(button, file37, 128, 22, 4019);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*filteredToasts*/
      64 && raw_value !== (raw_value = /*t*/
      ctx[32].action.label + ""))
        button.innerHTML = raw_value;
      ;
      if (dirty[0] & /*buttonAction*/
      4) {
        attr_dev(
          button,
          "class",
          /*buttonAction*/
          ctx[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(129:8) {#if t.action}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[27](
        /*t*/
        ctx[32]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text(
        /*buttonDismissLabel*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      t = claim_text(
        button_nodes,
        /*buttonDismissLabel*/
        ctx[4]
      );
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*buttonDismiss*/
        ctx[3]
      );
      attr_dev(button, "aria-label", "Dismiss toast");
      add_location(button, file37, 129, 28, 4142);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*buttonDismissLabel*/
      16)
        set_data_dev(
          t,
          /*buttonDismissLabel*/
          ctx[4]
        );
      if (dirty[0] & /*buttonDismiss*/
      8) {
        attr_dev(
          button,
          "class",
          /*buttonDismiss*/
          ctx[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(130:8) {#if !t.hideDismiss}",
    ctx
  });
  return block;
}
function create_each_block10(key_1, ctx) {
  let div2;
  let div1;
  let div0;
  let raw_value = (
    /*t*/
    ctx[32].message + ""
  );
  let t0;
  let div1_class_value;
  let t1;
  let div2_role_value;
  let div2_intro;
  let div2_outro;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*t*/
    (ctx[32].action || !/*t*/
    ctx[32].hideDismiss) && create_if_block_114(ctx)
  );
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[28](
        /*i*/
        ctx[34]
      )
    );
  }
  function mouseleave_handler() {
    return (
      /*mouseleave_handler*/
      ctx[29](
        /*i*/
        ctx[34]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { role: true, "aria-live": true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "text-base");
      add_location(div0, file37, 125, 6, 3860);
      attr_dev(div1, "class", div1_class_value = "toast " + /*classesToast*/
      ctx[7] + " " + /*t*/
      (ctx[32].background ?? /*background*/
      ctx[1]) + " " + /*t*/
      (ctx[32].classes ?? ""));
      attr_dev(div1, "data-testid", "toast");
      add_location(div1, file37, 124, 5, 3752);
      attr_dev(div2, "role", div2_role_value = /*t*/
      ctx[32].hideDismiss ? "alert" : "alertdialog");
      attr_dev(div2, "aria-live", "polite");
      add_location(div2, file37, 114, 4, 3445);
      this.first = div2;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      div0.innerHTML = raw_value;
      append_hydration_dev(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div2, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div2, "mouseenter", mouseenter_handler, false, false, false, false),
          listen_dev(div2, "mouseleave", mouseleave_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*filteredToasts*/
      64) && raw_value !== (raw_value = /*t*/
      ctx[32].message + ""))
        div0.innerHTML = raw_value;
      ;
      if (
        /*t*/
        ctx[32].action || !/*t*/
        ctx[32].hideDismiss
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_114(ctx);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*classesToast, filteredToasts, background*/
      194 && div1_class_value !== (div1_class_value = "toast " + /*classesToast*/
      ctx[7] + " " + /*t*/
      (ctx[32].background ?? /*background*/
      ctx[1]) + " " + /*t*/
      (ctx[32].classes ?? ""))) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*filteredToasts*/
      64 && div2_role_value !== (div2_role_value = /*t*/
      ctx[32].hideDismiss ? "alert" : "alertdialog")) {
        attr_dev(div2, "role", div2_role_value);
      }
    },
    r: function measure() {
      rect = div2.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div2);
      stop_animation();
      add_transform(div2, rect);
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div2, rect, flip, { duration: (
        /*duration*/
        ctx[0]
      ) });
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(
          div2,
          /*receive*/
          ctx[14],
          { key: (
            /*t*/
            ctx[32].id
          ) }
        );
        div2_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(
        div2,
        /*send*/
        ctx[13],
        { key: (
          /*t*/
          ctx[32].id
        ) }
      );
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(114:3) {#each filteredToasts as t, i (t)}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$toastStore*/
    ctx[5].length && create_if_block28(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$toastStore*/
        ctx2[5].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$toastStore*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cWrapper3 = "flex fixed top-0 left-0 right-0 bottom-0 pointer-events-none";
var cSnackbar = "flex flex-col gap-y-2";
var cToast = "flex justify-between items-center pointer-events-auto";
var cToastActions = "flex items-center space-x-2";
function instance37($$self, $$props, $$invalidate) {
  let classesWrapper;
  let classesSnackbar;
  let classesToast;
  let filteredToasts;
  let $toastStore;
  validate_store(toastStore, "toastStore");
  component_subscribe($$self, toastStore, ($$value) => $$invalidate(5, $toastStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, []);
  let { position = "b" } = $$props;
  let { max = 3 } = $$props;
  let { duration = 250 } = $$props;
  let { background = "variant-filled-secondary" } = $$props;
  let { width = "max-w-[640px]" } = $$props;
  let { color = "" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-x-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-lg" } = $$props;
  let { zIndex = "z-[888]" } = $$props;
  let { buttonAction = "btn variant-filled" } = $$props;
  let { buttonDismiss = "btn-icon btn-icon-sm variant-filled" } = $$props;
  let { buttonDismissLabel = "✕" } = $$props;
  let cPosition;
  let cAlign;
  let animAxis = { x: 0, y: 0 };
  switch (position) {
    case "t":
      cPosition = "justify-center items-start";
      cAlign = "items-center";
      animAxis = { x: 0, y: -100 };
      break;
    case "b":
      cPosition = "justify-center items-end";
      cAlign = "items-center";
      animAxis = { x: 0, y: 100 };
      break;
    case "l":
      cPosition = "justify-start items-center";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "r":
      cPosition = "justify-end items-center";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "tl":
      cPosition = "justify-start items-start";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "tr":
      cPosition = "justify-end items-start";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "bl":
      cPosition = "justify-start items-end";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "br":
      cPosition = "justify-end items-end";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
  }
  function onAction(index) {
    var _a, _b;
    (_b = (_a = $toastStore[index]) == null ? void 0 : _a.action) == null ? void 0 : _b.response();
    toastStore.close($toastStore[index].id);
  }
  function onMouseEnter(index) {
    var _a;
    if ((_a = $toastStore[index]) == null ? void 0 : _a.hoverable) {
      toastStore.freeze(index);
      $$invalidate(8, classesSnackbar += " scale-[105%]");
    }
  }
  function onMouseLeave(index) {
    var _a;
    if ((_a = $toastStore[index]) == null ? void 0 : _a.hoverable) {
      toastStore.unfreeze(index);
      $$invalidate(8, classesSnackbar = classesSnackbar.replace(" scale-[105%]", ""));
    }
  }
  const [send, receive] = crossfade({
    duration: (d) => Math.sqrt(d * duration),
    fallback(node) {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      return {
        duration,
        easing: cubicInOut,
        css: (t, u) => `
					transform: ${transform} scale(${t}) translate(${u * animAxis.x}%, ${u * animAxis.y}%);
					opacity: ${t}
				`
      };
    }
  });
  const click_handler = (i) => onAction(i);
  const click_handler_1 = (t) => toastStore.close(t.id);
  const mouseenter_handler = (i) => onMouseEnter(i);
  const mouseleave_handler = (i) => onMouseLeave(i);
  $$self.$$set = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(15, position = $$new_props.position);
    if ("max" in $$new_props)
      $$invalidate(16, max = $$new_props.max);
    if ("duration" in $$new_props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("background" in $$new_props)
      $$invalidate(1, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(17, width = $$new_props.width);
    if ("color" in $$new_props)
      $$invalidate(18, color = $$new_props.color);
    if ("padding" in $$new_props)
      $$invalidate(19, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(20, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(21, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(22, shadow = $$new_props.shadow);
    if ("zIndex" in $$new_props)
      $$invalidate(23, zIndex = $$new_props.zIndex);
    if ("buttonAction" in $$new_props)
      $$invalidate(2, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$new_props)
      $$invalidate(3, buttonDismiss = $$new_props.buttonDismiss);
    if ("buttonDismissLabel" in $$new_props)
      $$invalidate(4, buttonDismissLabel = $$new_props.buttonDismissLabel);
  };
  $$self.$capture_state = () => ({
    crossfade,
    cubicInOut,
    flip,
    toastStore,
    position,
    max,
    duration,
    background,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    buttonAction,
    buttonDismiss,
    buttonDismissLabel,
    cWrapper: cWrapper3,
    cSnackbar,
    cToast,
    cToastActions,
    cPosition,
    cAlign,
    animAxis,
    onAction,
    onMouseEnter,
    onMouseLeave,
    send,
    receive,
    filteredToasts,
    classesToast,
    classesSnackbar,
    classesWrapper,
    $toastStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(15, position = $$new_props.position);
    if ("max" in $$props)
      $$invalidate(16, max = $$new_props.max);
    if ("duration" in $$props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("background" in $$props)
      $$invalidate(1, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(17, width = $$new_props.width);
    if ("color" in $$props)
      $$invalidate(18, color = $$new_props.color);
    if ("padding" in $$props)
      $$invalidate(19, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(20, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(21, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(22, shadow = $$new_props.shadow);
    if ("zIndex" in $$props)
      $$invalidate(23, zIndex = $$new_props.zIndex);
    if ("buttonAction" in $$props)
      $$invalidate(2, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$props)
      $$invalidate(3, buttonDismiss = $$new_props.buttonDismiss);
    if ("buttonDismissLabel" in $$props)
      $$invalidate(4, buttonDismissLabel = $$new_props.buttonDismissLabel);
    if ("cPosition" in $$props)
      $$invalidate(24, cPosition = $$new_props.cPosition);
    if ("cAlign" in $$props)
      $$invalidate(25, cAlign = $$new_props.cAlign);
    if ("animAxis" in $$props)
      animAxis = $$new_props.animAxis;
    if ("filteredToasts" in $$props)
      $$invalidate(6, filteredToasts = $$new_props.filteredToasts);
    if ("classesToast" in $$props)
      $$invalidate(7, classesToast = $$new_props.classesToast);
    if ("classesSnackbar" in $$props)
      $$invalidate(8, classesSnackbar = $$new_props.classesSnackbar);
    if ("classesWrapper" in $$props)
      $$invalidate(9, classesWrapper = $$new_props.classesWrapper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesWrapper = `${cWrapper3} ${cPosition} ${zIndex} ${$$props.class || ""}`);
    if ($$self.$$.dirty[0] & /*cAlign, padding*/
    34078720) {
      $:
        $$invalidate(8, classesSnackbar = `${cSnackbar} ${cAlign} ${padding}`);
    }
    if ($$self.$$.dirty[0] & /*width, color, padding, spacing, rounded, shadow*/
    8257536) {
      $:
        $$invalidate(7, classesToast = `${cToast} ${width} ${color} ${padding} ${spacing} ${rounded} ${shadow}`);
    }
    if ($$self.$$.dirty[0] & /*$toastStore, max*/
    65568) {
      $:
        $$invalidate(6, filteredToasts = Array.from($toastStore).slice(0, max));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    duration,
    background,
    buttonAction,
    buttonDismiss,
    buttonDismissLabel,
    $toastStore,
    filteredToasts,
    classesToast,
    classesSnackbar,
    classesWrapper,
    onAction,
    onMouseEnter,
    onMouseLeave,
    send,
    receive,
    position,
    max,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    cPosition,
    cAlign,
    click_handler,
    click_handler_1,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance37,
      create_fragment37,
      safe_not_equal,
      {
        position: 15,
        max: 16,
        duration: 0,
        background: 1,
        width: 17,
        color: 18,
        padding: 19,
        spacing: 20,
        rounded: 21,
        shadow: 22,
        zIndex: 23,
        buttonAction: 2,
        buttonDismiss: 3,
        buttonDismissLabel: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment37.name
    });
  }
  get position() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonAction() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonAction(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonDismiss() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonDismiss(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonDismissLabel() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonDismissLabel(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Apollo.svelte
var file38 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\Apollo.svelte";
function create_fragment38(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { values: true, result: true, in: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "values", "0.8 0.6 -0.4 0.1 0,\n					0 1.2 0.05 0 0,\n					0 -1 3 0.02 0,\n					0 0 0 50 0");
      attr_dev(feColorMatrix, "result", "final");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      add_location(feColorMatrix, file38, 3, 2, 235);
      attr_dev(filter2, "id", "Apollo");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file38, 2, 1, 113);
      attr_dev(svg, "id", "svg-filter-apollo");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file38, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Apollo", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Apollo> was created with unknown prop '${key}'`);
  });
  return [];
}
var Apollo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Apollo",
      options,
      id: create_fragment38.name
    });
  }
};
var Apollo_default = Apollo;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/BlueNight.svelte
var file39 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\BlueNight.svelte";
function create_fragment39(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.000 0.000 0.000 0.000 0.000 \n                    0.000 1.000 0.000 0.000 0.05 \n                    0.000 0.000 1.000 0.000 0.400 \n                    0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file39, 3, 2, 247);
      attr_dev(filter2, "id", "BlueNight");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file39, 2, 1, 122);
      attr_dev(svg, "id", "svg-filter-bluenight");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file39, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlueNight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BlueNight> was created with unknown prop '${key}'`);
  });
  return [];
}
var BlueNight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlueNight",
      options,
      id: create_fragment39.name
    });
  }
};
var BlueNight_default = BlueNight;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Emerald.svelte
var file40 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\Emerald.svelte";
function create_fragment40(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feComponentTransfer;
  let feFuncR;
  let feFuncG;
  let feFuncB;
  let feFuncA;
  let feBlend;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feComponentTransfer = svg_element("feComponentTransfer");
      feFuncR = svg_element("feFuncR");
      feFuncG = svg_element("feFuncG");
      feFuncB = svg_element("feFuncB");
      feFuncA = svg_element("feFuncA");
      feBlend = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feComponentTransfer = claim_svg_element(filter_nodes, "feComponentTransfer", { in: true, result: true });
      var feComponentTransfer_nodes = children(feComponentTransfer);
      feFuncR = claim_svg_element(feComponentTransfer_nodes, "feFuncR", { type: true, tableValues: true });
      children(feFuncR).forEach(detach_dev);
      feFuncG = claim_svg_element(feComponentTransfer_nodes, "feFuncG", { type: true, tableValues: true });
      children(feFuncG).forEach(detach_dev);
      feFuncB = claim_svg_element(feComponentTransfer_nodes, "feFuncB", { type: true, tableValues: true });
      children(feFuncB).forEach(detach_dev);
      feFuncA = claim_svg_element(feComponentTransfer_nodes, "feFuncA", { type: true, tableValues: true });
      children(feFuncA).forEach(detach_dev);
      feComponentTransfer_nodes.forEach(detach_dev);
      feBlend = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            0 0 0 0.33 0");
      add_location(feColorMatrix, file40, 4, 2, 273);
      attr_dev(feFuncR, "type", "table");
      attr_dev(feFuncR, "tableValues", "0.03 0.9");
      add_location(feFuncR, file40, 15, 3, 555);
      attr_dev(feFuncG, "type", "table");
      attr_dev(feFuncG, "tableValues", "0.57 1");
      add_location(feFuncG, file40, 16, 3, 606);
      attr_dev(feFuncB, "type", "table");
      attr_dev(feFuncB, "tableValues", "0.49 0.53");
      add_location(feFuncB, file40, 17, 3, 655);
      attr_dev(feFuncA, "type", "table");
      attr_dev(feFuncA, "tableValues", "0 1");
      add_location(feFuncA, file40, 18, 3, 707);
      attr_dev(feComponentTransfer, "in", "colormatrix");
      attr_dev(feComponentTransfer, "result", "componentTransfer");
      add_location(feComponentTransfer, file40, 14, 2, 486);
      attr_dev(feBlend, "mode", "normal");
      attr_dev(feBlend, "in", "componentTransfer");
      attr_dev(feBlend, "in2", "SourceGraphic");
      attr_dev(feBlend, "result", "blend");
      add_location(feBlend, file40, 20, 2, 777);
      attr_dev(filter2, "id", "Emerald");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file40, 2, 1, 116);
      attr_dev(svg, "id", "svg-filter-emerald");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file40, 1, 0, 42);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feComponentTransfer);
      append_hydration_dev(feComponentTransfer, feFuncR);
      append_hydration_dev(feComponentTransfer, feFuncG);
      append_hydration_dev(feComponentTransfer, feFuncB);
      append_hydration_dev(feComponentTransfer, feFuncA);
      append_hydration_dev(filter2, feBlend);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Emerald", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Emerald> was created with unknown prop '${key}'`);
  });
  return [];
}
var Emerald = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Emerald",
      options,
      id: create_fragment40.name
    });
  }
};
var Emerald_default = Emerald;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/GreenFall.svelte
var file41 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\GreenFall.svelte";
function create_fragment41(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "0.5 -0.4 0.3332 0 0\n					0 0.4 0.3 0 0\n					0 0 0.5 0 0\n					0 0 0 500 -20");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      add_location(feColorMatrix, file41, 12, 2, 315);
      attr_dev(filter2, "id", "GreenFall");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file41, 2, 1, 122);
      attr_dev(svg, "id", "svg-filter-greenfall");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file41, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GreenFall", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GreenFall> was created with unknown prop '${key}'`);
  });
  return [];
}
var GreenFall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GreenFall",
      options,
      id: create_fragment41.name
    });
  }
};
var GreenFall_default = GreenFall;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Noir.svelte
var file42 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\Noir.svelte";
function create_fragment42(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feBlend0;
  let feBlend1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feBlend1 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "saturate");
      attr_dev(feColorMatrix, "values", "0");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix1");
      add_location(feColorMatrix, file42, 12, 2, 295);
      attr_dev(feBlend0, "mode", "lighten");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "colormatrix1");
      attr_dev(feBlend0, "in2", "colormatrix1");
      attr_dev(feBlend0, "result", "blend");
      add_location(feBlend0, file42, 13, 2, 424);
      attr_dev(feBlend1, "mode", "multiply");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix1");
      attr_dev(feBlend1, "in2", "diffuseLighting");
      attr_dev(feBlend1, "result", "blend1");
      add_location(feBlend1, file42, 14, 2, 546);
      attr_dev(filter2, "id", "Noir");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file42, 2, 1, 107);
      attr_dev(svg, "id", "svg-filter-noir");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file42, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feBlend1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noir", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noir> was created with unknown prop '${key}'`);
  });
  return [];
}
var Noir = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noir",
      options,
      id: create_fragment42.name
    });
  }
};
var Noir_default = Noir;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/NoirLight.svelte
var file43 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\NoirLight.svelte";
function create_fragment43(ctx) {
  let svg;
  let filter2;
  let feColorMatrix0;
  let feBlend0;
  let feBlend1;
  let feColorMatrix1;
  let feBlend2;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix0 = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feBlend1 = svg_element("feBlend");
      feColorMatrix1 = svg_element("feColorMatrix");
      feBlend2 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix0 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix0).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      feColorMatrix1 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix1).forEach(detach_dev);
      feBlend2 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend2).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix0, "type", "saturate");
      attr_dev(feColorMatrix0, "values", "0");
      attr_dev(feColorMatrix0, "x", "0%");
      attr_dev(feColorMatrix0, "y", "0%");
      attr_dev(feColorMatrix0, "width", "100%");
      attr_dev(feColorMatrix0, "height", "100%");
      attr_dev(feColorMatrix0, "in", "SourceGraphic");
      attr_dev(feColorMatrix0, "result", "colormatrix2");
      add_location(feColorMatrix0, file43, 12, 2, 315);
      attr_dev(feBlend0, "mode", "saturation");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "SourceGraphic");
      attr_dev(feBlend0, "in2", "colormatrix2");
      attr_dev(feBlend0, "result", "blend2");
      add_location(feBlend0, file43, 13, 2, 444);
      attr_dev(feBlend1, "mode", "screen");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix2");
      attr_dev(feBlend1, "in2", "blend2");
      attr_dev(feBlend1, "result", "blend3");
      add_location(feBlend1, file43, 14, 2, 571);
      attr_dev(feColorMatrix1, "type", "luminanceToAlpha");
      attr_dev(feColorMatrix1, "x", "0%");
      attr_dev(feColorMatrix1, "y", "0%");
      attr_dev(feColorMatrix1, "width", "100%");
      attr_dev(feColorMatrix1, "height", "100%");
      attr_dev(feColorMatrix1, "in", "blend3");
      attr_dev(feColorMatrix1, "result", "colormatrix3");
      add_location(feColorMatrix1, file43, 15, 2, 687);
      attr_dev(feBlend2, "mode", "exclusion");
      attr_dev(feBlend2, "x", "0%");
      attr_dev(feBlend2, "y", "0%");
      attr_dev(feBlend2, "width", "100%");
      attr_dev(feBlend2, "height", "100%");
      attr_dev(feBlend2, "in", "blend3");
      attr_dev(feBlend2, "in2", "colormatrix3");
      attr_dev(feBlend2, "result", "blend5");
      add_location(feBlend2, file43, 16, 2, 806);
      attr_dev(filter2, "id", "NoirLight");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file43, 2, 1, 122);
      attr_dev(svg, "id", "svg-filter-noirlight");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file43, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix0);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feBlend1);
      append_hydration_dev(filter2, feColorMatrix1);
      append_hydration_dev(filter2, feBlend2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NoirLight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NoirLight> was created with unknown prop '${key}'`);
  });
  return [];
}
var NoirLight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NoirLight",
      options,
      id: create_fragment43.name
    });
  }
};
var NoirLight_default = NoirLight;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Rustic.svelte
var file44 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\Rustic.svelte";
function create_fragment44(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 \n					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 \n					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  \n					0 0 0 1 0");
      add_location(feColorMatrix, file44, 3, 2, 235);
      attr_dev(filter2, "id", "Rustic");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file44, 2, 1, 113);
      attr_dev(svg, "id", "svg-filter-rustic");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file44, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rustic", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rustic> was created with unknown prop '${key}'`);
  });
  return [];
}
var Rustic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rustic",
      options,
      id: create_fragment44.name
    });
  }
};
var Rustic_default = Rustic;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Summer84.svelte
var file45 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\Summer84.svelte";
function create_fragment45(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.300 0.200 0.000 0.000 0.000 \n					0.300 0.600 0.200 0.000 0.000 \n					0.200 1.000 0.200 0.000 0.000 \n					0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file45, 3, 2, 243);
      attr_dev(filter2, "id", "Summer84");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file45, 2, 1, 119);
      attr_dev(svg, "id", "svg-filter-summer84");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file45, 1, 0, 44);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Summer84", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Summer84> was created with unknown prop '${key}'`);
  });
  return [];
}
var Summer84 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Summer84",
      options,
      id: create_fragment45.name
    });
  }
};
var Summer84_default = Summer84;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/XPro.svelte
var file46 = "node_modules\\@skeletonlabs\\skeleton\\dist\\actions\\Filters\\svg-filters\\XPro.svelte";
function create_fragment46(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.70 -0.20 0.00 0.00 0.00 \n                    0.10 0.800 0.30 0.00 0.00 \n                    0.20 0.300 0.50 0.00 0.00 \n                    0.00 0.00 0.00 1.00 0.00");
      add_location(feColorMatrix, file46, 3, 2, 227);
      attr_dev(filter2, "id", "XPro");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file46, 2, 1, 107);
      attr_dev(svg, "id", "svg-filter-xpro");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file46, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XPro", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XPro> was created with unknown prop '${key}'`);
  });
  return [];
}
var XPro = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XPro",
      options,
      id: create_fragment46.name
    });
  }
};
var XPro_default = XPro;
export {
  Accordion_default as Accordion,
  AccordionItem_default as AccordionItem,
  Apollo_default as Apollo,
  AppBar_default as AppBar,
  AppRail_default as AppRail,
  AppRailAnchor_default as AppRailAnchor,
  AppRailTile_default as AppRailTile,
  AppShell_default as AppShell,
  Autocomplete_default as Autocomplete,
  Avatar_default as Avatar,
  BlueNight_default as BlueNight,
  CodeBlock_default as CodeBlock,
  ConicGradient_default as ConicGradient,
  Drawer_default as Drawer,
  Emerald_default as Emerald,
  FileButton_default as FileButton,
  FileDropzone_default as FileDropzone,
  GreenFall_default as GreenFall,
  InputChip_default as InputChip,
  LightSwitch_default as LightSwitch,
  ListBox_default as ListBox,
  ListBoxItem_default as ListBoxItem,
  Modal_default as Modal,
  Noir_default as Noir,
  NoirLight_default as NoirLight,
  Paginator_default as Paginator,
  ProgressBar_default as ProgressBar,
  ProgressRadial_default as ProgressRadial,
  RadioGroup_default as RadioGroup,
  RadioItem_default as RadioItem,
  RangeSlider_default as RangeSlider,
  Ratings_default as Ratings,
  Rustic_default as Rustic,
  SlideToggle_default as SlideToggle,
  Step_default as Step,
  Stepper_default as Stepper,
  Summer84_default as Summer84,
  Tab_default as Tab,
  TabAnchor_default as TabAnchor,
  TabGroup_default as TabGroup,
  Table_default as Table,
  TableOfContents_default as TableOfContents,
  Toast_default as Toast,
  TreeView_default as TreeView,
  TreeViewItem_default as TreeViewItem,
  XPro_default as XPro,
  autoModeWatcher,
  clipboard,
  createDataTableStore,
  dataTableHandler,
  drawerStore,
  filter,
  focusTrap,
  getModeAutoPrefers,
  getModeOsPrefers,
  getModeUserPrefers,
  localStorageStore,
  modalStore,
  modeCurrent,
  modeOsPrefers,
  modeUserPrefers,
  popup,
  setInitialClassState,
  setModeCurrent,
  setModeUserPrefers,
  storeHighlightJs,
  storePopup,
  tableA11y,
  tableInteraction,
  tableMapperValues,
  tableSourceMapper,
  tableSourceValues,
  toastStore
};
//# sourceMappingURL=@skeletonlabs_skeleton.js.map
